\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\album\[album_title]\[album_id]\page.tsx
"use client";
import { Album } from "@/rework/components/main/album/Album";
import { Spinner } from "@/rework/components/extra/Spinner";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { useQuery } from "@tanstack/react-query";
import { useParams } from "next/navigation";
import { TryAgain } from "@/rework/components/extra/TryAgain";

export default function AlbumPage() {
  const { album_id } = useParams() as {
    album_id: string;
  };
  const {
    data: album,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["soundcloudAlbum", album_id],
    queryFn: () =>
      SoundCloudKit.getData(album_id, "albums", {
        include: ["spotlight", "latest"],
      }),
    enabled: !!album_id,
    retry: false,
    refetchOnWindowFocus: false,
  });
  if (!album_id)
    return <p className="text-[--systemSecondary]">No album found.</p>;
  if (isLoading) return <Spinner />;
  if (error) {
    return (
      <TryAgain
        errorName={(error as Error).name}
        errorMessage={(error as Error).message}
        onTryAgain={() => refetch()}
      />
    );
  }
  return album && <Album data={album} />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\artist\[artist_name]\[artist_id]\page.tsx
"use client";
import { Banner } from "@/rework/components/main/artist/banner/Banner";
import { Spotlight } from "@/rework/components/main/artist/Spotlight";
import { Latest } from "@/rework/components/main/artist/Latest";
import { Spinner } from "@/rework/components/extra/Spinner";
import { SoundCloudArtist } from "@/lib/types/soundcloud";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { useQuery } from "@tanstack/react-query";
import { useParams } from "next/navigation";
import { TryAgain } from "@/rework/components/extra/TryAgain";

async function fetchArtistData(artistId: string, _artistName: string) {
  const data = (await SoundCloudKit.getData(artistId, "artist", {
    include: ["spotlight", "latest"],
  })) as SoundCloudArtist;
  return data;
}

const soundCloudOfficial = ["music-charts-us"];

export default function ArtistPage() {
  const { artist_name, artist_id } = useParams() as {
    artist_name: string;
    artist_id: string;
  };
  const {
    data: artist,
    isLoading,
    error,
    refetch,
  } = useQuery<SoundCloudArtist>({
    queryKey: ["soundcloud_artist", artist_id],
    queryFn: () => fetchArtistData(artist_id, artist_name),
    // only run if artist_id is truthy
    enabled: !!artist_id,
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });

  if (soundCloudOfficial.includes(artist_name)) {
    return (
      <p className="text-[--systemSecondary]">
        This type of artist page is unavailable
      </p>
    );
  }

  if (isLoading) {
    return <Spinner />;
  }

  if (error) {
    return (
      <TryAgain
        errorName={(error as Error).name}
        errorMessage={(error as Error).message}
        onTryAgain={() => refetch()}
      />
    );
  }

  if (!artist) {
    return <p className="text-[--systemSecondary]">No artist found.</p>;
  }

  return (
    <>
      <Banner artist={artist} />
      <div className="flex pb-12">
        <Latest artist={artist} />
        <Spotlight artist={artist} />
      </div>
    </>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\artist\[artist_name]\[artist_id]\see-all\page.tsx
export default function SeeAllPage() {
  return (
    <div>
      <p>See All Page isn&apos;t finished yet</p>
    </div>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\library\albums\page.tsx
import { LibraryAlbums } from "@/rework/components/main/library/albums/LibraryAlbums";
import { conf } from "@/lib/config";
import { Metadata } from "next";

const config = conf();
export const metadata: Metadata = {
  title: `Library | ${config.APP_NAME}`,
};

export default async function LibraryAlbumsPage() {
  return <LibraryAlbums />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\library\artists\page.tsx
import { LibraryArtists } from "@/rework/components/main/library/artist/LibraryArtists";
import { conf } from "@/lib/config";
import { Metadata } from "next";

const config = conf();
export const metadata: Metadata = {
  title: `Library | ${config.APP_NAME}`,
};

export default async function LibraryArtistsPage() {
  return <LibraryArtists />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\library\recently-added\page.tsx
import { RecentlyAdded } from "@/rework/components/main/library/recently-added/RecentlyAdded";
import { conf } from "@/lib/config";
import { Metadata } from "next";

const config = conf();
export const metadata: Metadata = {
  title: `Library | ${config.APP_NAME}`,
};

export default async function LibraryRecentlyAddedPage() {
  return <RecentlyAdded />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\library\songs\page.tsx
import LibrarySongs from "@/rework/components/main/library/LibraryPage";
import { conf } from "@/lib/config";
import { Metadata } from "next";

const config = conf();
export const metadata: Metadata = {
  title: `Library | ${config.APP_NAME}`,
};

export default async function LibrarySongsPage() {
  return <LibrarySongs />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\me\likes\page.tsx
"use client";
import { useUser } from "@/hooks/useUser";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { Spinner } from "@/rework/components/extra/Spinner";
import { useQuery } from "@tanstack/react-query";
import UserLikedSongs from "@/rework/components/main/library/me/UserLikesPage";
import { TryAgain } from "@/rework/components/extra/TryAgain";

export default function UserLikes() {
  const { settings } = useUser();
  const {
    data: user,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["soundcloudUserID", settings?.soundcloudUserId],
    queryFn: () => SoundCloudKit.getUserData(settings!.soundcloudUserId),
    enabled: !!settings,
    retry: false,
    refetchOnWindowFocus: false,
  });
  if (!settings) return <p className="text-[--systemSecondary]">Loading user data.</p>;
  if (isLoading) return <Spinner />;
  if (error) {
    return (
      <TryAgain
        errorName={(error as Error).name}
        errorMessage={(error as Error).message}
        onTryAgain={() => refetch()}
      />
    );
  }

  return <UserLikedSongs user={user} />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\me\playlists\page.tsx
"use client";
import { useUser } from "@/hooks/useUser";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { Spinner } from "@/rework/components/extra/Spinner";
import { TryAgain } from "@/rework/components/extra/TryAgain";
import { useQuery } from "@tanstack/react-query";

export default function UserPlaylist() {
  const { settings } = useUser();
  console.log("Settings", settings);
  const {
    data: user,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["soundcloudUserID", settings?.soundcloudUserId],
    queryFn: () => SoundCloudKit.getUserData(settings!.soundcloudUserId),
    enabled: !!settings,
    retry: false,
    refetchOnWindowFocus: false,
  });
  if (!settings)
    return <p className="text-[--systemSecondary]">Loading user data.</p>;
  if (isLoading) return <Spinner />;
  if (error) {
    return (
      <TryAgain
        errorName={(error as Error).name}
        errorMessage={(error as Error).message}
        onTryAgain={() => refetch()}
      />
    );
  }
  console.log("User", user);

  return (
    <div>
      <h1>User Playlist</h1>
      <h2>Settings COlor:</h2>
    </div>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\playlist\[playlist_id]\page.tsx
export default function PlaylistPage() {
  return (
    <div>
      <p>Playlist page isn&apos;t finished yet</p>
    </div>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\rooms\[url]\page.tsx
"use client";
import { useParams } from "next/navigation";

export default function Rooms() {
  //   const [song, setSong] = useState<SoundCloudTrack | null>(null);
  const { url } = useParams() as {
    url: string;
  };

  return (
    <div>
      {url}
      <p>Rooms page isn&apos;t finished yet</p>
    </div>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\search\page.tsx
"use client";
import { Banner } from "@/rework/components/navigation/search/page/Banner";
import { Spinner } from "@/rework/components/extra/Spinner";
import { useQuery } from "@tanstack/react-query";
import { useSearchParams } from "next/navigation";
import SearchResults from "@/rework/components/navigation/search/page/SearchResults";
import { TryAgain } from "@/rework/components/extra/TryAgain";
import { Suspense } from "react";

const fetchSoundCloudResults = async (query: string | null) => {
  if (!query) return null;
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    controller.abort(); // abort the request
  }, 15000); // 15s
  try {
    const response = await fetch(
      `/api/soundcloud/search?q=${encodeURIComponent(query)}&type=full`,
      { signal: controller.signal }
    );
    if (!response.ok) {
      throw new Error("Failed to fetch search results");
    }
    return await response.json();
  } finally {
    clearTimeout(timeoutId);
  }
};

// Create a separate component that uses useSearchParams
function SearchContent() {
  const searchParams = useSearchParams();
  const query = searchParams?.get("q") || "";

  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ["soundcloudSearch", query],
    queryFn: () => fetchSoundCloudResults(query),
    enabled: Boolean(query),
    staleTime: 60_000, // 1 minute
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });

  if (!searchParams) return null;

  if (!data) {
    return (
      <div>
        <Banner query={query} />
        {isLoading && <Spinner />}
        {error && (
          <TryAgain
            errorMessage={(error as Error).message}
            errorName={(error as Error).name}
            onTryAgain={() => {
              refetch();
            }}
          />
        )}
      </div>
    );
  } else {
    return (
      <div>
        <Banner query={query} />
        <SearchResults data={data} />
      </div>
    );
  }
}

// Main page component with Suspense
export default function Search() {
  return (
    <Suspense
      fallback={
        <div className="w-full h-screen flex items-center justify-center">
          <Spinner />
        </div>
      }
    >
      <SearchContent />
    </Suspense>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\settings\page.tsx
"use client";
import { SafeView } from "@/components/mobile/SafeView";
import { useState, useEffect, useRef } from "react";
import { useUser } from "@clerk/nextjs";
import {
  IoColorPaletteOutline,
  IoPersonOutline,
  IoSearchOutline,
  IoMenuOutline,
  IoMusicalNotesOutline,
} from "react-icons/io5";
import { showToast } from "@/hooks/useToast";
import { Spinner } from "@/rework/components/extra/Spinner";
import { Switch } from "@/rework/components/controls/Switch";

export default function SettingsPage() {
  const { user, isLoaded } = useUser();
  const [username, setUsername] = useState("");
  const [themeColor, setThemeColor] = useState("#5891fa"); // Default color
  const [highlightedQueries, setHighlightedQueries] = useState(false);
  const [showSidebarIcons, setShowSidebarIcons] = useState(true);
  const [soundcloudUserId, setSoundcloudUserId] = useState("");
  const [saving, setSaving] = useState(false);
  const colorInputRef = useRef<HTMLInputElement>(null);

  // Predefined color options
  const colorOptions = [
    { name: "Blue", value: "#5891fa" },
    { name: "Purple", value: "#8a4fff" },
    { name: "Green", value: "#4caf50" },
    { name: "Pink", value: "#ff4fa9" },
    { name: "Orange", value: "#ff9800" },
    { name: "Red", value: "#f44336" },
    { name: "Teal", value: "#009688" },
  ];

  useEffect(() => {
    if (isLoaded && user) {
      setUsername(user.username || "");
      fetchUserSettings();
    }
  }, [isLoaded, user]);

  // Set the CSS variable when themeColor changes (e.g., on mount or save)
  useEffect(() => {
    if (themeColor) {
      document.documentElement.style.setProperty("--keyColor", themeColor);
    }
  }, [themeColor]);

  const fetchUserSettings = async () => {
    try {
      const response = await fetch("/api/user/settings");
      if (response.ok) {
        const data = await response.json();
        if (data.themeColor) {
          setThemeColor(data.themeColor);
        }
        setHighlightedQueries(data.highlightedQueries || false);
        setShowSidebarIcons(data.showSidebarIcons !== false); // Default to true if not set
        setSoundcloudUserId(data.soundcloudUserId || "");
      }
    } catch (error) {
      console.error("Error fetching user settings:", error);
    }
  };

  const updateUsername = async () => {
    if (!user) return;
    setSaving(true);
    try {
      await user.update({ username });
      showToast("success", "Username updated successfully");
    } catch (error) {
      console.error("Error updating username:", error);
      const errorMessage = error instanceof Error ? error.message : "";
      if (
        errorMessage.includes(
          "Username must be between 4 and 64 characters long"
        )
      ) {
        showToast("error", "Username must be between 4 and 64 characters long");
      } else {
        showToast("error", "Failed to update username");
      }
    } finally {
      setSaving(false);
    }
  };

  const handleColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Update CSS variable directly for real-time preview
    document.documentElement.style.setProperty("--keyColor", e.target.value);
  };

  const handleSaveThemeColor = async () => {
    if (colorInputRef.current) {
      const selectedColor = colorInputRef.current.value;
      setThemeColor(selectedColor); // Update state
      try {
        const response = await fetch("/api/user/settings", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ themeColor: selectedColor }),
        });
        if (response.ok) {
          showToast("success", "Theme color updated");
        } else {
          showToast("error", "Failed to save theme color");
        }
      } catch (error) {
        console.error("Error updating theme color:", error);
        showToast("error", "Failed to save theme color");
      }
    }
  };

  const updateSetting = async (settingName: string, value: any) => {
    try {
      const response = await fetch("/api/user/settings", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ [settingName]: value }),
      });

      if (response.ok) {
        showToast("success", "Setting updated");
        return true;
      } else {
        showToast("error", "Failed to save setting");
        return false;
      }
    } catch (error) {
      console.error(`Error updating ${settingName}:`, error);
      showToast("error", "Failed to save setting");
      return false;
    }
  };

  const toggleHighlightedQueries = async () => {
    const newValue = !highlightedQueries;
    setHighlightedQueries(newValue);
    await updateSetting("highlightedQueries", newValue);
  };

  const toggleShowSidebarIcons = async () => {
    const newValue = !showSidebarIcons;
    setShowSidebarIcons(newValue);
    await updateSetting("showSidebarIcons", newValue);
  };

  const saveSoundcloudUserId = async () => {
    const trimmedId = soundcloudUserId.trim();
    await updateSetting("soundcloudUserId", trimmedId || null);
  };

  if (!isLoaded) {
    return (
      <SafeView className="w-full">
        <h1 className="text-3xl font-bold mb-4">Settings</h1>
        <Spinner />
      </SafeView>
    );
  }

  return (
    <div className="pb-20 p-4 w-full">
      <div className="mb-4">
        <h1 className="text-3xl font-bold">Settings</h1>
        <p className="text-[--systemSecondary]">
          Manage your personal details and preferences
        </p>
      </div>

      <div className="space-y-8">
        {/* Profile Section */}
        <section>
          <h2 className="text-xl font-semibold select-none flex items-center gap-2 mb-4">
            <IoPersonOutline /> Profile
          </h2>
          <div className="space-y-4">
            <div>
              <label
                htmlFor="username"
                className="block select-none text-sm font-medium mb-1"
              >
                Username
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  id="username"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyDown={(e) => {
                    if (
                      e.key === "Enter" &&
                      username &&
                      username !== user?.username
                    ) {
                      updateUsername();
                    }
                  }}
                  className="p-2 bg-background border border-labelDivider rounded-xl w-full placeholder:text-[--systemSecondary]"
                  placeholder="Enter username"
                />
                <button
                  onClick={updateUsername}
                  disabled={saving || !username || username === user?.username}
                  className="px-4 py-2 select-none bg-background border border-labelDivider rounded-xl hover:bg-systemToolbarTitlebar transition-colors disabled:opacity-50"
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        </section>

        {/* SoundCloud Section */}
        <section>
          <h2 className="text-xl font-semibold select-none flex items-center gap-2 mb-4">
            <IoMusicalNotesOutline /> SoundCloud Integration
          </h2>
          <div className="space-y-4">
            <div>
              <label
                htmlFor="soundcloud-userid"
                className="block select-none text-sm font-medium mb-1"
              >
                SoundCloud User ID
              </label>
              <p className="text-sm text-[--systemSecondary] mb-2">
                Enter your SoundCloud User ID to access your playlists, likes,
                and more
              </p>
              <div className="flex gap-2">
                <input
                  type="text"
                  id="soundcloud-userid"
                  value={soundcloudUserId}
                  onChange={(e) => setSoundcloudUserId(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") {
                      saveSoundcloudUserId();
                    }
                  }}
                  className="p-2 bg-background border border-labelDivider rounded-xl w-full placeholder:text-[--systemSecondary]"
                  placeholder="e.g. 123456789"
                />
                <button
                  onClick={saveSoundcloudUserId}
                  className="px-4 py-2 select-none bg-background border border-labelDivider rounded-xl hover:bg-systemToolbarTitlebar transition-colors"
                >
                  Save
                </button>
              </div>
              <p className="text-xs text-[--systemSecondary] mt-1">
                You can find your User ID in your SoundCloud profile URL or
                settings
              </p>
            </div>
          </div>
        </section>

        {/* Appearance Section */}
        <section>
          <h2 className="text-xl font-semibold select-none flex items-center gap-2 mb-4">
            <IoColorPaletteOutline /> Appearance
          </h2>
          <div>
            <label className="block text-sm font-medium mb-2 select-none">
              Theme Color
            </label>
            <div className="flex flex-wrap gap-2">
              {colorOptions.map((color) => (
                <button
                  key={color.value}
                  onClick={() => {
                    if (colorInputRef.current) {
                      colorInputRef.current.value = color.value;
                      document.documentElement.style.setProperty(
                        "--keyColor",
                        color.value
                      );
                    }
                  }}
                  className={`w-12 h-12 rounded-full flex items-center justify-center transition-transform ${
                    themeColor === color.value
                      ? "ring-2 ring-offset-2 scale-110"
                      : ""
                  }`}
                  style={{ backgroundColor: color.value }}
                  title={color.name}
                />
              ))}
            </div>
          </div>

          {/* Custom color picker */}
          <div className="mt-4">
            <label
              htmlFor="custom-color"
              className="block select-none text-sm font-medium mb-2"
            >
              Custom Color
            </label>
            <div className="flex gap-2 items-center">
              <input
                type="color"
                id="custom-color"
                defaultValue={themeColor} // Uncontrolled input
                ref={colorInputRef}
                onChange={handleColorChange}
                className="w-10 h-10 rounded cursor-pointer"
              />
              <span className="text-sm">{themeColor}</span>
              <button
                onClick={handleSaveThemeColor}
                className="px-4 py-2 select-none bg-background border border-labelDivider rounded-xl hover:bg-systemToolbarTitlebar transition-colors disabled:opacity-50"
              >
                Save
              </button>
            </div>
          </div>
        </section>

        {/* Search Settings */}
        <section>
          <h2 className="text-xl font-semibold select-none flex items-center gap-2 mb-4">
            <IoSearchOutline /> Search
          </h2>
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="font-medium">Highlight search queries</h3>
                <p className="text-sm text-[--systemSecondary]">
                  Highlight matching text in search results
                </p>
              </div>
              <Switch
                checked={highlightedQueries}
                onCheckedChange={toggleHighlightedQueries}
                id="show-sidebar-icons"
              />
            </div>
          </div>
        </section>

        {/* Sidebar Settings */}
        <section>
          <h2 className="text-xl font-semibold select-none flex items-center gap-2 mb-4">
            <IoMenuOutline /> Sidebar
          </h2>
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="font-medium">Show sidebar icons</h3>
                <p className="text-sm text-[--systemSecondary]">
                  Display icons next to sidebar menu items
                </p>
              </div>
              <Switch
                checked={showSidebarIcons}
                onCheckedChange={toggleShowSidebarIcons}
                id="show-sidebar-icons"
              />
            </div>
          </div>
        </section>
      </div>
    </div>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\sign-in\[[...sign-in]]\page.tsx
import { SignIn } from "@clerk/nextjs";

export default function Page() {
  return <SignIn />;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\(pages)\song\[song_title]\[song_id]\page.tsx
"use client";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { SoundCloudTrack } from "@/lib/types/soundcloud";
import { dev } from "@/lib/utils";
import { useParams } from "next/navigation";
import { useEffect, useState } from "react";

export default function Song() {
  const [song, setSong] = useState<SoundCloudTrack | null>(null);
  const { song_title, song_id } = useParams() as {
    song_title: string;
    song_id: string;
  };
  useEffect(() => {
    const fetchSong = async () => {
      const data = (await SoundCloudKit.getData(
        song_id,
        "songs"
      )) as SoundCloudTrack;
      dev.log("fetchSong | SoundCloudKit.getData", data);
      setSong(data);
    };
    fetchSong();
  }, [song_id, song_title]);
  return <div>{song?.title}</div>;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\api\prefetch-images\[...rest]\route.ts
import { NextRequest, NextResponse } from "next/server";
import { parseHTML } from "linkedom";

export const dynamic = "force-static";

function getHostname() {
  if (process.env.NODE_ENV === "development") {
    return "localhost:3000";
  }
  if (process.env.VERCEL_ENV === "production") {
    return process.env.VERCEL_PROJECT_PRODUCTION_URL;
  }
  return process.env.VERCEL_BRANCH_URL;
}

export async function GET(
  _: NextRequest,
  { params }: { params: { rest: string[] } }
) {
  const schema = process.env.NODE_ENV === "development" ? "http" : "https";
  const host = getHostname();
  if (!host) {
    return new Response("Failed to get hostname from env", { status: 500 });
  }
  const href = (await params).rest.join("/");
  if (!href) {
    return new Response("Missing url parameter", { status: 400 });
  }
  const url = `${schema}://${host}/${href}`;
  const response = await fetch(url);
  if (!response.ok) {
    return new Response("Failed to fetch", { status: response.status });
  }
  const body = await response.text();
  const { document } = parseHTML(body);
  const images = Array.from(document.querySelectorAll("main img"))
    .map((img: any) => ({
      srcset: img.getAttribute("srcset") || img.getAttribute("srcSet"), // Linkedom is case-sensitive
      sizes: img.getAttribute("sizes"),
      src: img.getAttribute("src"),
      alt: img.getAttribute("alt"),
      loading: img.getAttribute("loading"),
    }))
    .filter((img) => img.src);
  return NextResponse.json(
    { images },
    {
      headers: {
        "Cache-Control": "public, max-age=3600",
      },
    }
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\api\streams\[trackId]\route.ts
import { NextResponse } from "next/server";
import { SoundCloudKit } from "@/lib/audio/fetchers";

export async function GET(
  req: Request,
  { params }: { params: { trackId: string } }
) {
  // Note: `await params` is incorrect; params is not a Promise. Fix this by removing `await`.
  const { trackId } = await params; // Correct destructuring

  try {
    const songData = await SoundCloudKit.getData(trackId, "songs");
    const transcodingUrl = songData.media.transcodings.find(
      (t: any) => t.format.protocol === "hls"
    )?.url;

    if (!transcodingUrl) {
      throw new Error("No HLS transcoding URL found");
    }

    // Ensure API key and client_id are available
    const apiKey = process.env.SOUNDCLOUD_API_KEY;
    const clientId = process.env.SOUNDCLOUD_CLIENT_ID;
    if (!apiKey || !clientId) {
      throw new Error(
        "SoundCloud API key or client ID is not configured in environment variables"
      );
    }

    // Fetch with Authorization header and client_id query parameter
    const response = await fetch(`${transcodingUrl}?client_id=${clientId}`, {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    });

    if (!response.ok) {
      console.error(
        `Fetch failed with status: ${response.status}`,
        await response.text()
      );
      throw new Error("Failed to fetch m3u8 URL");
    }

    const data = await response.json();
    return NextResponse.json({ url: data.url }, { status: 200 });
  } catch (err) {
    console.error(`Error fetching stream URL for track ${trackId}:`, err);
    return NextResponse.json(
      { error: "Could not retrieve stream URL" },
      { status: 500 }
    );
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\api\user\settings\route.ts
"use server";
import { NextResponse } from "next/server";
import { auth, currentUser } from "@clerk/nextjs/server";
import prisma from "@/lib/prisma";

// Get or create user settings for the current user
async function getOrCreateUserSettings(userId: string) {
  // First check if the user exists, if not create them
  let user = await prisma.user.findUnique({ where: { id: userId } });

  // If user doesn't exist yet, we need to create them
  if (!user) {
    const clerkUser = await currentUser();
    if (!clerkUser) {
      throw new Error("Failed to get current user");
    }

    user = await prisma.user.create({
      data: {
        id: userId,
        email: clerkUser.primaryEmailAddress?.emailAddress || "",
        firstName: clerkUser.firstName || null,
        lastName: clerkUser.lastName || null,
        username: clerkUser.username || null,
      },
    });
  }

  // Now get or create the user settings
  let settings = await prisma.userSettings.findUnique({
    where: { userId },
  });

  if (!settings) {
    settings = await prisma.userSettings.create({
      data: {
        userId,
        themeColor: "#5891fa", // Default theme color
        highlightedQueries: false, // Default search setting
        showSidebarIcons: true, // Default sidebar setting
        soundcloudUserId: null, // Default to no SoundCloud User ID
      },
    });
  }

  return settings;
}

// GET: Retrieve user's settings
export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const settings = await getOrCreateUserSettings(userId);

    return NextResponse.json(settings);
  } catch (err) {
    console.error(`Error fetching user settings: ${String(err)}`);
    return NextResponse.json(
      { error: "Failed to retrieve user settings" },
      { status: 500 }
    );
  }
}

// PUT: Update user settings
export async function PUT(req: Request) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const data = await req.json();

    // Validate theme color if provided
    if (data.themeColor && !/^#[0-9A-F]{6}$/i.test(data.themeColor)) {
      return NextResponse.json(
        { error: "Invalid theme color format. Use hex format (e.g., #5891fa)" },
        { status: 400 }
      );
    }

    // Get current settings or create them if they don't exist
    await getOrCreateUserSettings(userId);

    // Update the settings
    const settings = await prisma.userSettings.update({
      where: { userId },
      data: {
        // Only update fields that were provided in the request
        ...(data.themeColor !== undefined && { themeColor: data.themeColor }),
        ...(data.highlightedQueries !== undefined && {
          highlightedQueries: data.highlightedQueries,
        }),
        ...(data.showSidebarIcons !== undefined && {
          showSidebarIcons: data.showSidebarIcons,
        }),
        ...(data.soundcloudUserId !== undefined && {
          soundcloudUserId: data.soundcloudUserId,
        }),
      },
    });

    return NextResponse.json(settings);
  } catch (err) {
    console.error(`Error updating user settings: ${String(err)}`);
    return NextResponse.json(
      { error: "Failed to update user settings" },
      { status: 500 }
    );
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\api\user\songs\route.ts
"use server";
import { NextResponse } from "next/server";
import { auth, currentUser } from "@clerk/nextjs/server";
import prisma from "@/lib/prisma";

// 1) Create or find local user
async function getOrCreateUser(userId: string, email: string) {
  let user = await prisma.user.findUnique({ where: { id: userId } });
  if (!user) {
    user = await prisma.user.create({
      data: {
        id: userId,
        email: email,
      },
    });
  }
  return user;
}

// 2) Create or find library
async function getOrCreateLibrary(userId: string) {
  let library = await prisma.library.findFirst({ where: { userId } });
  if (!library) {
    library = await prisma.library.create({
      data: {
        userId,
      },
    });
  }
  return library;
}

// **GET: Retrieve user's library songs**
export async function GET() {
  try {
    const { userId } = await auth();
    const user = await currentUser();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    await getOrCreateUser(
      userId,
      user?.primaryEmailAddress?.emailAddress ?? ""
    );

    // Then get or create the library
    const library = await getOrCreateLibrary(userId);

    // Now fetch the library with songs
    const libraryWithSongs = await prisma.library.findUnique({
      where: { id: library.id },
      include: { songs: true },
    });

    return NextResponse.json(libraryWithSongs?.songs || [], { status: 200 });
  } catch (err) {
    console.error(`Error fetching library: ${String(err)}`);
    return NextResponse.json(
      { error: "Failed to retrieve library" },
      { status: 500 }
    );
  }
}
// **POST: Add song to library**
export async function POST(req: Request) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { soundcloudId } = await req.json();
    if (!soundcloudId) {
      return NextResponse.json(
        { error: "SoundCloud ID is required" },
        { status: 400 }
      );
    }

    const library = await getOrCreateLibrary(userId);

    // Create song if it doesn't exist and add to library
    await prisma.$transaction(async (tx) => {
      // Try to create the song (if it exists, this will be skipped)
      await tx.song.upsert({
        where: { id: soundcloudId },
        update: {}, // No updates if it exists
        create: { id: soundcloudId },
      });

      // Add song to library
      await tx.library.update({
        where: { id: library.id },
        data: {
          songs: {
            connect: { id: soundcloudId },
          },
        },
      });
    });

    return NextResponse.json(
      { success: true, message: "Song added to library" },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error adding song:", error);
    return NextResponse.json(
      { error: "Failed to add song to library" },
      { status: 500 }
    );
  }
}

// **DELETE: Remove song from library**
export async function DELETE(req: Request) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    console.log("DELETE | userId", userId);

    const { soundcloudId } = await req.json();
    console.log("DELETE | soundcloudId", soundcloudId);
    if (!soundcloudId) {
      return NextResponse.json(
        { error: "SoundCloud ID is required" },
        { status: 400 }
      );
    }

    const library = await getOrCreateLibrary(userId);
    console.log("DELETE | library", library);

    await prisma.library.update({
      where: { id: library.id },
      data: {
        songs: {
          disconnect: { id: soundcloudId },
        },
      },
    });

    return NextResponse.json(
      { success: true, message: "Song removed from library" },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error removing song:", error);
    return NextResponse.json(
      { error: "Failed to remove song from library" },
      { status: 500 }
    );
  }
}

\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\layout.tsx
import type { Metadata } from "next";
import { ThemeProvider as NextThemeProvider } from "@/components/theme-provider";
import type { Viewport } from "next";
import { Toaster } from "react-hot-toast";
import { Content } from "@/rework/components/main/Content";
import ReactQueryWrapper from "@/providers/QueryWrapper";
import "../rework/global.css";
import { Audio } from "@/rework/components/player/Audio";
import { ClerkProvider } from "@clerk/nextjs";
import "react-contexify/dist/ReactContexify.css";
import "../styles/contexifyGaku.css";
import "../styles/playercontrols.css";
import { contextMenus } from "@/rework/components/contextmenus/contextMenus";
import { ThemeProvider } from "@/providers/ThemeProvider";

export const metadata: Metadata = {
  title: "Gaku",
  description: "A SoundCloud Client",
  applicationName: "Gaku",
  appleWebApp: {
    capable: true,
    title: "Gaku",
    statusBarStyle: "black-translucent",
  },
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  viewportFit: "cover",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider
      publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}
    >
      <html lang="en" suppressHydrationWarning={true}>
        <head>
          <script src="./chromium-lyrics-style-fix.js" defer />
          <link rel="manifest" href="/manifest.json" />
          <link
            rel="preload"
            href="/assets/fonts/SFNS.woff2"
            as="font"
            type="font/woff2"
            crossOrigin="anonymous"
          />
          <link
            rel="preload"
            href="/assets/fonts/SFNSItalic.woff2"
            as="font"
            type="font/woff2"
            crossOrigin="anonymous"
          />
          <link
            rel="preload"
            href="/assets/fonts/SFNSRounded.woff2"
            as="font"
            type="font/woff2"
            crossOrigin="anonymous"
          />

          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/12.9__iPad_Pro_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/10.5__iPad_Air_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/11__iPad_Pro__10.5__iPad_Pro_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_14_Plus__iPhone_13_Pro_Max__iPhone_12_Pro_Max_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 1032px) and (device-height: 1376px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/13__iPad_Pro_M4_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_15_Pro_Max__iPhone_15_Plus__iPhone_14_Pro_Max_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_13_mini__iPhone_12_mini__iPhone_11_Pro__iPhone_XS__iPhone_X_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/10.2__iPad_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_8__iPhone_7__iPhone_6s__iPhone_6__4.7__iPhone_SE_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/4__iPhone_SE__iPod_touch_5th_generation_and_later_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 820px) and (device-height: 1180px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/10.9__iPad_Air_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/11__iPad_Pro__10.5__iPad_Pro_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_14_Plus__iPhone_13_Pro_Max__iPhone_12_Pro_Max_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_11__iPhone_XR_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_13_mini__iPhone_12_mini__iPhone_11_Pro__iPhone_XS__iPhone_X_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1210px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/11__iPad_Pro_M4_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_14__iPhone_13_Pro__iPhone_13__iPhone_12_Pro__iPhone_12_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_15_Pro_Max__iPhone_15_Plus__iPhone_14_Pro_Max_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_11_Pro_Max__iPhone_XS_Max_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_14__iPhone_13_Pro__iPhone_13__iPhone_12_Pro__iPhone_12_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_8__iPhone_7__iPhone_6s__iPhone_6__4.7__iPhone_SE_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 820px) and (device-height: 1180px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/10.9__iPad_Air_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/12.9__iPad_Pro_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 1032px) and (device-height: 1376px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/13__iPad_Pro_M4_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/10.5__iPad_Air_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 834px) and (device-height: 1210px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/11__iPad_Pro_M4_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/10.2__iPad_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_15_Pro__iPhone_15__iPhone_14_Pro_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 744px) and (device-height: 1133px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/8.3__iPad_Mini_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/9.7__iPad_Pro__7.9__iPad_mini__9.7__iPad_Air__9.7__iPad_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_8_Plus__iPhone_7_Plus__iPhone_6s_Plus__iPhone_6_Plus_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_11__iPhone_XR_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 744px) and (device-height: 1133px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
            href="/assets/splash_screens/8.3__iPad_Mini_landscape.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_8_Plus__iPhone_7_Plus__iPhone_6s_Plus__iPhone_6_Plus_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/9.7__iPad_Pro__7.9__iPad_mini__9.7__iPad_Air__9.7__iPad_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
            href="/assets/splash_screens/4__iPhone_SE__iPod_touch_5th_generation_and_later_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
            href="/assets/splash_screens/iPhone_15_Pro__iPhone_15__iPhone_14_Pro_portrait.png"
          />
          <link
            rel="apple-touch-startup-image"
            media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
            href="/assets/splash_screens/iPhone_11_Pro_Max__iPhone_XS_Max_landscape.png"
          />
          <meta name="mobile-web-app-capable" content="yes" />
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta
            name="apple-mobile-web-app-status-bar-style"
            content="black-translucent"
          />
          <meta
            name="viewport"
            content="width=device-width, initial-scale=1, viewport-fit=cover"
          />
          <link rel="icon" href="/favicon.ico" sizes="any" />
        </head>
        <body className="SFPro" suppressHydrationWarning>
          <ReactQueryWrapper>
            <ThemeProvider>
              <NextThemeProvider
                attribute="class"
                defaultTheme="system"
                enableSystem
              >
                <Content>
                  {children}
                  {contextMenus}
                </Content>
                <Toaster
                  position="bottom-center"
                  toastOptions={{
                    style: {
                      padding: "12px 16px",
                      borderRadius: "15px",
                      background: "rgba(28, 28, 30, 0.85)",
                      color: "#fff",
                      fontSize: "15px",
                      fontWeight: "500",
                      maxWidth: "90%",
                      textAlign: "center",
                      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                      backdropFilter: "blur(10px)",
                      filter: "grayscale(1)",
                    },
                    success: {
                      iconTheme: {
                        primary: "#fff",
                        secondary: "rgba(28, 28, 30, 0.85)",
                      },
                      duration: 2000,
                    },
                    error: {
                      iconTheme: {
                        primary: "#fff",
                        secondary: "rgba(28, 28, 30, 0.85)",
                      },
                      duration: 3000,
                    },
                  }}
                  containerStyle={{
                    bottom: 50,
                  }}
                />
                <Audio />
              </NextThemeProvider>
            </ThemeProvider>
          </ReactQueryWrapper>
        </body>
      </html>
    </ClerkProvider>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\manifest.ts
import { MetadataRoute } from "next";

const iconTheme = {
  sunset: "sunset",
  flora: "flora",
  sea: "sea",
  fruit: "fruit",
  dawn: "dawn",
};

// Set the desired theme here
const selectedTheme = iconTheme.flora;

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: "Gaku",
    short_name: "Gaku",
    description: "A SoundCloud Client",
    start_url: "/",
    display: "standalone",
    background_color: "#ffffff",
    theme_color: "#000000",
    id: "20240807",
    lang: "en",
    orientation: "portrait",
    categories: ["music"],
    icons: [
      {
        src: `/assets/icons/${selectedTheme}/windows11/SmallTile.scale-100.png`,
        sizes: "71x71",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SmallTile.scale-125.png`,
        sizes: "89x89",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SmallTile.scale-150.png`,
        sizes: "107x107",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SmallTile.scale-200.png`,
        sizes: "142x142",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SmallTile.scale-400.png`,
        sizes: "284x284",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square150x150Logo.scale-100.png`,
        sizes: "150x150",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square150x150Logo.scale-125.png`,
        sizes: "188x188",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square150x150Logo.scale-150.png`,
        sizes: "225x225",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square150x150Logo.scale-200.png`,
        sizes: "300x300",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square150x150Logo.scale-400.png`,
        sizes: "600x600",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Wide310x150Logo.scale-100.png`,
        sizes: "310x150",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Wide310x150Logo.scale-125.png`,
        sizes: "388x188",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Wide310x150Logo.scale-150.png`,
        sizes: "465x225",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Wide310x150Logo.scale-200.png`,
        sizes: "620x300",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Wide310x150Logo.scale-400.png`,
        sizes: "1240x600",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/LargeTile.scale-100.png`,
        sizes: "310x310",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/LargeTile.scale-125.png`,
        sizes: "388x388",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/LargeTile.scale-150.png`,
        sizes: "465x465",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/LargeTile.scale-200.png`,
        sizes: "620x620",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/LargeTile.scale-400.png`,
        sizes: "1240x1240",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.scale-100.png`,
        sizes: "44x44",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.scale-125.png`,
        sizes: "55x55",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.scale-150.png`,
        sizes: "66x66",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.scale-200.png`,
        sizes: "88x88",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.scale-400.png`,
        sizes: "176x176",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/StoreLogo.scale-100.png`,
        sizes: "50x50",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/StoreLogo.scale-125.png`,
        sizes: "63x63",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/StoreLogo.scale-150.png`,
        sizes: "75x75",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/StoreLogo.scale-200.png`,
        sizes: "100x100",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/StoreLogo.scale-400.png`,
        sizes: "200x200",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SplashScreen.scale-100.png`,
        sizes: "620x300",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SplashScreen.scale-125.png`,
        sizes: "775x375",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SplashScreen.scale-150.png`,
        sizes: "930x450",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SplashScreen.scale-200.png`,
        sizes: "1240x600",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/SplashScreen.scale-400.png`,
        sizes: "2480x1200",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-16.png`,
        sizes: "16x16",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-20.png`,
        sizes: "20x20",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-24.png`,
        sizes: "24x24",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-30.png`,
        sizes: "30x30",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-32.png`,
        sizes: "32x32",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-36.png`,
        sizes: "36x36",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-40.png`,
        sizes: "40x40",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-44.png`,
        sizes: "44x44",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-48.png`,
        sizes: "48x48",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-60.png`,
        sizes: "60x60",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-64.png`,
        sizes: "64x64",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-72.png`,
        sizes: "72x72",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-80.png`,
        sizes: "80x80",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-96.png`,
        sizes: "96x96",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.targetsize-256.png`,
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-16.png`,
        sizes: "16x16",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-20.png`,
        sizes: "20x20",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-24.png`,
        sizes: "24x24",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-30.png`,
        sizes: "30x30",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-32.png`,
        sizes: "32x32",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-36.png`,
        sizes: "36x36",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-40.png`,
        sizes: "40x40",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-44.png`,
        sizes: "44x44",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-48.png`,
        sizes: "48x48",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-60.png`,
        sizes: "60x60",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-64.png`,
        sizes: "64x64",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-72.png`,
        sizes: "72x72",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-80.png`,
        sizes: "80x80",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-96.png`,
        sizes: "96x96",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-unplated_targetsize-256.png`,
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-16.png`,
        sizes: "16x16",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-20.png`,
        sizes: "20x20",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-24.png`,
        sizes: "24x24",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-30.png`,
        sizes: "30x30",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-32.png`,
        sizes: "32x32",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-36.png`,
        sizes: "36x36",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-40.png`,
        sizes: "40x40",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-44.png`,
        sizes: "44x44",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-48.png`,
        sizes: "48x48",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-60.png`,
        sizes: "60x60",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-64.png`,
        sizes: "64x64",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-72.png`,
        sizes: "72x72",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-80.png`,
        sizes: "80x80",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-96.png`,
        sizes: "96x96",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/windows11/Square44x44Logo.altform-lightunplated_targetsize-256.png`,
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-512-512.png`,
        sizes: "512x512",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-192-192.png`,
        sizes: "192x192",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-144-144.png`,
        sizes: "144x144",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-96-96.png`,
        sizes: "96x96",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-72-72.png`,
        sizes: "72x72",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/android/android-launchericon-48-48.png`,
        sizes: "48x48",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/16.png`,
        sizes: "16x16",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/20.png`,
        sizes: "20x20",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/29.png`,
        sizes: "29x29",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/32.png`,
        sizes: "32x32",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/40.png`,
        sizes: "40x40",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/50.png`,
        sizes: "50x50",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/57.png`,
        sizes: "57x57",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/58.png`,
        sizes: "58x58",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/60.png`,
        sizes: "60x60",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/64.png`,
        sizes: "64x64",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/72.png`,
        sizes: "72x72",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/76.png`,
        sizes: "76x76",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/80.png`,
        sizes: "80x80",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/87.png`,
        sizes: "87x87",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/100.png`,
        sizes: "100x100",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/114.png`,
        sizes: "114x114",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/120.png`,
        sizes: "120x120",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/128.png`,
        sizes: "128x128",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/144.png`,
        sizes: "144x144",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/152.png`,
        sizes: "152x152",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/167.png`,
        sizes: "167x167",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/180.png`,
        sizes: "180x180",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/192.png`,
        sizes: "192x192",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/256.png`,
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/512.png`,
        sizes: "512x512",
        type: "image/png",
      },
      {
        src: `/assets/icons/${selectedTheme}/ios/1024.png`,
        sizes: "1024x1024",
        type: "image/png",
      },
    ],
  };
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\offline\page.tsx
"use client";
import { useEffect, useState } from "react";
import { Heading, SafeView, SubHeading } from "@/components/mobile/SafeView";
import { useRouter } from "next/navigation";
import { IoCloudOffline, IoRefresh } from "react-icons/io5";

export default function Offline() {
  const [isOnline, setIsOnline] = useState(true);
  const router = useRouter();

  useEffect(() => {
    setIsOnline(navigator.onLine);

    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  const handleRefresh = () => {
    if (isOnline) {
      router.refresh();
    }
  };

  return (
    <>
      <SafeView>
        <Heading>Gaku</Heading>
        <SubHeading className="mb-6">
          {isOnline ? "You're back online!" : "You're currently offline"}
        </SubHeading>
        <div className="flex flex-col items-center justify-center space-y-6">
          <IoCloudOffline className="text-3xl text-muted-foreground" />
          <p className="text-center text-muted-foreground">
            {isOnline
              ? "Your internet connection has been restored. You can now use all features of the app."
              : "It looks like you're offline. Some features may be unavailable until you reconnect."}
          </p>
          <button
            onClick={handleRefresh}
            className="flex items-center gap-2 px-4 py-1 rounded-xl bg-primary text-primary-foreground hover:bg-primary/90"
            disabled={!isOnline}
          >
            <IoRefresh className="text-lg" />
            Refresh
          </button>
        </div>
      </SafeView>
    </>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\app\page.tsx
import { Sections } from "@/rework/components/main/home/Sections";
import { Welcome } from "@/rework/components/main/home/Welcome";

export default function Home() {
  return (
    <>
      <Welcome />
      <Sections />
    </>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\AnimatedCover.tsx
import React from "react";
import ReactPlayer from "react-player";

interface AnimatedCoverProps {
  url: string;
  style?: React.CSSProperties;
}

export const AnimatedCover: React.FC<AnimatedCoverProps> = ({ url, style }) => {
  return (
    <>
      <ReactPlayer
        url={url}
        playing
        loop
        muted
        playsinline
        width="100%"
        height="100%"
        controls={false}
        style={{ borderRadius: "16px", aspectRatio: "1/1", ...style }}
      />
    </>
  );
};

export const AnimatedCoverFull: React.FC<AnimatedCoverProps> = ({ url }) => {
  return (
    <>
      <div>
        <div className="w-screen h-[19.5rem] bg-red-500/0" />
        <div className="-z-10 overflow-x-clip grid items-end justify-center w-screen h-[20rem] absolute top-0">
          <div className="scale-[1.2] absolute top-0 standalone:top-[-1rem] left-0 w-screen h-screen animated-video-container flex">
            <ReactPlayer
              url={url}
              playing={true}
              loop={true}
              muted={true}
              height={"25rem"}
              controls={false}
              playsinline={true}
              style={{ aspectRatio: "1/1" }}
            />
          </div>

          <div className="w-full h-56 album-animated-blur absolute translate-y-[14rem]" />
          <div className="w-full h-56 album-animated-fade bg-gradient-to-t from-[--apple-animated-bg-color] from-50% absolute translate-y-[14rem]" />
        </div>
      </div>
    </>
  );
};

export default AnimatedCover;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\AnimatedLyrics.tsx
// src\components\AnimatedLyrics.tsx
import { useEffect, useRef, useState } from "react";
import clsx from "clsx";
import { fetchLyrics } from "@/lib/utils";
import "../styles/lyrics.css";
import { motion, AnimatePresence } from "framer-motion";

export const LyricDots = () => (
  <motion.div
    layout
    className="size-fit pt-4"
    initial={{ scale: 0, opacity: 0, marginBottom: "0px" }}
    animate={{ scale: 1, opacity: 1, marginBottom: "0px" }}
    exit={{ scale: 0.8, opacity: 0, marginBottom: "-22px" }}
    transition={{ duration: 0.3 }}
  >
    <motion.div className="lyric-dots">
      <div className="dot dot-1">
        <div className="svg-dot">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            stroke="currentColor"
            strokeWidth="0"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="12" cy="12" r="10"></circle>
          </svg>
        </div>
      </div>
      <div className="dot dot-2">
        <div className="svg-dot">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            stroke="currentColor"
            strokeWidth="0"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="12" cy="12" r="10"></circle>
          </svg>
        </div>
      </div>
      <div className="dot dot-3">
        <div className="svg-dot">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            stroke="currentColor"
            strokeWidth="0"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="12" cy="12" r="10"></circle>
          </svg>
        </div>
      </div>
    </motion.div>
  </motion.div>
);

interface LyricLine {
  startTimeMs: string;
  words: string;
}

export const AnimatedLyrics = ({
  localPlayed,
  delay = 0,
  onSeek,
  songTitle,
  artistName,
}: {
  localPlayed: number;
  delay?: number;
  onSeek: (time: number) => void;
  songTitle: string;
  artistName: string;
}) => {
  const [currentLine, setCurrentLine] = useState<LyricLine | null>(null);
  const currentLineRef = useRef<HTMLParagraphElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null); // reference to the lyrics container
  const [lyrics, setLyrics] = useState<{ lines: LyricLine[] }>({ lines: [] });
  const [showDots, setShowDots] = useState(false);

  const getLyrics = async (songTitle: string, artistName: string) => {
    const data = await fetchLyrics(songTitle, artistName);
    if (!data) {
      return;
    }
    setLyrics(data.lyrics);
  };

  useEffect(() => {
    const fetchSongLyrics = async () => {
      await getLyrics(songTitle, artistName);
    };
    fetchSongLyrics();
  }, [songTitle, artistName]);

  useEffect(() => {
    if (lyrics && lyrics.lines.length > 0) {
      const adjustedTimestamp = (localPlayed + delay) * 1000;

      const currentLineIndex = lyrics.lines.findIndex((line, index) => {
        const nextLineStartTime = lyrics.lines[index + 1]
          ? Number(lyrics.lines[index + 1].startTimeMs)
          : Infinity;
        return (
          Number(line.startTimeMs) <= adjustedTimestamp &&
          adjustedTimestamp < nextLineStartTime
        );
      });

      if (currentLineIndex !== -1) {
        setCurrentLine(lyrics.lines[currentLineIndex]);
        setShowDots(false);
      } else {
        setCurrentLine(null);
        const firstLineStartTime = Number(lyrics.lines[0].startTimeMs);
        const isBeforeFirstLyric = adjustedTimestamp < firstLineStartTime;
        const isInGap = lyrics.lines.every((line, index) => {
          const nextLineStartTime = lyrics.lines[index + 1]
            ? Number(lyrics.lines[index + 1].startTimeMs)
            : Infinity;
          return (
            adjustedTimestamp < Number(line.startTimeMs) ||
            adjustedTimestamp >= nextLineStartTime
          );
        });
        setShowDots(isBeforeFirstLyric || isInGap);
      }
    }
  }, [localPlayed, delay, lyrics]);

  useEffect(() => {
    if (currentLineRef.current && containerRef.current) {
      const lyricsContainer = containerRef.current;
      const lineTop = currentLineRef.current.offsetTop;
      const containerHeight = lyricsContainer.clientHeight;
      const lineHeight = currentLineRef.current.clientHeight;
      const scrollPosition = lineTop - containerHeight / 2 + lineHeight / 2;
      lyricsContainer.scrollTo({
        top: scrollPosition,
        behavior: "smooth",
      });
    }
  }, [currentLine]);

  const handleClick = (startTimeMs: string) => {
    const timeInSeconds = parseInt(startTimeMs, 10) / 1000;
    onSeek(timeInSeconds);
  };

  if (!lyrics) {
    return (
      <div>
        <LyricDots />
      </div>
    );
  }

  return (
    <div
      className="lyrics-container"
      style={{ overflowY: "auto", height: "55vh" }}
      ref={containerRef} // attach the containerRef to the lyrics-container
    >
      <div
        className="lyrics-view"
        style={{
          // paddingTop: "40px",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          minHeight: "100%",
        }}
      >
        <AnimatePresence>{showDots && <LyricDots />}</AnimatePresence>
        {lyrics.lines.map((line, index) => {
          const isCurrentLine = currentLine?.startTimeMs === line.startTimeMs;
          const isPastLine =
            Number(line.startTimeMs) < (localPlayed + delay) * 1000;
          const isFirstLine = index === 0;

          return (
            <p
              key={line.startTimeMs + index}
              ref={isCurrentLine ? currentLineRef : null}
              onClick={() => handleClick(line.startTimeMs)}
              className={clsx(
                "lyric-line has-syllables",
                isCurrentLine ? "active" : isPastLine ? "finished" : "",
                isFirstLine ? "!pt-4" : ""
              )}
              style={{ cursor: "pointer" }}
            >
              {line.words}
            </p>
          );
        })}
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\AnimatedRichSyncLyrics.tsx
import { useEffect, useRef, useState } from "react";
import clsx from "clsx";
import "../styles/lyrics.css";
import { LyricDots } from "./AnimatedLyrics";
import { fetchLyrics, fetchRichSyncLyrics } from "@/lib/utils";

interface RichSyncLine {
  ts: number; // start time in seconds
  te: number; // end time in seconds
  l: { c: string; o: number }[]; // lyric characters and offsets
  x: string;
}

interface LyricLine {
  startTimeMs: string;
  words: string;
}

const easeOutCubic = (t: number): number => {
  return 1 - Math.pow(1 - t, 3);
};

const calculateCharacterProgress = (
  line: RichSyncLine,
  localPlayed: number,
  delay: number
): number[] => {
  if (!line) return [];

  const adjustedTimestamp = (localPlayed + delay) * 1000;
  const lineStartTime = line.ts * 1000;
  const totalLineDuration = (line.te - line.ts) * 1000;
  const elapsedTime = adjustedTimestamp - lineStartTime;
  const rawProgress = Math.min(Math.max(elapsedTime / totalLineDuration, 0), 1);
  const easedProgress = easeOutCubic(rawProgress);

  return line.l.map((_, index) => {
    const charStartTime =
      lineStartTime + (index / line.l.length) * totalLineDuration;
    const charElapsedTime = adjustedTimestamp - charStartTime;
    const charProgress = Math.min(
      Math.max(charElapsedTime / totalLineDuration, 0),
      1
    );
    return easeOutCubic(charProgress);
  });
};

export const AnimatedRichSyncLyrics = ({
  localPlayed,
  delay = 0,
  duration,
  onSeek,
  hasRichSync = false, // Prop to conditionally use rich sync lyrics or regular lyrics
  songTitle,
  artistName,
}: {
  localPlayed: number;
  delay?: number;
  duration: number;
  onSeek: (time: number) => void;
  hasRichSync?: boolean;
  songTitle: string;
  artistName: string;
}) => {
  const [currentLine, setCurrentLine] = useState<
    RichSyncLine | LyricLine | null
  >(null);
  const currentLineRef = useRef<HTMLParagraphElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [lyrics, setLyrics] = useState<{ lines: RichSyncLine[] | LyricLine[] }>(
    { lines: [] }
  );
  const [showDots, setShowDots] = useState(false);
  const [lineProgress, setLineProgress] = useState<number[]>([]); // State to store line progress for each character
  const animationRef = useRef<number | null>(null); // Store requestAnimationFrame ID

  // Fetch Rich Sync Lyrics
  const getRichSyncLyrics = async () => {
    try {
      const data = await fetchRichSyncLyrics(songTitle, artistName);
      if (!data || !data.lyrics || !data.lyrics.message.body.richsync) return;
      const richsyncBody = data.lyrics.message.body.richsync.richsync_body;
      const richsyncLines = JSON.parse(richsyncBody);
      setLyrics({ lines: richsyncLines });
    } catch (error) {
      console.error("RichSync | Error processing richsync data:", error);
      setLyrics({ lines: [] });
    }
  };

  // Fetch Regular Lyrics
  const getLyrics = async (songTitle: string, artistName: string) => {
    const data = await fetchLyrics(songTitle, artistName);
    if (!data) return;
    setLyrics(data.lyrics);
  };

  useEffect(() => {
    if (hasRichSync) {
      getRichSyncLyrics(); // Load rich sync lyrics if the prop is true
    } else {
      getLyrics(songTitle, artistName); // Load regular lyrics if the prop is false
    }
  }, [songTitle, artistName]);

  useEffect(() => {
    if (lyrics.lines.length > 0) {
      const adjustedTimestamp = (localPlayed + delay) * 1000;

      const currentLineIndex = lyrics.lines.findIndex((line, index) => {
        const nextLineStartTime = lyrics.lines[index + 1]
          ? hasRichSync
            ? (lyrics.lines[index + 1] as RichSyncLine).ts * 1000
            : Number((lyrics.lines[index + 1] as LyricLine).startTimeMs)
          : Infinity;
        return hasRichSync
          ? (line as RichSyncLine).ts * 1000 <= adjustedTimestamp &&
              adjustedTimestamp < nextLineStartTime
          : Number((line as LyricLine).startTimeMs) <= adjustedTimestamp &&
              adjustedTimestamp < nextLineStartTime;
      });

      if (currentLineIndex !== -1) {
        setCurrentLine(lyrics.lines[currentLineIndex]);
        setShowDots(false);
      } else {
        setCurrentLine(null);
        const firstLineStartTime = hasRichSync
          ? (lyrics.lines[0] as RichSyncLine).ts * 1000
          : Number((lyrics.lines[0] as LyricLine).startTimeMs);
        const isBeforeFirstLyric = adjustedTimestamp < firstLineStartTime;
        const isInGap = lyrics.lines.every((line, index) => {
          const nextLineStartTime = lyrics.lines[index + 1]
            ? hasRichSync
              ? (lyrics.lines[index + 1] as RichSyncLine).ts * 1000
              : Number((lyrics.lines[index + 1] as LyricLine).startTimeMs)
            : Infinity;
          return hasRichSync
            ? adjustedTimestamp < (line as RichSyncLine).ts * 1000 ||
                adjustedTimestamp >= nextLineStartTime
            : adjustedTimestamp < Number((line as LyricLine).startTimeMs) ||
                adjustedTimestamp >= nextLineStartTime;
        });
        setShowDots(isBeforeFirstLyric || isInGap);
      }
    }
  }, [localPlayed, delay, lyrics, hasRichSync]);

  useEffect(() => {
    if (currentLineRef.current && containerRef.current) {
      const lyricsContainer = containerRef.current;
      const lineTop = currentLineRef.current.offsetTop;
      const containerHeight = lyricsContainer.clientHeight;
      const lineHeight = currentLineRef.current.clientHeight;
      const scrollPosition = lineTop - containerHeight / 2 + lineHeight / 2;
      lyricsContainer.scrollTo({
        top: scrollPosition,
        behavior: "smooth",
      });
    }
  }, [currentLine]);

  const handleClick = (startTime: number | string) => {
    const timeInSeconds = hasRichSync
      ? (startTime as number)
      : parseInt(startTime as string, 10) / 1000;
    onSeek(timeInSeconds);
  };

  useEffect(() => {
    const updateLineProgress = () => {
      if (currentLine) {
        const progress = calculateCharacterProgress(
          currentLine as RichSyncLine,
          localPlayed,
          delay
        );
        setLineProgress(progress);
      }
      animationRef.current = requestAnimationFrame(updateLineProgress);
    };

    animationRef.current = requestAnimationFrame(updateLineProgress);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [localPlayed, currentLine, delay]);

  if (lyrics.lines.length === 0) {
    return (
      <div>
        <LyricDots />
      </div>
    );
  }

  return (
    <div
      className="lyrics-container"
      style={{ overflowY: "auto", height: "55vh" }}
      ref={containerRef}
    >
      <div
        className="lyrics-view"
        style={{
          height: "100%",
          display: "flex",
          flexDirection: "column",
          minHeight: "100%",
        }}
      >
        {lyrics.lines.map((line, index) => {
          const isCurrentLine = hasRichSync
            ? currentLine === line
            : Number((currentLine as LyricLine)?.startTimeMs) ===
              Number((line as LyricLine).startTimeMs);

          const isPastLine = hasRichSync
            ? (line as RichSyncLine).ts < localPlayed + delay
            : Number((line as LyricLine).startTimeMs);
          (localPlayed + delay) * 1000;
          const isFirstLine = index === 0;

          const lineProgress =
            isCurrentLine && hasRichSync
              ? calculateCharacterProgress(
                  line as RichSyncLine,
                  localPlayed,
                  delay
                )
              : isPastLine
              ? Array((line as RichSyncLine).l.length).fill(1)
              : Array((line as RichSyncLine).l.length).fill(0);

          return (
            <p
              key={index}
              ref={isCurrentLine ? currentLineRef : null}
              onClick={() =>
                handleClick(
                  hasRichSync
                    ? (line as RichSyncLine).ts
                    : (line as LyricLine).startTimeMs
                )
              }
              className={clsx(
                "lyric-line lyric-word",
                isCurrentLine
                  ? "current-word"
                  : isPastLine
                  ? "finished-word"
                  : "",
                isFirstLine ? "!pt-4" : ""
              )}
              style={
                {
                  cursor: "pointer",
                  "--lyric-line-progress": lineProgress,
                } as React.CSSProperties
              }
            >
              {hasRichSync
                ? (line as RichSyncLine).l.map((part, partIndex) => (
                    <span
                      key={partIndex}
                      className={clsx(
                        "lyric-char",
                        part.c === " " && partIndex === 0
                          ? "no-leading-space"
                          : ""
                      )}
                      style={
                        {
                          "--char-progress": lineProgress[partIndex],
                        } as React.CSSProperties
                      }
                    >
                      {part.c === " " && partIndex === 0
                        ? ""
                        : part.c === " "
                        ? "\u00A0"
                        : part.c}
                    </span>
                  ))
                : (line as LyricLine).words}
            </p>
          );
        })}
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\CanvasBackground.tsx
import React, { useEffect, useRef, useState } from "react";

interface CanvasBackgroundProps {
  src: string;
  blur?: number;
  warpIntensity?: number;
  imgScale?: number;
  maxFramerate?: number;
  bpm?: number;
  brightness?: number;
  transitionDuration?: number; // Add transitionDuration prop
  className?: string;
  children: React.ReactNode;
}

export const CanvasBackground: React.FC<CanvasBackgroundProps> = ({
  src,
  blur = 10,
  warpIntensity = 20,
  imgScale = 2,
  maxFramerate = 40,
  bpm = 60,
  brightness = 1,
  transitionDuration = 200, // Default transition duration in milliseconds
  className,
  children,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [rotation, setRotation] = useState(0);
  const [rotationDirection, setRotationDirection] = useState(1);
  const [pulseValue, setPulseValue] = useState(0);
  const [speed, setSpeed] = useState(bpm / 120);
  const [currentBrightness, setCurrentBrightness] = useState(brightness);

  useEffect(() => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = src;
    img.onload = () => setImage(img);
  }, [src]);

  useEffect(() => {
    setSpeed(bpm / 120);
  }, [bpm]);

  useEffect(() => {
    if (!image || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = 250;
    canvas.height = 250;

    let animationFrameId: number;

    const draw = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

      // Apply warp effect
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const index = (y * canvas.width + x) * 4;
          const warpX = x + Math.sin(y / warpIntensity) * warpIntensity;
          const warpY = y + Math.cos(x / warpIntensity) * warpIntensity;
          const warpIndex =
            (Math.floor(warpY) * canvas.width + Math.floor(warpX)) * 4;

          if (warpIndex >= 0 && warpIndex < data.length) {
            data[index] = data[warpIndex];
            data[index + 1] = data[warpIndex + 1];
            data[index + 2] = data[warpIndex + 2];
          }
        }
      }
      ctx.putImageData(imageData, 0, 0);

      // Smoothly transition brightness
      setCurrentBrightness((prev) => {
        const step = (brightness - prev) * (1 / (transitionDuration / 16.67));
        return prev + step;
      });

      // Apply blur and brightness effect
      ctx.filter = `blur(${blur}px) brightness(${currentBrightness})`;
      ctx.drawImage(canvas, 0, 0);

      // Update rotation
      setRotation((prev) => prev + 0.01 * rotationDirection * speed);

      animationFrameId = requestAnimationFrame(draw);
    };

    draw();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [
    image,
    blur,
    warpIntensity,
    rotationDirection,
    speed,
    brightness,
    currentBrightness,
    transitionDuration,
  ]);

  return (
    <div
      className={`relative ${className}`}
      style={{ width: "100%", height: "100%" }}
    >
      <canvas
        ref={canvasRef}
        className="absolute inset-0 blur-[10px]"
        style={{
          transform: "translate(-50%, -50%) scaleX(8) scaleY(4.5)",
          top: "50%",
          left: "50%",
        }}
      />
      <div className="relative z-10 h-full">{children}</div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\ColorGen.tsx
import Color, { Palette } from "color-thief-react";
import React from "react";

export const ColorGen = ({ src }: { src: string }) => {
  return (
    <div>
      <>
        <Palette
          src={src}
          crossOrigin="anonymous"
          format="hslString"
          quality={1}
          colorCount={2}
        >
          {({ data, loading }) => {
            if (loading) return null;
            if (data) {
              document.documentElement.style.setProperty(
                "--palette-1",
                `${data[0]}`
              );
              document.documentElement.style.setProperty(
                "--palette-2",
                `${data[1]}`
              );
              let hslParts1 = data[0].match(/hsl\((\d+), (\d+)%, (\d+)%\)/);
              if (hslParts1) {
                let hue = hslParts1[1];
                let saturation = hslParts1[2];
                let lightness = Math.min(parseInt(hslParts1[3]) + 20, 85);
                let newHSL = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                document.documentElement.style.setProperty(
                  "--palette-1",
                  newHSL
                );
              }
            }
          }}
        </Palette>
        <Color src={src} crossOrigin="anonymous" format="hslString" quality={1}>
          {({ data, loading }) => {
            if (loading) return null;
            if (data) {
              document.documentElement.style.setProperty("--theme", `${data}`);
              let hslParts = data.match(/hsl\((\d+), (\d+)%, (\d+)%\)/);
              if (hslParts) {
                let hue = hslParts[1];
                let saturation = Math.min(parseInt(hslParts[2]) + 25, 100);
                let lightness = Math.min(parseInt(hslParts[3]) + 20, 85);
                let newHSL = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                document.documentElement.style.setProperty("--ambient", newHSL);
              }
            }
          }}
        </Color>
      </>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\Lossless.tsx
export const Lossless = ({ className }: { className: string }) => {
  return (
    <div
      title="p.s. it's not actually lossless :P"
      className="flex items-center justify-center gap-1"
    >
      <svg
        className={`${className} relative top-[1px]`}
        xmlns="http://www.w3.org/2000/svg"
        width="16"
        height="16"
        viewBox="0 0 15 9"
      >
        <path d="M8.184,0.35C9.944,0.35 10.703,3.296 11.338,5.238C11.673,3.842 11.497,3.542 11.857,3.542C11.99,3.542 12.126,3.633 12.126,3.798C12.126,3.809 12.123,3.839 12.117,3.883L12.091,4.058C12.02,4.522 11.845,5.494 11.654,6.144C13.198,10.191 14.345,4.861 14.474,3.772C14.493,3.615 14.612,3.542 14.731,3.542C14.891,3.542 15.022,3.662 14.997,3.843C14.72,5.605 14.295,8.35 12.547,8.35C11.582,8.35 11.04,7.595 10.611,6.73C9.54,4.626 9.047,1.093 7.997,1.093C7.66,1.093 7.411,1.444 7.394,1.444C7.362,1.444 7.337,1.301 7.023,0.909C7.322,0.567 7.734,0.35 8.184,0.35ZM2.458,0.354C5.211,0.354 5.456,7.618 7.014,7.618C7.197,7.618 7.394,7.507 7.61,7.256C7.729,7.458 7.851,7.638 7.978,7.796C7.667,8.151 7.28,8.35 6.795,8.35C5.054,8.349 4.306,5.434 3.663,3.466C3.511,4.097 3.432,4.669 3.402,4.925C3.382,5.088 3.263,5.163 3.143,5.163C3.009,5.163 2.874,5.071 2.874,4.908L2.874,4.908L2.877,4.87C2.966,4.223 3.146,3.243 3.347,2.56C3.079,1.858 2.745,1.091 2.252,1.091C1.257,1.091 0.687,3.591 0.527,4.925C0.508,5.088 0.388,5.163 0.268,5.163C0.135,5.163 0,5.071 0,4.908C0,4.896 0.001,4.883 0.002,4.87C0.283,2.836 0.808,0.354 2.458,0.354ZM5.315,0.35C5.809,0.35 6.339,0.608 6.797,1.211C6.822,1.241 7.078,1.639 7.159,1.777C8.277,3.802 8.818,7.627 9.881,7.627C10.065,7.627 10.264,7.513 10.484,7.256C10.604,7.458 10.726,7.638 10.852,7.796C10.542,8.15 10.155,8.35 9.67,8.35C6.933,8.349 6.636,1.09 5.128,1.09C4.788,1.09 4.536,1.444 4.519,1.444C4.487,1.444 4.462,1.301 4.148,0.909C4.455,0.558 4.87,0.35 5.315,0.35Z" />
      </svg>
      <span className="">Lossless</span>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\LyricIcon.tsx
export const LyricIcon = ({ className }: { className: string }) => {
  return (
    <div className="flex items-center justify-center gap-1">
      <svg
        width="24"
        height="24"
        className={`${className} relative top-[1px]`}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 192 180"
        version="1.1"
        style={{
          fillRule: "evenodd",
          clipRule: "evenodd",
          strokeLinejoin: "round",
          strokeMiterlimit: 2,
        }}
      >
        <g transform="matrix(1,0,0,1,-821.683,-451.586)">
          <path d="M1013.35,487.987C1013.35,467.897 997.039,451.586 976.948,451.586L858.084,451.586C837.994,451.586 821.683,467.897 821.683,487.987L821.683,560.79C821.683,580.881 837.994,597.192 858.084,597.192L866.171,597.192C866.171,597.192 866.524,611.488 866.82,623.479C866.894,626.46 868.668,629.135 871.386,630.36C874.103,631.586 877.283,631.147 879.566,629.23C894.516,616.675 917.716,597.192 917.716,597.192L976.948,597.192C997.039,597.192 1013.35,580.881 1013.35,560.79L1013.35,487.987ZM1000.35,495.01C1000.35,477.53 986.251,463.338 968.886,463.338L866.146,463.338C848.781,463.338 834.683,477.53 834.683,495.01L834.683,558.353C834.683,575.833 848.781,585.998 866.146,585.998L878.136,585.998L878.757,615.599L908.688,585.998L968.886,585.998C986.251,585.998 1000.35,575.833 1000.35,558.353L1000.35,495.01Z" />
          <g>
            <g transform="matrix(0.977158,0.212516,-0.212516,0.977158,128.2,-179.565)">
              <path
                d="M905.108,528.038C903.606,529.813 901.928,531.15 900.073,532.049C898.218,532.948 896.164,533.397 893.911,533.397C891.772,533.397 889.775,532.982 887.921,532.151C886.066,531.321 884.461,530.16 883.107,528.669C881.753,527.179 880.712,525.438 879.984,523.447C879.256,521.455 878.892,519.367 878.892,517.183C878.892,514.839 879.301,512.614 880.12,510.509C880.94,508.404 882.112,506.578 883.636,505.03C885.161,503.483 886.976,502.277 889.081,501.412C891.186,500.547 893.513,500.115 896.062,500.115C898.998,500.115 901.615,500.65 903.913,501.719C906.212,502.789 908.146,504.342 909.716,506.379C911.286,508.415 912.492,510.981 913.335,514.076C914.177,517.171 914.598,520.676 914.598,524.59C914.598,528.959 914.154,532.811 913.266,536.145C912.379,539.479 911.087,542.278 909.392,544.542C907.696,546.807 905.665,548.491 903.299,549.594C900.932,550.698 898.247,551.25 895.243,551.25C892.284,551.25 894.059,544.73 895.516,544.73C896.813,544.73 898.042,544.4 899.202,543.74C900.363,543.08 901.353,542.147 902.172,540.941C903.811,538.506 904.789,534.205 905.108,528.038Z"
                style={{ fillRule: "nonzero" }}
              />
            </g>
            <g transform="matrix(0.977158,0.212516,-0.212516,0.977158,175.2,-179.565)">
              <path
                d="M905.108,528.038C903.606,529.813 901.928,531.15 900.073,532.049C898.218,532.948 896.164,533.397 893.911,533.397C891.772,533.397 889.775,532.982 887.921,532.151C886.066,531.321 884.461,530.16 883.107,528.669C881.753,527.179 880.712,525.438 879.984,523.447C879.256,521.455 878.892,519.367 878.892,517.183C878.892,514.839 879.301,512.614 880.12,510.509C880.94,508.404 882.112,506.578 883.636,505.03C885.161,503.483 886.976,502.277 889.081,501.412C891.186,500.547 893.513,500.115 896.062,500.115C898.998,500.115 901.615,500.65 903.913,501.719C906.212,502.789 908.146,504.342 909.716,506.379C911.286,508.415 912.492,510.981 913.335,514.076C914.177,517.171 914.598,520.676 914.598,524.59C914.598,528.959 914.154,532.811 913.266,536.145C912.379,539.479 911.087,542.278 909.392,544.542C907.696,546.807 905.665,548.491 903.299,549.594C900.932,550.698 898.247,551.25 895.243,551.25C892.284,551.25 894.059,544.73 895.516,544.73C896.813,544.73 898.042,544.4 899.202,543.74C900.363,543.08 901.353,542.147 902.172,540.941C903.811,538.506 904.789,534.205 905.108,528.038Z"
                style={{ fillRule: "nonzero" }}
              />
            </g>
          </g>
        </g>
      </svg>
      <span className="sr-only">LyricIcon</span>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\Options.tsx
export const Options = ({ className }: { className: string }) => {
  return (
    <div className="flex items-center justify-center gap-1">
      <svg
        width="24"
        height="24"
        viewBox="0 0 28 28"
        xmlns="http://www.w3.org/2000/svg"
        className={className}
      >
        <circle
          fill="var(--iconCircleFill, transparent)"
          cx="14"
          cy="14"
          r="14"
        ></circle>
        <path
          fill="var(--iconEllipsisFill, white)"
          d="M10.105 14c0-.87-.687-1.55-1.564-1.55-.862 0-1.557.695-1.557 1.55 0 .848.695 1.55 1.557 1.55.855 0 1.564-.702 1.564-1.55zm5.437 0c0-.87-.68-1.55-1.542-1.55A1.55 1.55 0 0012.45 14c0 .848.695 1.55 1.55 1.55.848 0 1.542-.702 1.542-1.55zm5.474 0c0-.87-.687-1.55-1.557-1.55-.87 0-1.564.695-1.564 1.55 0 .848.694 1.55 1.564 1.55.848 0 1.557-.702 1.557-1.55z"
        ></path>
      </svg>
      <span className="sr-only">Options</span>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\PlayingIcon.tsx
import React from "react";
import "./PlayingIcon.css";

export interface IconBaseProps extends React.SVGAttributes<SVGElement> {
  children?: React.ReactNode;
  size?: string | number;
  color?: string;
  title?: string;
}

export const PlayingIcon: React.FC<IconBaseProps> = ({
  size = "24",
  color = "currentColor",
  title = "Icon depicting sound waves with three vertical bars changing in height in a pulsating manner",
  ...props
}) => {
  return (
    <span className="size-fit -ml-1">
      <svg
        fill={color}
        viewBox="0 0 24 30"
        width={size}
        height={size}
        {...props}
      >
        <title>{title}</title>
        <rect
          className="playing-icon-1"
          height="30"
          rx="2"
          ry="2"
          width="4"
        ></rect>
        <rect
          className="playing-icon-2"
          height="22"
          rx="2"
          ry="2"
          width="4"
          x="10"
          y="4"
        ></rect>
        <rect
          className="playing-icon-3"
          height="30"
          rx="2"
          ry="2"
          width="4"
          x="20"
        ></rect>
      </svg>
    </span>
  );
};

export const PausedIcon: React.FC<IconBaseProps> = ({
  size = "24",
  color = "currentColor",
  title = "Icon depicting sound waves with three vertical bars in a static, paused state",
  ...props
}) => {
  return (
    <span className="size-fit -ml-1">
      <svg
        fill={color}
        viewBox="0 0 30 10"
        width={size}
        height={size}
        {...props}
      >
        <title>{title}</title>
        <circle cx="5" cy="5" r="3" />
        <circle cx="15" cy="5" r="3" />
        <circle cx="25" cy="5" r="3" />
      </svg>
    </span>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\PlayPause.tsx
import React from "react";
import Lottie from "lottie-react";
import playing from "./lottie/playing.json";
import paused from "./lottie/paused.json";

export const Playing = () => {
  return (
    <div>
      {/* <Lottie animationData={playing} loop={true} /> */}
      IlI|
    </div>
  );
};

export const Paused = () => {
  return (
    <div>
      {/* <Lottie animationData={paused} loop={true} /> */}
      ...
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\Icons\XMark.tsx
export const XMark = ({
  className,
  height,
  width,
}: {
  className: string;
  height: string;
  width: string;
}) => {
  return (
    <div className={`${className} flex items-center justify-center gap-1`}>
      <svg
        width={width}
        height={height}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 82 82"
      >
        <path d="M2.707 79.097c1.427 1.407 3.187 2.106 5.279 2.097 2.092-.01 3.806-.68 5.14-2.012l27.866-27.899 27.842 27.87c1.37 1.39 3.087 2.079 5.15 2.07 2.064-.01 3.811-.728 5.241-2.155 1.408-1.43 2.116-3.172 2.126-5.226.01-2.055-.67-3.778-2.04-5.17L51.469 40.807 79.31 12.999c1.37-1.412 2.054-3.15 2.054-5.213 0-2.064-.713-3.8-2.14-5.207-1.449-1.41-3.2-2.126-5.255-2.145-2.054-.019-3.766.667-5.136 2.06L40.992 30.33 13.127 2.465C11.792 1.13 10.074.458 7.972.448 5.87.438 4.115 1.14 2.707 2.551 1.277 3.977.572 5.73.591 7.815c.019 2.083.696 3.8 2.03 5.155l27.895 27.837L2.622 68.7C1.287 70.036.61 71.749.59 73.84c-.02 2.093.686 3.845 2.116 5.256z" />
      </svg>
      <span className="sr-only">Close Button</span>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\lyrics\LyricDots.tsx
import React, { useEffect, useState } from "react";
import "@/styles/LyricDots.css";

interface LyricDotsProps {
  start: number;
  end: number;
  currentTime: number;
}

const LyricDots: React.FC<LyricDotsProps> = ({ start, end, currentTime }) => {
  const [active, setActive] = useState(true);
  const [dotOpacity, setDotOpacity] = useState([10, 10, 10]);

  const progress = Math.min(
    Math.max(((currentTime - start) / (end - start)) * 100, 0),
    100
  );

  useEffect(() => {
    if (progress >= 98) {
      setActive(false);
    } else {
      setActive(true);
      if (progress < 33) {
        const value = Math.floor(((progress + 10) / 33) * 100);
        setDotOpacity([value, 10, 10]);
      } else if (progress < 66) {
        const value = Math.floor(((progress + 10 - 33) / 33) * 100);
        setDotOpacity([100, value, 10]);
      } else {
        const value = Math.floor(((progress + 10 - 66) / 33) * 100);
        setDotOpacity([100, 100, value]);
      }
    }
  }, [progress]);

  const getDotStyle = (index: number) => ({
    opacity: dotOpacity[index] / 100,
  });

  return (
    <div className={`lyric-dots ${!active ? "clear" : ""}`}>
      <div className="dot dot-1" style={getDotStyle(0)}></div>
      <div className="dot dot-2" style={getDotStyle(1)}></div>
      <div className="dot dot-3" style={getDotStyle(2)}></div>
    </div>
  );
};

export default LyricDots;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\lyrics\LyricLine.tsx
import React from "react";
import LyricWord from "./LyricWord";

interface RichSyncLyricLine {
  ts: number;
  te: number;
  l: { c: string; o: number }[];
  x?: string;
  translation?: string;
}

interface LineSyncLyricLine {
  startTimeMs: string;
  words: string;
  endTimeMs: string;
}

interface LyricLineProps {
  index: number;
  lyric: RichSyncLyricLine | LineSyncLyricLine;
  isActive: boolean;
  isUnsynced: boolean;
  seekTo: (time: number) => void;
  smoothTime: number;
  delayfix: number;
  getWordDuration?: (lineIndex: number, wordIndex: number) => number;
  syncType: "WORD_SYNCED" | "LINE_SYNCED";
}

const LyricLine: React.FC<LyricLineProps> = ({
  index,
  lyric,
  isActive,
  isUnsynced,
  seekTo,
  smoothTime,
  delayfix,
  getWordDuration,
  syncType,
}) => {
  const handleClick = () => {
    const time =
      syncType === "WORD_SYNCED"
        ? (lyric as RichSyncLyricLine).ts
        : parseInt((lyric as LineSyncLyricLine).startTimeMs) / 1000;
    seekTo(time);
  };

  if (syncType === "WORD_SYNCED") {
    // Rich Sync Lyrics
    const richLyric = lyric as RichSyncLyricLine;
    return (
      <h3
        className={`lyric-line ${isActive ? "active" : ""} ${
          isUnsynced ? "unsynced" : ""
        }`}
        onClick={handleClick}
        data-line-index={index}
      >
        <div className="richl">
          {richLyric.l.map((verse, verseIndex) => (
            <LyricWord
              key={verseIndex}
              lineIndex={index}
              verse={verse}
              verseIndex={verseIndex}
              lyric={richLyric}
              smoothTime={smoothTime}
              delayfix={delayfix}
              getWordDuration={getWordDuration!}
            />
          ))}
        </div>
        {richLyric.translation && (
          <div className="lyrics-translation">{richLyric.translation}</div>
        )}
      </h3>
    );
  } else {
    // Line Sync Lyrics
    const lineLyric = lyric as LineSyncLyricLine;
    return (
      <h3
        className={`lyric-line ${isActive ? "active" : ""} ${
          isUnsynced ? "unsynced" : ""
        }`}
        onClick={handleClick}
        data-line-index={index}
      >
        <div className="richl">{lineLyric.words}</div>
      </h3>
    );
  }
};

export default React.memo(LyricLine);


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\lyrics\LyricsView.tsx
import React, { useState, useEffect, useRef, useCallback } from "react";
import { fetchRichSyncLyrics, fetchLyrics } from "@/lib/utils";
import "@/styles/LyricsView.css";
import LyricLine from "./LyricLine";
import { motion } from "framer-motion";

interface RichSyncLyricLine {
  ts: number; // start time in seconds
  te: number; // end time in seconds
  l: { c: string; o: number }[]; // lyric characters and offsets
  x?: string;
  translation?: string;
}

interface LineSyncLyricLine {
  startTimeMs: string;
  words: string;
  endTimeMs: string;
}

interface RichSyncLyrics {
  syncType: "WORD_SYNCED";
  lines: RichSyncLyricLine[];
  provider?: string;
  timingType?: string;
  language?: string;
}

interface LineSyncLyrics {
  syncType: "LINE_SYNCED";
  lines: LineSyncLyricLine[];
  provider?: string;
  timingType?: string;
  language?: string;
}

type LyricsData = RichSyncLyrics | LineSyncLyrics;

interface LyricsViewProps {
  time: number;
  yoffset?: number;
  seekTo: (time: number) => void;
  playing: boolean;
  sourceInfo?: {
    provider: string;
    timingType: string;
    language: string;
  };
  songTitle: string;
  artistName: string;
  duration: number; // Duration of the song in seconds
}

const LyricsView: React.FC<LyricsViewProps> = ({
  time,
  yoffset = 128,
  seekTo,
  playing,
  sourceInfo,
  songTitle,
  artistName,
  duration,
}) => {
  const lyricsViewRef = useRef<HTMLDivElement>(null);
  const [currentLyricsLine, setCurrentLyricsLine] = useState<number>(-1);
  const [isUserScrolling, setIsUserScrolling] = useState(false);
  const [lyrics, setLyrics] = useState<LyricsData | null>(null);

  const delayfix = 0.8; // Adjust if necessary

  // Introduce smoothTime state
  const [smoothTime, setSmoothTime] = useState(time);

  const rafIdRef = useRef<number | null>(null);
  const startTimeRef = useRef<number>(performance.now());
  const initialTimeRef = useRef<number>(time);

  // Cache lyrics data
  const lyricsCache = useRef<{ [key: string]: LyricsData | null }>({});

  const requestIdRef = useRef(0);

  useEffect(() => {
    const cacheKey = `${songTitle}-${artistName}`;
    if (lyricsCache.current[cacheKey]) {
      setLyrics(lyricsCache.current[cacheKey]);
    } else {
      let isCancelled = false;
      const currentRequestId = ++requestIdRef.current;

      const fetchLyricsData = async () => {
        const richSyncLyrics = await getRichSyncLyrics(songTitle, artistName);
        if (isCancelled || currentRequestId !== requestIdRef.current) return;

        if (richSyncLyrics && richSyncLyrics.lines.length > 0) {
          lyricsCache.current[cacheKey] = richSyncLyrics;
          setLyrics(richSyncLyrics);
        } else {
          const lineSyncLyrics = await getLineSyncLyrics(songTitle, artistName);
          if (isCancelled || currentRequestId !== requestIdRef.current) return;

          if (lineSyncLyrics && lineSyncLyrics.lines.length > 0) {
            lyricsCache.current[cacheKey] = lineSyncLyrics;
            setLyrics(lineSyncLyrics);
          } else {
            lyricsCache.current[cacheKey] = null;
            setLyrics(null);
          }
        }
      };

      fetchLyricsData();

      return () => {
        isCancelled = true;
      };
    }
  }, [songTitle, artistName]);

  // Fetch functions
  const getRichSyncLyrics = async (
    songTitle: string,
    artistName: string
  ): Promise<RichSyncLyrics | null> => {
    try {
      // console.log(
      //   `fetchRichSyncLyrics | artist and title:", ${artistName} - ${songTitle})`
      // );
      const data = await fetchRichSyncLyrics(songTitle, artistName);
      if (!data || !data.lyrics || !data.lyrics.message.body.richsync)
        return null;
      const richsyncBody = data.lyrics.message.body.richsync.richsync_body;
      const richsyncLines: RichSyncLyricLine[] = JSON.parse(richsyncBody);
      return {
        syncType: "WORD_SYNCED",
        lines: richsyncLines,
        provider: data.lyrics.providerDisplayName,
        timingType: data.lyrics.syncType,
        language: data.lyrics.language,
      };
    } catch (error) {
      console.error("RichSync | Error processing richsync data:", error);
      return null;
    }
  };

  const getLineSyncLyrics = async (
    songTitle: string,
    artistName: string
  ): Promise<LineSyncLyrics | null> => {
    try {
      // console.log(
      //   `fetchLyrics | artist and title:", ${artistName} - ${songTitle})`
      // );
      const data = await fetchLyrics(songTitle, artistName);
      if (!data || !data.lyrics || !data.lyrics.lines) return null;
      const lines = data.lyrics.lines;
      return {
        syncType: "LINE_SYNCED",
        lines: lines,
        provider: data.lyrics.providerDisplayName,
        timingType: data.lyrics.syncType,
        language: data.lyrics.language,
      };
    } catch (error) {
      console.error("LineSync | Error processing line sync data:", error);
      return null;
    }
  };

  useEffect(() => {
    if (!lyrics) return;

    const update = () => {
      const now = performance.now();
      const elapsed = (now - startTimeRef.current) / 1000; // Convert to seconds
      setSmoothTime(initialTimeRef.current + elapsed);

      if (playing) {
        rafIdRef.current = requestAnimationFrame(update);
      }
    };

    if (playing) {
      startTimeRef.current = performance.now();
      initialTimeRef.current = time;
      rafIdRef.current = requestAnimationFrame(update);
    } else {
      // If paused, cancel the animation loop and set smoothTime to current time
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
      setSmoothTime(time);
    }

    // Clean up when the component unmounts or when playing changes
    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
    };
  }, [playing, time, lyrics]);

  useEffect(() => {
    if (!lyrics) return;
    getActiveLyric();
  }, [smoothTime, lyrics]);

  const getActiveLyric = useCallback(() => {
    if (!lyrics) return;

    for (let i = 0; i < lyrics.lines.length; i++) {
      let lineStartTime: number;
      let lineEndTime: number;

      if (lyrics.syncType === "WORD_SYNCED") {
        const line = lyrics.lines[i] as RichSyncLyricLine;
        lineStartTime = line.ts;
        lineEndTime = line.te;
      } else {
        const line = lyrics.lines[i] as LineSyncLyricLine;
        lineStartTime = parseInt(line.startTimeMs) / 1000;
        if (i < lyrics.lines.length - 1) {
          const nextLine = lyrics.lines[i + 1] as LineSyncLyricLine;
          lineEndTime = parseInt(nextLine.startTimeMs) / 1000;
        } else {
          lineEndTime = duration;
        }
      }

      if (
        smoothTime + delayfix >= lineStartTime &&
        smoothTime + delayfix <= lineEndTime
      ) {
        if (currentLyricsLine !== i) {
          setCurrentLyricsLine(i);
          scrollToActiveLine(i);
        }
        break;
      }
    }
  }, [smoothTime, lyrics, currentLyricsLine, delayfix, duration]);

  const scrollToActiveLine = useCallback(
    (lineIndex: number) => {
      if (isUserScrolling) return;

      if (lyricsViewRef.current) {
        const activeLine = lyricsViewRef.current.querySelector<HTMLDivElement>(
          `.lyric-line[data-line-index='${lineIndex}']`
        );
        if (activeLine) {
          activeLine.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }
    },
    [isUserScrolling]
  );

  const handleUserScroll = useCallback(() => {
    setIsUserScrolling(true);
    const timeoutId = setTimeout(() => {
      setIsUserScrolling(false);
    }, 2000);

    return () => clearTimeout(timeoutId);
  }, []);

  useEffect(() => {
    const lyricsContainer = lyricsViewRef.current;
    if (lyricsContainer) {
      lyricsContainer.addEventListener("scroll", handleUserScroll);
    }

    return () => {
      if (lyricsContainer) {
        lyricsContainer.removeEventListener("scroll", handleUserScroll);
      }
    };
  }, [handleUserScroll]);

  const getWordDuration = useCallback(
    (lineIndex: number, wordIndex: number): number => {
      if (!lyrics || lyrics.syncType !== "WORD_SYNCED") return 0.1;

      const line = lyrics.lines[lineIndex] as RichSyncLyricLine;
      const word = line.l[wordIndex];
      const wordStartTime = line.ts + word.o;

      let wordEndTime: number;

      // Check if there is a next word in the same line
      if (wordIndex + 1 < line.l.length) {
        const nextWord = line.l[wordIndex + 1];
        wordEndTime = line.ts + nextWord.o;
      } else {
        wordEndTime = line.te;
      }

      let duration = wordEndTime - wordStartTime;

      // Ensure minimum duration
      if (duration <= 0) {
        duration = 0.1; // Minimum duration of 0.1 seconds
      }

      return duration;
    },
    [lyrics]
  );

  if (!lyrics) {
    const loadingContainerVariants = {
      start: {
        transition: {
          staggerChildren: 0.2,
        },
      },
      end: {
        transition: {
          staggerChildren: 0.2,
        },
      },
    };

    const loadingCircleVariants = {
      start: {
        y: "0%",
      },
      end: {
        y: "100%",
      },
    };

    const loadingCircleTransition = {
      duration: 0.5,
      yoyo: Infinity,
      ease: "easeInOut",
    };

    return (
      <div className="lyrics-container pt-5">
        <p>Loading lyrics...</p>
      </div>
    );
  }

  return (
    <div ref={lyricsViewRef} className="md-body lyric-body lyrics-container">
      {lyrics.lines.map((lyric, index) => {
        const isActive = index === currentLyricsLine;
        const isUnsynced = false; // Adjust if needed

        return (
          <LyricLine
            key={index}
            index={index}
            lyric={lyric}
            isActive={isActive}
            isUnsynced={isUnsynced}
            seekTo={seekTo}
            smoothTime={smoothTime}
            delayfix={delayfix}
            getWordDuration={getWordDuration}
            syncType={lyrics.syncType}
          />
        );
      })}
      {/* Display source information if available */}
      {sourceInfo && (
        <div className="source-info">
          <p>
            {sourceInfo.provider} - {sourceInfo.timingType} (
            {sourceInfo.language})
          </p>
        </div>
      )}
    </div>
  );
};

export default LyricsView;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\lyrics\LyricWord.tsx
import React, { useMemo, useEffect } from "react";

interface RichSyncLyricLine {
  ts: number; // Start time in seconds
  te: number; // End time in seconds
  l: { c: string; o: number }[]; // Characters and their offsets
}

interface LyricWordProps {
  lineIndex: number;
  verseIndex: number;
  verse: { c: string; o: number };
  lyric: RichSyncLyricLine;
  smoothTime: number;
  delayfix: number;
  getWordDuration: (lineIndex: number, wordIndex: number) => number;
}

const LyricWord: React.FC<LyricWordProps> = ({
  lineIndex,
  verseIndex,
  verse,
  lyric,
  smoothTime,
  delayfix,
  getWordDuration,
}) => {
  const wordStartTime = lyric.ts + verse.o;
  const wordDuration = getWordDuration(lineIndex, verseIndex);

  // Define an epsilon to prevent overlapping activations
  const epsilon = 0.05; // 50ms buffer

  // Determine if the word is active based on current time
  const isWordActive =
    smoothTime + delayfix >= wordStartTime &&
    smoothTime + delayfix < wordStartTime + wordDuration - epsilon;

  // Determine if the word is completed
  const isWordCompleted =
    smoothTime + delayfix >= wordStartTime + wordDuration - epsilon;

  // Assign appropriate CSS classes based on word state
  let wordClassName = "word";
  if (isWordActive) {
    wordClassName += " word-active";
  } else if (isWordCompleted) {
    wordClassName += " word-completed";
  }

  // Determine if a space should be added before this word
  const addSpaceBefore = verseIndex > 0;

  // Split the word into individual characters
  const characters = useMemo(() => Array.from(verse.c), [verse.c]);

  // Count non-space characters for animation timing
  const nonSpaceCharCount = useMemo(
    () => characters.filter((char) => char !== " ").length,
    [characters]
  );

  // Calculate duration for each character's animation
  const charDuration =
    nonSpaceCharCount > 0 ? wordDuration / nonSpaceCharCount : wordDuration;

  // Calculate word progress as a percentage (0% to 100%)
  const wordProgress = useMemo(() => {
    if (isWordActive) {
      const progress =
        ((smoothTime + delayfix - wordStartTime) / wordDuration) * 100;
      // Clamp the progress between 0% and 100%
      return `${Math.min(Math.max(progress, 0), 100)}%`;
    } else if (isWordCompleted) {
      return "100%";
    } else {
      return "0%";
    }
  }, [
    isWordActive,
    isWordCompleted,
    smoothTime,
    delayfix,
    wordStartTime,
    wordDuration,
  ]);

  // Debugging: Log the active state and progress
  useEffect(() => {
    console.log(
      `Word [Line ${lineIndex} Word ${verseIndex}]: Active=${isWordActive}, Completed=${isWordCompleted}, Progress=${wordProgress}`
    );
  }, [isWordActive, isWordCompleted, wordProgress, lineIndex, verseIndex]);

  return (
    <React.Fragment>
      {addSpaceBefore && <span className="word-space"> </span>}
      <span
        className={wordClassName}
        data-start-time={wordStartTime}
        data-duration={wordDuration}
        style={
          isWordActive || isWordCompleted
            ? ({
                "--word-duration": `${wordDuration}s`,
                "--bgProgress": wordProgress,
                "--char-count": nonSpaceCharCount,
                "--char-duration": `${charDuration}s`,
              } as React.CSSProperties)
            : {}
        }
      >
        {characters.map((char, charIndex) => {
          if (char === " ") {
            // Render space without animation
            return (
              <span key={charIndex} className="char space">
                {char}
              </span>
            );
          } else {
            // Calculate animation delay for non-space characters
            const nonSpaceIndex = characters
              .slice(0, charIndex)
              .filter((c) => c !== " ").length;
            const charDelay = nonSpaceIndex * charDuration;

            return (
              <span
                key={charIndex}
                className="char"
                style={
                  isWordActive
                    ? ({
                        "--char-animation-delay": `${charDelay}s`,
                      } as React.CSSProperties)
                    : {}
                }
              >
                {char}
              </span>
            );
          }
        })}
      </span>
    </React.Fragment>
  );
};

export default React.memo(LyricWord);


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\home\SongCard.tsx
import React from "react";
import Image from "next/image";
import { Skeleton } from "@/components/skeletons/skeleton";
import { CanvasBackground } from "@/components/CanvasBackground";

interface SongCard {
  img: string;
  title: string;
  artist: string;
  id?: string;
  kind?: string;
  onClick?: () => void;
}

const SongCardSkeleton = () => {
  return (
    <>
      <div className="min-w-[15rem] min-h-[7.5rem]">
        <div className="text-white bg-foreground/5 rounded-2xl overflow-hidden">
          <Skeleton className="size-full aspect-square rounded-xl" />
          <div className="p-2 text-center flex flex-col items-center gap-1">
            <Skeleton className="bg-foreground/5 w-full h-[1rem] rounded-xl" />
            <Skeleton className="bg-foreground/5 w-[50%] h-[1rem] rounded-xl" />
          </div>
        </div>
      </div>
    </>
  );
};

export const SongCard = ({
  onClick,
  img,
  title,
  artist,
  id,
  kind,
}: SongCard) => {
  if (!img && !title && !artist) return <SongCardSkeleton />;
  return (
    <div onClick={onClick} className="min-w-[15rem] h-[22rem] max-sm:h-[20rem]">
      <div className="text-white rounded-2xl overflow-hidden">
        <CanvasBackground
          blur={120}
          className="h-[22rem] max-sm:h-[20rem]"
          src={img}
        >
          <Image
            className="border-b border-border/50 aspect-square"
            src={img}
            alt={title || "Title"}
            width={500}
            height={500}
            draggable={false}
            unoptimized={true}
          />
          <div className="p-2 pb-3 text-center h-[25%] flex flex-col justify-center items-center">
            <p className="font-bold">{title || "Title"}</p>
            <p>{artist || "Artist"}</p>
          </div>
        </CanvasBackground>
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\LibraryCard.tsx
import Image from "next/image";
import { useEffect, useState, useCallback } from "react";
import { Skeleton } from "../skeletons/skeleton";
import "../../styles/album.css";
import { useTheme } from "next-themes";
import Loader from "react-loaders";
import "loaders.css";

export const LibraryCard = ({
  songId,
  handlePlaySong,
  isExplicit,
  isPlaying,
}: {
  songId: string;
  handlePlaySong: (id: string) => void;
  isExplicit?: boolean;
  isPlaying?: boolean;
}) => {
  const [songData, setSongData] = useState<any>(null);
  const { theme } = useTheme();

  useEffect(() => {
    const fetchSongData = async () => {
      try {
        const response = await fetch(`/api/track/info/${songId}`);
        const data = await response.json();
        setSongData(data);
      } catch (error) {
        console.error("Error fetching song data:", error);
      }
    };

    fetchSongData();
  }, [songId]);

  const handleClick = useCallback(() => {
    handlePlaySong(songId);
  }, [handlePlaySong, songId]);

  if (!songData?.title) {
    return <LibraryCardSkeleton />;
  }

  return (
    <>
      <div
        onClick={handleClick}
        className="library-card w-full py-[1.5px] pl-5 flex items-center gap-3 cursor-pointer desktop-hover-library-card standalone:active:bg-foreground/5 transition-colors duration-150 standalone:duration-300"
      >
        <div className="size-12">
          <div className="album-container album-shadow !w-12 !mb-0">
            {isPlaying && (
              <div className="size-full bg-black/50 absolute rounded-md flex items-center justify-center">
                <Loader
                  innerClassName="scale-[0.4] *:!bg-white"
                  type="line-scale-pulse-out"
                  active
                />
              </div>
            )}
            <Image
              width={1000}
              height={1000}
              src={
                songData.artwork_url ||
                (theme === "light"
                  ? "/assets/placeholders/missing_song_light.png"
                  : "/assets/placeholders/missing_song_dark.png")
              }
              alt={songData.title || ""}
              className="size-12 rounded-md"
              onError={(e) => {
                e.currentTarget.style.background =
                  "linear-gradient(to right, #FFA500, #FF4500)";
                e.currentTarget.src =
                  "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; // 1x1 transparent gif
              }}
              draggable={false}
              unoptimized={true}
            />
            <div className="album-border !border-[0.5px] !border-white/50 !rounded-md" />
          </div>
        </div>
        <div className="flex flex-col flex-grow justify-center w-[70vw] standalone:w-[65vw] h-12 pr-5">
          <div className="flex items-center gap-1.5">
            <p className="truncate text-base leading-[1.25rem]">
              {songData.title}
            </p>
            {isExplicit && <p className="opacity-50 scale-110">🅴</p>}
          </div>
          <p className="text-sm text-muted-foreground truncate">
            {songData.user.username}
          </p>
          {/* <div className="w-[77%] h-[1px] bg-muted-foreground/10 absolute translate-y-[1.75rem]" /> */}
        </div>
      </div>
    </>
  );
};

export const LibraryCardSkeleton = () => {
  return (
    <>
      <div className="w-full py-[1.5px] pl-5 flex items-center gap-3 cursor-pointer desktop-hover-library-card standalone:active:bg-foreground/5 transition-colors duration-150 standalone:duration-300">
        <div className="min-w-12">
          <Skeleton className="size-12 rounded-md aspect-square" />
        </div>
        <div className="flex flex-col flex-grow justify-center gap-1 w-[70vw] standalone:w-[65vw] h-12 pr-5">
          <div className="flex items-center gap-1.5">
            <Skeleton className="w-[25vw] h-[1rem] rounded-sm" />
          </div>
          <Skeleton className="w-[15vw] h-[1rem] rounded-sm" />
        </div>
      </div>
    </>
  );
};

// a<div
// onClick={onClick}
// className="w-full py-4 flex items-center gap-4 px-4 cursor-pointer hover:bg-foreground/5 transition-colors duration-150 rounded-xl"
// >
// <div className="min-w-16">
//   <Image
//     width={1000}
//     height={1000}
//     src={
//       songData.artwork_url ||
//       "https://t3.ftcdn.net/jpg/05/16/27/58/360_F_516275801_f3Fsp17x6HQK0xQgDQEELoTuERO4SsWV.jpg"
//     }
//     alt={songData.title || ""}
//     className="size-16 rounded-lg"
//     onError={(e) => {
//       e.currentTarget.style.background =
//         "linear-gradient(to right, #FFA500, #FF4500)";
//       e.currentTarget.src =
//         "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; // 1x1 transparent gif
//     }}
//     draggable={false}
//     unoptimized={true}
//   />
// </div>
// <div className="flex flex-col flex-grow">
//   <div className="flex items-center gap-2 w-[70vw] standalone:w-[65vw]">
//     <h1 title={songData.title} className="whitespace-nowrap truncate">
//       {songData.publisher_metadata?.explicit
//         ? `${songData.title} 🅴`
//         : songData.title}
//     </h1>
//     {/* {premium === true && (
//       <span
//         title="This content is a preview because of SoundCloud encryption"
//         className="bg-orange-500 p-0.5 text-xs rounded-md"
//       >
//         Go+
//       </span>
//     )} */}
//   </div>
//   <h2 className="text-muted-foreground">{songData.user.username}</h2>
// </div>
// {/* <div onClick={handleFavoriteClick} className="cursor-pointer">
//   {isFavorited ? (
//     <IoHeart className="scale-y-[.95] text-red-500" size={24} />
//   ) : (
//     <IoHeartOutline className="scale-y-[.95]" size={24} />
//   )}
// </div> */}
// a</div>


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\Navbar.tsx
"use client";
import Link from "next/link";
import React from "react";
import { GoHomeFill } from "react-icons/go";
import { IoAlbums, IoSearch } from "react-icons/io5";
import { usePathname } from "next/navigation";
import { motion } from "framer-motion";
import { LinearBlur } from "progressive-blur";

export const Navbar = ({
  volume,
  setVolume,
  muted,
  setMuted,
  playing,
  setPlaying,
  duration,
  played,
  onSeek,
}: {
  volume?: number;
  setVolume?: (volume: number) => void;
  muted?: boolean;
  setMuted?: (muted: boolean) => void;
  playing?: boolean;
  setPlaying?: (playing: boolean) => void;
  duration?: number;
  played?: number;
  onSeek?: (time: number) => void;
}) => {
  const pathname = usePathname();
  const isLinkActive = (href: string) => pathname === href;

  return (
    <div className="navbar-mobile-container select-none !z-[100] relative">
      <nav className="navbar-mobile">
        <motion.div whileTap={{ scale: 0.925 }}>
          <Link href={"/"} className="flex flex-col items-center">
            <GoHomeFill
              className={`navbar-icon ${
                isLinkActive("/") ? "text-ambient" : "text-foreground/30"
              }`}
              size={30}
            />
            <span
              className={`navbar-icon-title ${
                isLinkActive("/") ? "text-ambient" : "text-foreground/30"
              }`}
            >
              Home
            </span>
          </Link>
        </motion.div>
        <motion.div whileTap={{ scale: 0.925 }}>
          <Link href={"/search"} className="flex flex-col items-center">
            <IoSearch
              className={`navbar-icon ${
                isLinkActive("/search") ? "text-ambient" : "text-foreground/30"
              }`}
              size={30}
            />
            <span
              className={`navbar-icon-title ${
                isLinkActive("/search") ? "text-ambient" : "text-foreground/30"
              }`}
            >
              Search
            </span>
          </Link>
        </motion.div>
        <motion.div whileTap={{ scale: 0.925 }}>
          <Link href={"/library"} className="flex flex-col items-center">
            <IoAlbums
              className={`navbar-icon ${
                isLinkActive("/library") ? "text-ambient" : "text-foreground/30"
              }`}
              size={30}
            />
            <span
              className={`navbar-icon-title ${
                isLinkActive("/library") ? "text-ambient" : "text-foreground/30"
              }`}
            >
              Library
            </span>
          </Link>
        </motion.div>
      </nav>
      <div className="w-screen h-screen overflow-hidden bottom-0 absolute blur-pro">
        <LinearBlur
          side="bottom"
          tint="rgba(255, 255, 255, 0)"
          falloffPercentage={100}
          strength={128}
          style={{
            position: "fixed",
            width: "100vw",
            height: "100vh",
            pointerEvents: "none",
          }}
        />
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\SafeView.tsx
import React, {
  InputHTMLAttributes,
  ReactNode,
  useEffect,
  useRef,
  useState,
} from "react";
import { IoSearch } from "react-icons/io5";
import { useRouter } from "next/navigation";
import { IoIosArrowBack, IoIosArrowForward } from "react-icons/io";
import { motion } from "framer-motion";
import Link from "next/link";

interface SafeViewProps {
  children?: ReactNode;
  className?: string;
  backButton?: boolean;
}

export const SafeView: React.FC<SafeViewProps> = ({
  children,
  className = "",
  backButton,
}) => {
  return (
    <>
      {backButton ? (
        <div className="z-50 relative pt-5 standalone:pt-0">
          <BackButton />
        </div>
      ) : null}
      <div
        className={`${className} pt-8 standalone:pt-12 pb-40 px-5 min-w-screen min-h-screen select-none`}
      >
        {children ? children : <p>No content available</p>}
      </div>
    </>
  );
};

export const Heading = ({
  children,
  className = "",
}: {
  children: ReactNode;
  className?: string;
}) => {
  return (
    <h1 className={`${className} text-4xl font-bold mb-4`}>
      {children ? children : <p>Home</p>}
    </h1>
  );
};

export const SubHeading = ({
  children,
  subtitle,
  className = "",
  link,
  onClick,
}: {
  children: ReactNode;
  subtitle?: string;
  className?: string;
  link?: string;
  onClick?: () => void;
}) => {
  return (
    <div onClick={onClick} className={`${className}`}>
      <h1 className="text-3xl font-bold flex items-center gap-2">
        {link ? (
          <motion.button
            whileTap={{
              scale: 0.95,
              translateX: -5,
            }}
            transition={{ duration: 0.125, ease: "easeInOut" }}
          >
            <Link href={link}>
              <div className="flex items-center gap-2">
                {children}
                <IoIosArrowForward
                  className="text-muted-foreground"
                  size={24}
                />
              </div>
            </Link>
          </motion.button>
        ) : (
          children
        )}
      </h1>
      {subtitle && (
        <h4 className="text-sm text-muted-foreground">
          <p>{subtitle}</p>
        </h4>
      )}
    </div>
  );
};

export const ScrollHeader = ({
  title,
  className = "",
  value,
  onChange,
  onSearch,
  onKeyDown,
  autoFocus,
}: {
  title: string;
  className?: string;
  value?: string;
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onSearch?: () => void;
  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  autoFocus?: boolean;
}) => {
  const [isScrolled, setIsScrolled] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY > 37) {
        setIsScrolled(true);
      } else {
        setIsScrolled(false);
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return (
    <div
      className={`fixed top-0 left-0 w-full z-[150] transition-all opacity-0 pt-8 standalone:pt-12 pb-2 px-5 ${
        isScrolled
          ? "bg-background/75 backdrop-blur-2xl pt-14 opacity-[1] standalone:pt-[3.6rem]  pb-2 px-5"
          : "bg-transparent py-4"
      } ${className}`}
    >
      {/* Only show title when scrolled */}
      {isScrolled && (
        <>
          <h1 className="text-lg font-semibold text-center">{title}</h1>
          <Input
            value={value}
            onChange={onChange}
            onKeyDown={onKeyDown}
            placeholder="Search"
            onSearch={onSearch}
            autoFocus={autoFocus}
            className="mb-5"
          />
        </>
      )}
    </div>
  );
};

export const Header = ({
  title,
  className = "",
  children,
}: {
  title: string;
  className?: string;
  children?: ReactNode;
}) => {
  const [isScrolled, setIsScrolled] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY > 30) {
        setIsScrolled(true);
      } else {
        setIsScrolled(false);
      }
    };
    window.addEventListener("scroll", handleScroll);
    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, []);

  return (
    <div className={`${className}`}>
      <Heading>{title}</Heading>
      <div
        className={`${
          isScrolled
            ? "fixed top-0 left-0 w-full z-50 bg-foreground/75 backdrop-blur-2xl pt-10 standalone:pt-16 pb-2"
            : "relative pt-10 pb-4"
        } transition-all`}
      >
        <Input placeholder="Search" className="" />
      </div>
      <div className={`pt-20 ${isScrolled ? "mt-12" : ""}`}>{children}</div>
    </div>
  );
};

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  className?: string;
  onSearch?: () => void;
  icon?: React.ReactNode | false;
}

export const Input: React.FC<InputProps> = ({
  className,
  onSearch,
  autoFocus,
  placeholder,
  type,
  title,
  icon,
  ...props
}) => {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (autoFocus && inputRef.current) {
      inputRef.current.focus();
    }
  }, [autoFocus]);

  return (
    <>
      <div
        className={`${
          className || ""
        } bg-foreground/[0.05] w-full rounded-xl relative flex items-center px-2 gap-2`}
      >
        {icon !== false && (
          <button>
            {icon || (
              <IoSearch
                onClick={onSearch}
                className="text-muted-foreground"
                size={20}
              />
            )}
          </button>
        )}
        <input
          {...props}
          ref={inputRef}
          spellCheck="true"
          type={type}
          className={`appearance-none py-2 bg-transparent w-full placeholder:text-muted-foreground focus:outline-none ${
            icon === false ? "pl-2" : ""
          }`}
          placeholder={placeholder}
          aria-haspopup="false"
          title={title}
        />
      </div>
    </>
  );
};

export const ScrollContainer = ({
  children,
  className,
}: {
  children: ReactNode;
  className?: string;
}) => {
  return (
    <div
      className={`${className} flex overflow-x-scroll pb-5 max-sm:pb-3 hide-scroll-bar gap-2`}
    >
      {children}
    </div>
  );
};

export const BackButton = ({ className }: { className?: string }) => {
  const router = useRouter();
  const handleBack = () => {
    const currentUrl = window.location.hostname;
    if (
      document.referrer &&
      new URL(document.referrer).hostname === currentUrl
    ) {
      router.back();
    } else {
      router.push("/");
    }
  };
  return (
    <motion.button
      whileTap={{
        scale: 0.9,
        backgroundColor: "rgba(255, 255, 255, 0.15)",
      }}
      transition={{ duration: 0.125, ease: "easeInOut" }}
      onClick={handleBack}
      className={`${className} flex items-center space-x-2 p-2 max-sm:pl-1 cursor-pointer rounded-[50%] sm:hover:bg-[rgba(255,255,255,0.1)] sm:ml-4 transition-colors ease-out`}
    >
      <IoIosArrowBack size={30} />
      <span className="sr-only">Back</span>
    </motion.button>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\SearchCard.tsx
import Image from "next/image";
import React, { useState, useEffect } from "react";
import { IoHeartOutline, IoHeart } from "react-icons/io5";
import { RiVerifiedBadgeFill } from "react-icons/ri";
import { useLibrary } from "@/hooks/useLibrary"; // Adjust the path according to your structure
import { ChevronRight } from "lucide-react";
import { useTheme } from "next-themes";

export const SearchCard = ({
  className,
  id,
  title,
  artistName,
  image,
  artist,
  track,
  playlist,
  verified,
  premium,
  isExplicit,
  onClick,
}: {
  className?: string;
  id?: string;
  title?: string;
  artistName?: string;
  image?: string;
  artist?: boolean;
  track?: boolean;
  playlist?: boolean;
  verified?: boolean;
  premium?: boolean;
  isExplicit?: boolean;
  onClick?: () => void;
}) => {
  const { addSong, removeSong, isSongInLibrary } = useLibrary();
  const songId = `${id}`; // Unique identifier for the song
  const [isFavorited, setIsFavorited] = useState(false);
  const { theme } = useTheme();

  useEffect(() => {
    // Check if the song is already in the library on component mount
    setIsFavorited(isSongInLibrary(songId));
  }, [songId, isSongInLibrary]);

  const handleFavoriteClick = () => {
    if (isFavorited) {
      removeSong(songId);
      setIsFavorited(false);
    } else {
      addSong({
        id: songId,
        title: title || "Unknown Title",
        artist: artistName || "Unknown Artist",
      });
      setIsFavorited(true);
    }
  };

  return (
    <div
      className={`${className || ""}w-full py-4 flex items-center gap-4 px-4`}
    >
      <div onClick={onClick} className="absolute w-[90%] h-20 bg-black/0" />
      <div>
        <Image
          width={1000}
          height={1000}
          src={
            image ||
            (theme === "light"
              ? "/assets/placeholders/missing_song_light.png"
              : "/assets/placeholders/missing_song_dark.png")
          }
          alt={title || ""}
          className={`min-w-16 aspect-square size-16 ${
            artist ? "rounded-full" : "rounded-lg"
          }`}
          onError={(e) => {
            e.currentTarget.style.background =
              "linear-gradient(to right, #FFA500, #FF4500)";
            e.currentTarget.src =
              "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; // 1x1 transparent gif
          }}
          draggable={false}
          unoptimized={true}
        />
      </div>
      {artist && (
        <div className="flex items-center justify-between w-full gap-2">
          <div>
            <h1>{title}</h1>
            <h2 className="text-muted-foreground">Artist</h2>
            {verified === true && (
              <span className="text-muted-foreground">
                <RiVerifiedBadgeFill className="text-[#699fff]" />
              </span>
            )}
          </div>
          <div>
            <ChevronRight size={24} className="text-muted-foreground/30" />
          </div>
        </div>
      )}
      {track && (
        <>
          <div className="flex items-center justify-between w-full gap-2">
            <div className="flex flex-col">
              <div className="flex items-center gap-2">
                <h1
                  title={title}
                  className="truncate max-w-[75vw] max-sm:max-w-[50vw]"
                >
                  {isExplicit ? `${title} 🅴` : title}
                </h1>
                {premium === true && (
                  <span
                    title="This content is a preview because of SoundCloud encryption"
                    className="bg-orange-500 p-0.5 text-xs rounded-md"
                  >
                    Go+
                  </span>
                )}
              </div>
              <h2 className="text-muted-foreground">Song · {artistName}</h2>
            </div>
            <div onClick={handleFavoriteClick} className="cursor-pointer">
              {isFavorited ? (
                <IoHeart className="scale-y-[.95] text-red-500" size={24} />
              ) : (
                <IoHeartOutline
                  className="scale-y-[.95] text-muted-foreground/30"
                  size={24}
                />
              )}
            </div>
          </div>
        </>
      )}
      {playlist && (
        <div className="flex items-center justify-between w-full gap-2">
          <div>
            <h1 className="truncate max-w-[75vw] max-sm:max-w-[50vw]">
              {title}
            </h1>
            <h2 className="text-muted-foreground">Playlist</h2>
          </div>
          <div>
            <ChevronRight size={24} className="text-muted-foreground/30" />
          </div>
        </div>
      )}
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\mobile\TitleOverflowAnimator.tsx
// import React, { useState, useEffect, useRef } from "react";
// import { motion, useAnimation } from "framer-motion";
// import "../../styles/TitleOverflowAnimator.css";

// export const TitleOverflowAnimator: React.FC<{ children: React.ReactNode }> = ({
//   children,
// }) => {
//   const [isOverflowing, setIsOverflowing] = useState(false);
//   const containerRef = useRef<HTMLDivElement>(null);
//   const contentRef = useRef<HTMLDivElement>(null);
//   const controls = useAnimation();

//   useEffect(() => {
//     const container = containerRef.current;
//     const content = contentRef.current;
//     const screenWidth = window.innerWidth;
//     setIsOverflowing(screenWidth < 500);
//     // console.log("marquee | screenWidth:", screenWidth);
//     // console.log("marquee | is screenWidth under 500px?", screenWidth < 500);

//     if (isOverflowing) {
//       // console.log("marquee | isContentOverflowing:", isOverflowing);
//       if (container && content) {
//         const containerWidth = window.innerWidth * 0.45; // Fixed container width
//         const contentWidth = content.scrollWidth;
//         // console.log("marquee | contentWidth:", contentWidth);
//         const isContentOverflowing = containerWidth;
//         // console.log("marquee | container && content:", container && content);

//         if (isContentOverflowing) {
//           // console.log("contentWidth:", contentWidth);
//           const singleCopyWidth = contentWidth / 2;
//           // console.log("singleCopyWidth:", singleCopyWidth);
//           const animationDistance = singleCopyWidth;
//           // console.log("animationDistance:", animationDistance);
//           const animationDuration = animationDistance / 45  ; // Adjust speed as needed
//           // console.log("animationDuration:", animationDuration);

//           setTimeout(() => {
//             controls.start({
//               x: [-0, -animationDistance],
//               transition: {
//                 duration: animationDuration,
//                 ease: "linear",
//                 repeat: Infinity,
//                 repeatDelay: 10,
//                 delay: 1,
//               },
//             });
//           }, 1000); // 5 second delay before animation starts
//         }
//       }
//     } else {
//       controls.stop();
//     }
//   }, [children, controls, isOverflowing, setIsOverflowing]);

//   return (
//     <div className="marquee-container" ref={containerRef}>
//       <motion.div
//         className="marquee-content"
//         ref={contentRef}
//         animate={controls}
//       >
//         <span>{children}</span>
//         {isOverflowing && <span>{children}</span>}
//       </motion.div>
//     </div>
//   );
// };

import React, { useEffect, useRef, useState } from "react";
import { motion } from "framer-motion";
import "../../styles/TitleOverflowAnimator.css";

export const TitleOverflowAnimator: React.FC<{
  children: React.ReactNode;
  className?: string | null;
}> = ({ children, className }) => {
  const child = useRef<HTMLSpanElement>(null);
  const [contentWidth, setContentWidth] = useState(0);
  const [isOverflowing, setIsOverflowing] = useState(false);

  useEffect(() => {
    if (child.current) {
      const measuredWidth = child.current.scrollWidth;
      const windowWidthThreshold = window.innerWidth * 0.5;

      // Check if the content width exceeds half of the window's width
      if (measuredWidth > windowWidthThreshold) {
        setIsOverflowing(true);
        setContentWidth(measuredWidth * 2); // Double width for both spans
      } else {
        setIsOverflowing(false);
        setContentWidth(measuredWidth); // Single span width
      }

      // Set the content width to a CSS variable called --overflow-title-width
      document.documentElement.style.setProperty(
        "--overflow-title-width",
        `${measuredWidth}px`
      );
    }
  }, [children]);

  const marqueeVariants = {
    animate: {
      x: isOverflowing ? [0, -contentWidth / 2] : [0], // Only animate if overflowing
      transition: isOverflowing
        ? {
            delay: 5,
            duration: 10, // Adjust the duration to control the speed of the animation
            ease: "linear",
            repeat: Infinity, // Loop the animation infinitely
            repeatDelay: 5, // Delay between each loop
          }
        : {}, // No animation if not overflowing
    },
  };

  return (
    <div className={`marquee-container ${className}`}>
      <motion.div
        className="marquee-content"
        variants={marqueeVariants}
        animate="animate"
        style={{ width: isOverflowing ? `${contentWidth}px` : "auto" }} // Ensure the container is wide enough
      >
        <span ref={child}>{children}</span>
        {isOverflowing && <span>{children}</span>}{" "}
        {/* Duplicate only if overflowing */}
      </motion.div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\PersistentAudioPlayer.tsx
"use client";
import { AudioPlayer } from "@/components/player/AudioPlayer";
import useAudioStore from "@/context/AudioContext";
import { useEffect } from "react";

export const PersistentAudioPlayer = () => {
  const {
    currentTrack,
    playlistUrl,
    cover,
    playNextTrack,
    playPreviousTrack,
    isPlaying,
  } = useAudioStore();

  useEffect(() => {
    const setPageTitle = async () => {
      // const fixedTitle = artistNameRemove(currentTrack.user.username, currentTrack.title)
      const fixedTitle = currentTrack?.title;
      if (!currentTrack) {
        console.log("No current track | PersistentAudioPlayer");
      }
      const title = fixedTitle ? `${fixedTitle}` : "Gaku";
      document.title = title;
    };

    if (currentTrack) {
      setPageTitle();
    }
  }, [currentTrack]);

  // const artistNameRemove = (artistName: string, trackTitle: string): string => {
  //   // Create a regular expression to match the artist name and a dash
  //   const regex = new RegExp(`^${artistName}\\s*-\\s*`, "i");
  //   // Replace the artist name and dash with an empty string
  //   return trackTitle.replace(regex, "").trim();
  // };

  if (!playlistUrl || !currentTrack) return null;

  // console.log("PersistentAudioPlayer");
  // console.log("PersistentAudioPlayer | currentTrack:", currentTrack);
  // console.log(
  //   "PersistentAudioPlayer | currentTrack Username:",
  //   currentTrack.user.username
  // );

  return (
    <div className="pb-[20rem] z-[200] absolute">
      <AudioPlayer
        height="100%"
        img={cover || currentTrack.artwork_url || ""}
        // title={artistNameRemove(currentTrack.user.username, currentTrack.title)}
        title={currentTrack.title}
        artist={currentTrack.user?.username || currentTrack.artist}
        album={currentTrack.publisher_metadata?.album_title || ""}
        src={playlistUrl}
        isExplicit={currentTrack.publisher_metadata?.explicit === true}
        onNext={playNextTrack}
        onEnded={playNextTrack}
        onPrevious={playPreviousTrack} // Automatically play the next track when the current one ends
      />
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\AudioPlayer.tsx
"use client";
import { useRef, useState, useEffect } from "react";
import ReactPlayer from "react-player";
import {
  IoPause,
  IoPlay,
  IoPlayBack,
  IoPlayForward,
  IoVolumeMedium,
  IoVolumeMute,
  IoVolumeOff,
} from "react-icons/io5";
import { FaPause } from "react-icons/fa6";
import Image from "next/image";
import { AnimatePresence, motion, transform } from "framer-motion";
import { TitleOverflowAnimator } from "../mobile/TitleOverflowAnimator";
import useAudioStore from "@/context/AudioContext";
import "../../styles/overlay.css";
import "../../styles/playercontrols.css";
import { CanvasBackground } from "../CanvasBackground";
import { BubbleChat, XMark } from "react-ios-icons";
import { useTheme } from "next-themes";
import { Lyric } from "@/lib/types";

import LyricsView from "../lyrics/LyricsView";
import timelessData from "../../../etc/test/timeless.json";
import { LyricIcon } from "../Icons/LyricIcon";

export const AudioPlayer = ({
  src,
  width,
  height,
  volume: initialVolume = 0.1,
  title,
  artist,
  album,
  img,
  onEnded,
  onNext,
  onPrevious,
  isExplicit,
  onPlayPause,
}: {
  src: string | string[] | MediaStream | undefined;
  width?: string | number | undefined;
  height?: string | number | undefined;
  volume?: number | undefined;
  title?: string;
  artist?: string;
  album?: string;
  img?: string;
  onEnded?: () => void;
  onNext?: () => void;
  onPrevious?: () => void;
  isExplicit?: boolean;
  onPlayPause?: (playing: boolean) => void;
}) => {
  const { setIsPlaying } = useAudioStore();
  const [volume, setVolume] = useState(initialVolume);
  const [muted, setMuted] = useState(false);
  const [playing, setPlaying] = useState(true);
  const [duration, setDuration] = useState(0);
  const [played, setPlayed] = useState(0);
  const playerRef = useRef<ReactPlayer>(null);
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    if ("mediaSession" in navigator) {
      const isIPhone = /iPhone/i.test(navigator.userAgent);
      const displayTitle = isIPhone && isExplicit ? `${title} 🅴` : title;
      navigator.mediaSession.metadata = new MediaMetadata({
        title: displayTitle || "Unknown Title",
        artist: artist || "Unknown Artist",
        album: album || "",
        artwork: [
          {
            src: img || "default-image.jpg",
            sizes: "512x512",
            type: "image/png",
          },
        ],
      });

      navigator.mediaSession.setActionHandler("play", () => {
        setPlaying(true);
      });
      navigator.mediaSession.setActionHandler("pause", () => {
        setPlaying(false);
      });
      navigator.mediaSession.setActionHandler("nexttrack", () => {
        console.log('User clicked "Next Track" icon.');
        if (onNext) {
          onNext();
        }
      });
      navigator.mediaSession.setActionHandler("previoustrack", () => {
        console.log('User clicked "Previous Track" icon.');
        if (playerRef.current && playerRef.current.getCurrentTime() > 3) {
          playerRef.current.seekTo(0);
        } else if (onPrevious) {
          onPrevious();
        }
      });
      navigator.mediaSession.setActionHandler("seekto", (details) => {
        if (details.seekTime && playerRef.current) {
          playerRef.current.seekTo(details.seekTime, "seconds");
        }
      });

      const updatePositionState = () => {
        if (playerRef.current) {
          navigator.mediaSession.setPositionState({
            duration: duration,
            playbackRate: playerRef?.current.getInternalPlayer().playbackRate,
            position: playerRef.current.getCurrentTime(),
          });
        }
      };

      const positionUpdateInterval = setInterval(updatePositionState, 1000);

      return () => {
        clearInterval(positionUpdateInterval);
      };
    }
  }, [title, artist, img, onNext, onPrevious, duration]);

  const handleDuration = (duration: number) => {
    setDuration(duration);
  };

  const handleProgress = (state: { played: number }) => {
    setPlayed(state.played);
  };

  const handlePrevious = () => {
    if (playerRef.current && playerRef.current.getCurrentTime() > 3) {
      playerRef.current.seekTo(0);
    } else if (onPrevious) {
      onPrevious();
    }
  };

  const handleBack = () => {
    setIsExpanded(false); // Close the expanded view
  };

  return (
    <>
      <ReactPlayer
        ref={playerRef}
        volume={muted ? 0 : volume}
        url={src}
        playing={playing}
        width="0px"
        height="0px"
        onDuration={handleDuration}
        onProgress={handleProgress}
        onEnded={onEnded}
      />
      {isExpanded ? (
        <motion.div
          initial={{ y: "100%" }}
          animate={{ y: 0 }}
          exit={{ y: "100%" }}
          transition={{ duration: 0.3, ease: "easeInOut" }}
        >
          <ExpandedPlayerControls
            volume={volume}
            setVolume={setVolume}
            muted={muted}
            setMuted={setMuted}
            playing={playing}
            setPlaying={setPlaying}
            duration={duration}
            played={played}
            onSeek={(time) => playerRef.current?.seekTo(time)}
            title={title || "Unknown Title"}
            artist={artist || "Unknown Artist"}
            img={img}
            onNext={onNext}
            onPrevious={handlePrevious}
            onPlayPause={onPlayPause}
            setIsPlaying={setIsPlaying}
            playerRef={playerRef}
            onBack={handleBack}
          />
        </motion.div>
      ) : (
        <Controls
          volume={volume}
          setVolume={setVolume}
          muted={muted}
          setMuted={setMuted}
          playing={playing}
          setPlaying={setPlaying}
          duration={duration}
          played={played}
          onSeek={(time) => playerRef.current?.seekTo(time)}
          title={title || "Unknown Title"}
          artist={artist || "Unknown Artist"}
          img={img}
          onNext={onNext}
          onPrevious={handlePrevious}
          onPlayPause={onPlayPause}
          setIsPlaying={setIsPlaying}
          playerRef={playerRef}
          onExpand={() => setIsExpanded(!isExpanded)}
        />
      )}
    </>
  );
};

const ExpandedPlayerControls = ({
  volume,
  setVolume,
  muted,
  setMuted,
  playing,
  setPlaying,
  duration,
  played,
  onSeek,
  title,
  artist,
  img,
  onNext,
  onPrevious,
  onPlayPause,
  setIsPlaying,
  playerRef,
  onBack, // Add onBack prop to handle closing the expanded view
}: {
  volume: number;
  setVolume: (volume: number) => void;
  muted: boolean;
  setMuted: (muted: boolean) => void;
  playing: boolean;
  setPlaying: (playing: boolean) => void;
  duration: number;
  played: number;
  onSeek: (time: number) => void;
  title: string;
  artist: string;
  img?: string;
  onNext?: () => void;
  onPrevious?: () => void;
  onPlayPause?: (playing: boolean) => void;
  setIsPlaying?: (isPlaying: boolean) => void;
  playerRef: React.RefObject<ReactPlayer>;
  onBack: () => void; // Add this prop to trigger the close action
}) => {
  const [localPlayed, setLocalPlayed] = useState(played * duration);
  const [showLyrics, setShowLyrics] = useState(false);
  const [previousVolume, setPreviousVolume] = useState(volume);
  const { theme } = useTheme();

  // Load current volume to slider visual on first load
  useEffect(() => {
    document.documentElement.style.setProperty(
      "--volume-value",
      `${volume * 100}%`
    );
  }, [volume]);

  useEffect(() => {
    const percentagePlayed = played * 100;
    document.documentElement.style.setProperty(
      "--seek-value",
      `${percentagePlayed}%`
    );
    setLocalPlayed(played * duration);
  }, [played, duration]);

  useEffect(() => {
    window.scrollTo(0, 0);
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = ""; // Re-enable scrolling when unmounted
    };
  }, []);

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setMuted(false);
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    document.documentElement.style.setProperty(
      "--volume-value",
      `${newVolume * 100}%`
    );
  };

  const handleMute = () => {
    if (muted) {
      setMuted(false);
      setVolume(previousVolume);
    } else {
      setPreviousVolume(volume);
      setMuted(true);
      setVolume(0);
    }
  };

  const handlePlayPause = () => {
    const newPlayingState = !playing;
    setPlaying(newPlayingState);

    if (setIsPlaying) {
      setIsPlaying(newPlayingState); // Update the global isPlaying state
    }

    if (onPlayPause) {
      onPlayPause(newPlayingState);
    }
  };

  const handleSeekChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const time = parseFloat(e.target.value);
    setLocalPlayed(time);
  };

  const handleSeekMouseUp = (
    e: React.MouseEvent<HTMLInputElement> | React.TouchEvent<HTMLInputElement>
  ) => {
    const time = parseFloat((e.target as HTMLInputElement).value);
    onSeek(time);
  };

  const formatTime = (seconds: number) => {
    const date = new Date(seconds * 1000);
    const hh = date.getUTCHours();
    const mm = date.getUTCMinutes();
    const ss = date.getUTCSeconds().toString().padStart(2, "0");
    if (hh) {
      return `${hh}:${mm.toString().padStart(2, "0")}:${ss}`;
    }
    return `${mm}:${ss}`;
  };

  const toggleLyrics = () => {
    setShowLyrics(!showLyrics);
  };

  const useDisplayMode = () => {
    const [isStandalone, setIsStandalone] = useState(false);

    useEffect(() => {
      // Check if the app is running in standalone mode
      const mediaQuery = window.matchMedia("(display-mode: standalone)");
      setIsStandalone(mediaQuery.matches);

      // Listen for changes in display mode
      const handleChange = (e: MediaQueryListEvent) =>
        setIsStandalone(e.matches);
      mediaQuery.addListener(handleChange);

      return () => mediaQuery.removeListener(handleChange);
    }, []);

    return isStandalone;
  };

  const isStandalone = useDisplayMode();

  const coverVariants = {
    open: { scale: 1.5, x: "40vw", y: "-10vh", transition: { duration: 0.3 } },
    closed: { scale: 1, x: "40vw", y: 0, transition: { duration: 0.3 } },
  };

  return (
    <div className="overlay bg-black">
      <AnimatePresence>
        <div className="overlay-close-container">
          <button onClick={onBack} className="overlay-close" />
        </div>
        <motion.div
          layout="position"
          className="mt-[2rem] w-full h-fit flex justify-between"
        >
          <CanvasBackground
            // animated
            // blur={isStandalone ? "100" : "200"}
            blur={3}
            src={img || ""}
            warpIntensity={120}
            brightness={playing ? 0.9 : 0.5}
          >
            <div className="px-5">
              <motion.div
                layout="position"
                layoutId="cover"
                // animate={!showLyrics ? { height: "450px" } : { height: "100px" }}
                transition={{ duration: 0.3, ease: "easeInOut" }}
                className={`flex text-white z-50 transition-all duration-300 w-full pointer-events-none ${
                  !showLyrics
                    ? "justify-center items-center h-[50vh] relative pt-20"
                    : "h-[50vh] absolute"
                }`}
              >
                <motion.div
                  onClick={() => showLyrics && toggleLyrics()}
                  layout="position"
                  className="pointer-events-auto max-w-[25rem] aspect-square shadow-sm"
                  transition={{ duration: 0.5, type: "spring" }}
                  animate={
                    !showLyrics
                      ? {
                          width: "75vw",
                          height: "auto",
                          scale: playing ? 1 : 0.9,
                        }
                      : {
                          width: "3.5rem",
                          height: "3.5rem",
                          scale: playing ? 1 : 1,
                        }
                  }
                >
                  <Image
                    layout="position"
                    className="rounded-lg w-full h-full object-cover"
                    src={
                      img ||
                      (theme === "light"
                        ? "/assets/placeholders/missing_song_light.png"
                        : "/assets/placeholders/missing_song_dark.png")
                    }
                    alt={title || ""}
                    width={336}
                    height={336}
                    draggable={false}
                    unoptimized={true}
                  />
                </motion.div>

                {showLyrics && (
                  <motion.div
                    initial={{ opacity: 0, y: 20, filter: "blur(10px)" }}
                    animate={{ opacity: 1, y: 0, filter: "blur(0px)" }}
                    exit={{ opacity: 0, y: 20, filter: "blur(10px)" }}
                    transition={{ duration: 0.5, type: "spring" }}
                    layout="position"
                  >
                    <span className="font-semibold text-white/90">
                      <TitleOverflowAnimator>{title}</TitleOverflowAnimator>
                    </span>
                    <p className="pl-2.5 text-white/50 text-sm">{artist}</p>
                  </motion.div>
                )}
              </motion.div>
              <div
                className={`w-full ${
                  showLyrics
                    ? "h-[7.5vh] max-sm:h-[5vh]"
                    : "h-[15vh] max-sm:h-[10vh]"
                }`}
              />

              {showLyrics && (
                <div className="h-[55vh]">
                  {/* <AnimatedRichSyncLyrics
                    hasRichSync={true}
                    songTitle={title}
                    artistName={artist}
                    onSeek={(time) => playerRef.current?.seekTo(time)}
                    delay={1}
                    localPlayed={localPlayed}
                    duration={duration}
                  /> */}
                  <LyricsView
                    time={localPlayed}
                    artistName={artist}
                    songTitle={title}
                    duration={duration}
                    playing={playing}
                    seekTo={(time: number) => playerRef.current?.seekTo(time)}
                  />
                </div>
              )}

              <motion.div
                transition={{ duration: 0.5 }}
                layout="position"
                id="controls"
                className={`${
                  showLyrics
                    ? "pt-[3.75rem] max-sm:translate-y-10"
                    : "pt-[0rem]"
                }`}
              >
                <div className="w-full">
                  {!showLyrics && (
                    <motion.div
                      initial={{ opacity: 0, y: -25, filter: "blur(10px)" }}
                      animate={{ opacity: 1, y: 0, filter: "blur(0px)" }}
                      exit={{ opacity: 0, y: -25, filter: "blur(10px)" }}
                      transition={{ duration: 0.5, type: "spring" }}
                      layout="position"
                      className="pb-4"
                    >
                      <span className="right-[0.625rem] relative font-semibold text-white/90">
                        <TitleOverflowAnimator className="!w-[90vw]">
                          {title}
                        </TitleOverflowAnimator>
                      </span>
                      <p className="text-white/50 text-sm">{artist}</p>
                    </motion.div>
                  )}
                  <div className="items-center flex w-full pb-1">
                    <motion.input
                      whileHover={{ scaleY: 1.5 }}
                      whileTap={{ scaleY: 0.995 }}
                      className="apple-slider seek-slider"
                      type="range"
                      min={0}
                      max={duration}
                      step="any"
                      value={localPlayed}
                      onChange={handleSeekChange}
                      onMouseUp={handleSeekMouseUp}
                      onTouchEnd={handleSeekMouseUp}
                    />
                  </div>
                  <div className="w-full justify-between flex text-white/50">
                    <span>{formatTime(localPlayed)}</span>
                    <span>{formatTime(duration)}</span>
                  </div>
                </div>
                <div className="flex items-center w-full justify-center text-white">
                  <motion.button
                    whileHover={{
                      backgroundColor: "rgba(255, 255, 255, 0.05)",
                    }}
                    whileTap={{
                      scale: 0.85,
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    }}
                    transition={{ duration: 0.1, ease: "easeInOut" }}
                    onClick={onPrevious}
                    className="flex flex-col items-center rounded-full p-2"
                  >
                    <IoPlayBack size={40} />
                  </motion.button>
                  <motion.button
                    whileHover={{
                      backgroundColor: "rgba(255, 255, 255, 0.05)",
                    }}
                    onClick={handlePlayPause}
                    whileTap={{
                      scale: 0.85,
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    }}
                    transition={{ duration: 0.1, ease: "easeInOut" }}
                    className="flex flex-col items-center rounded-full p-2"
                  >
                    {playing ? <IoPause size={40} /> : <IoPlay size={40} />}
                  </motion.button>
                  <motion.button
                    whileHover={{
                      backgroundColor: "rgba(255, 255, 255, 0.05)",
                    }}
                    whileTap={{
                      scale: 0.85,
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    }}
                    transition={{ duration: 0.1, ease: "easeInOut" }}
                    onClick={onNext}
                    className="flex flex-col items-center rounded-full p-2"
                  >
                    <IoPlayForward size={40} />
                  </motion.button>
                </div>
                {!isStandalone && (
                  <div className="flex items-center gap-2 w-full text-white">
                    <motion.button
                      whileTap={{ scale: 0.85 }}
                      transition={{ duration: 0.1, ease: "easeInOut" }}
                      onClick={handleMute}
                    >
                      {muted ? (
                        <IoVolumeMute size={30} />
                      ) : (
                        <IoVolumeMedium size={30} />
                      )}
                    </motion.button>
                    <motion.input
                      whileHover={{ scaleY: 1.5 }}
                      whileTap={{ scaleY: 0.995 }}
                      className="apple-slider volume-slider"
                      type="range"
                      min={0}
                      max={1}
                      step="any"
                      value={volume}
                      onChange={handleVolumeChange}
                    />
                  </div>
                )}
                <div className="w-full flex justify-between py-2 h-10">
                  <motion.button
                    onClick={toggleLyrics}
                    whileTap={{ scale: 0.85 }}
                    transition={{ duration: 0.1, ease: "easeInOut" }}
                  >
                    <LyricIcon
                      className={`transition-all duration-300 ${
                        showLyrics
                          ? "fill-white/75 text-white/75 stroke-white/75"
                          : "fill-white/10 text-white/10 stroke-white/10"
                      }`}
                    />
                  </motion.button>
                  <motion.button
                    onClick={onBack}
                    whileTap={{ scale: 0.85 }}
                    transition={{ duration: 0.1, ease: "easeInOut" }}
                  >
                    <XMark className="fill-white/10 text-white/10 stroke-white/10" />
                  </motion.button>
                </div>
              </motion.div>
            </div>
          </CanvasBackground>
        </motion.div>
      </AnimatePresence>
    </div>
  );
};

export const Controls = ({
  volume,
  setVolume,
  muted,
  setMuted,
  playing,
  setPlaying,
  duration,
  played,
  onSeek,
  title,
  artist,
  img,
  onNext,
  onPrevious,
  onPlayPause,
  setIsPlaying,
  playerRef,
  onExpand,
}: {
  volume: number;
  setVolume: (volume: number) => void;
  muted: boolean;
  setMuted: (muted: boolean) => void;
  playing: boolean;
  setPlaying: (playing: boolean) => void;
  duration: number;
  played: number;
  onSeek: (time: number) => void;
  title: string;
  artist: string;
  img?: string;
  onNext?: () => void;
  onPrevious?: () => void;
  onPlayPause?: (playing: boolean) => void;
  setIsPlaying?: (isPlaying: boolean) => void; // Add this prop to update the global state
  playerRef: React.RefObject<ReactPlayer>;
  onExpand: () => void;
}) => {
  const handlePlayPause = () => {
    const newPlayingState = !playing;
    setPlaying(newPlayingState);

    if (setIsPlaying) {
      setIsPlaying(newPlayingState); // Update the global isPlaying state
    }

    if (onPlayPause) {
      onPlayPause(newPlayingState);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center">
      <div className="navbar-mobile-container">
        <NavbarMiniControls
          img={img || ""}
          title={title}
          playing={playing}
          play={handlePlayPause}
          onNext={onNext}
          onExpand={onExpand}
        />
      </div>
    </div>
  );
};

export const NavbarMiniControls = ({
  img,
  title,
  playing,
  play,
  onNext,
  onExpand,
}: {
  img: string;
  title?: string;
  playing?: boolean;
  play?: () => void;
  onNext?: () => void;
  onExpand?: () => void;
}) => {
  const { theme } = useTheme();
  return (
    <div>
      <div className="navbar-mini-container">
        <div className="w-full h-fit mini-control backdrop-blur-lg p-2 rounded-[14px] flex justify-between bg-background/20 dark:bg-card/75">
          <div onClick={onExpand} className="flex items-center w-full">
            <Image
              className="size-11 rounded-lg"
              src={
                img ||
                (theme === "light"
                  ? "/assets/placeholders/missing_song_light.png"
                  : "/assets/placeholders/missing_song_dark.png")
              }
              alt={title || "Missing Image"}
              width={200}
              height={200}
              unoptimized={true}
              draggable={false}
            />
            <TitleOverflowAnimator>{title}</TitleOverflowAnimator>
          </div>
          <div className="flex items-center pr-2 gap-2">
            <motion.button
              whileHover={{ backgroundColor: "rgba(255, 255, 255, 0.05)" }}
              whileTap={{
                scale: 0.85,
                backgroundColor: "rgba(255, 255, 255, 0.1)",
              }}
              transition={{ duration: 0.125, ease: "easeInOut" }}
              onClick={play}
              className="flex flex-col items-center rounded-full p-2"
            >
              {playing ? <FaPause size={26} /> : <IoPlay size={26} />}
            </motion.button>
            <motion.button
              whileHover={{ backgroundColor: "rgba(255, 255, 255, 0.05)" }}
              whileTap={{
                scale: 0.85,
                backgroundColor: "rgba(255, 255, 255, 0.1)",
              }}
              transition={{ duration: 0.125, ease: "easeInOut" }}
              onClick={onNext}
              className="flex flex-col items-center rounded-full p-2"
            >
              <IoPlayForward size={26} />
            </motion.button>
          </div>
        </div>
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\AudioPlayerNew.tsx
"use client";
import React, { useEffect, useRef, useState } from "react";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import ReactPlayer from "react-player";
import { Controls } from "./controls/Controls";
import { SoundCloudKit } from "@/lib/audio/fetchers";

export const AudioPlayerNew = () => {
  const {
    currentSong,
    isPlaying,
    nextSong,
    previousSong,
    setQueue,
    queue,
    duration,
    setPlayerRef,
    setIsPlaying,
    volume,
  } = useAudioStoreNew();
  const playerRef = useRef<ReactPlayer>(null);

  useEffect(() => {
    console.log("AudioStateNew | state:", queue);
  }, [setQueue, currentSong, queue]);

  useEffect(() => {
    // Set the player ref inside the store
    setPlayerRef(playerRef);
  }, [setPlayerRef]);

  useEffect(() => {
    if ("mediaSession" in navigator) {
      const isIPhone = /iPhone/i.test(navigator.userAgent);
      const displayTitle =
        isIPhone && currentSong?.explicit
          ? `${currentSong?.name} 🅴`
          : currentSong?.name;
      navigator.mediaSession.metadata = new MediaMetadata({
        title: displayTitle || "Unknown Title",
        artist: currentSong?.artist.name || "Unknown Artist",
        album: currentSong?.albumName || "",
        artwork: [
          {
            src: SoundCloudKit.getHD(
              currentSong?.artwork?.url || "default-image.jpg"
            ),
            sizes: "512x512",
            type: "image/png",
          },
        ],
      });

      navigator.mediaSession.setActionHandler("play", () => {
        setIsPlaying(true);
      });
      navigator.mediaSession.setActionHandler("pause", () => {
        setIsPlaying(false);
      });
      navigator.mediaSession.setActionHandler("nexttrack", () => {
        nextSong();
      });
      navigator.mediaSession.setActionHandler("previoustrack", () => {
        previousSong();
      });
      navigator.mediaSession.setActionHandler("seekto", (details) => {
        if (details.seekTime && playerRef.current) {
          playerRef.current.seekTo(details.seekTime, "seconds");
        }
      });
      const updatePositionState = () => {
        if (playerRef.current) {
          const internalPlayer = playerRef.current.getInternalPlayer();
          navigator.mediaSession.setPositionState({
            duration: duration,
            playbackRate: internalPlayer ? internalPlayer.playbackRate : 1,
            position: playerRef.current.getCurrentTime(),
          });
        }
      };
      const positionUpdateInterval = setInterval(updatePositionState, 1000);
      return () => {
        clearInterval(positionUpdateInterval);
      };
    }
  }, [currentSong, isPlaying, duration, nextSong, previousSong, setIsPlaying]);

  return (
    <>
      {/* <UrlInput onLoadUrl={(url) => handleLoadUrl(url)} /> */}
      <ReactPlayer
        ref={playerRef}
        url={currentSong?.src}
        playing={isPlaying}
        onEnded={nextSong}
        volume={volume}
        onProgress={({ playedSeconds }) =>
          useAudioStoreNew.getState().setCurrentTime(playedSeconds)
        }
        onDuration={(duration) =>
          useAudioStoreNew.getState().setDuration(duration)
        }
        width="0px"
        height="0px"
      />
      <Controls />
    </>
  );
};

interface UrlInputProps {
  onLoadUrl: (url: string) => void;
}

const UrlInput: React.FC<UrlInputProps> = ({ onLoadUrl }) => {
  const [testUrl, setTestUrl] = useState("");
  return (
    <div>
      <input
        type="text"
        value={testUrl}
        onChange={(e) => setTestUrl(e.target.value)}
        placeholder="Enter a SoundCloud URL"
      />
      <button onClick={() => onLoadUrl(testUrl)}>Load Track/Playlist</button>
      <p>https://soundcloud.com/lilyeat/gone-4-a-min</p>
      <p>https://soundcloud.com/selecta-775244148/5-osamason-only-azure</p>
      <p>https://soundcloud.com/octobersveryown/drake-champagne-poetry</p>
      <p>https://soundcloud.com/octobersveryown/drake-n-2-deep-feat-future</p>
      <p>https://soundcloud.com/jackboysofficial/out-west-feat-young-thug</p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\controls\components\CloseButton.tsx
import { XMark } from "@/components/Icons/XMark";
import styles from "./CloseButton.module.css";

export const CloseButton = ({ onClick }: { onClick: () => void }) => {
  return (
    <button
      aria-label="Close"
      role="button"
      className={styles.closeButton}
      onClick={onClick}
    >
      {/* CloseButton */}
      <XMark className={styles.xmark} height="100%" width="100%" />
    </button>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\controls\Controls.tsx
import { useAudioStoreNew } from "@/context/AudioContextNew";
import React, { useEffect, useMemo, useRef, useState } from "react";
import style from "./Controls.module.css";

import { IoPlay, IoPlayBack, IoPlayForward } from "react-icons/io5";
import { PiPauseFill } from "react-icons/pi";
import { Volume2, VolumeX } from "lucide-react";

import { motion, AnimatePresence, LayoutGroup } from "framer-motion";
import Image from "next/image";
import { useTheme } from "next-themes";
import { TitleOverflowAnimator } from "@/components/mobile/TitleOverflowAnimator";
import { Song } from "@/lib/audio/types";
import { useMediaQuery } from "@/hooks/useMediaQuery";
import { CloseButton } from "./components/CloseButton";
import dynamic from "next/dynamic";
import AnimatedCover from "@/components/AnimatedCover";
import { LyricIcon } from "@/components/Icons/LyricIcon";
import { Options } from "@/components/Icons/Options";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";
import { SoundCloudKit } from "@/lib/audio/fetchers";
// import { AppleLyrics } from "../lyrics/AppleLyrics";
// import { BackgroundRender } from "@applemusic-like-lyrics/react";

// Fix document not defined error
const AppleLyrics = dynamic(
  () => import("../lyrics/AppleLyrics").then((mod) => mod.AppleLyrics),
  {
    ssr: false,
  }
);
// Also fixing document not defined error
const BackgroundRender = dynamic(
  () =>
    import("@applemusic-like-lyrics/react").then((mod) => mod.BackgroundRender),
  {
    ssr: false,
  }
);

export const Controls: React.FC = () => {
  const { currentSong, isPlaying, nextSong, previousSong, setIsPlaying } =
    useAudioStoreNew();
  const [isExpanded, setIsExpanded] = useState(false);

  const handlePlayPause = () => {
    setIsPlaying(!isPlaying);
  };

  const handleExpand = () => {
    setIsExpanded(true);
  };

  const handleClose = () => {
    setIsExpanded(false);
  };

  return (
    <>
      <LayoutGroup>
        {/* Minimized Player */}
        {!isExpanded && (
          <div className={style.controlsContainer}>
            <div className={style.controls}>
              <MiniPlayer
                song={currentSong || undefined}
                playing={isPlaying}
                onPlayPause={handlePlayPause}
                onNext={nextSong}
                onExpand={handleExpand}
              />
            </div>
          </div>
        )}

        {/* Expanded Player */}
        <AnimatePresence>
          {isExpanded && (
            <ExpandedPlayer
              key="expanded"
              song={currentSong || undefined}
              isPlaying={isPlaying}
              onPlayPause={handlePlayPause}
              onNext={nextSong}
              onPrev={previousSong}
              onClose={handleClose}
            />
          )}
        </AnimatePresence>
      </LayoutGroup>
    </>
  );
};

export const playerImageProps = {
  initial: { filter: "blur(2px)" },
  animate: { filter: "blur(0px)" },
  exit: { filter: "blur(2px)" },
  layout: "position", // Ensures consistent layout animations
  transition: { ease: "easeInOut" },
};

interface MiniPlayerProps {
  song?: Song;
  playing: boolean;
  onPlayPause: () => void;
  onNext: () => void;
  onExpand: () => void;
}

const MiniPlayer = ({
  song,
  onPlayPause,
  playing,
  onNext,
  onExpand,
}: MiniPlayerProps) => {
  const { theme } = useTheme();

  return (
    <div className="fixed bottom-[5rem] left-0 right-0">
      <div className={style.miniPlayer}>
        <motion.div
          onClick={onExpand}
          layout
          className="flex items-center w-full cursor-pointer"
        >
          <motion.div
            layoutId="playerImage"
            layout="preserve-aspect"
            className="relative overflow-hidden origin-center size-11"
          >
            <Image
              className="size-11 rounded-lg"
              src={
                song?.artwork?.url ||
                (theme === "light"
                  ? "/assets/placeholders/missing_song_light.png"
                  : "/assets/placeholders/missing_song_dark.png")
              }
              alt={song?.name || "Missing Image"}
              width={200}
              height={200}
              unoptimized={true}
              draggable={false}
            />
          </motion.div>
          <motion.div>
            <TitleOverflowAnimator>{song?.name}</TitleOverflowAnimator>
          </motion.div>
        </motion.div>
        <ControlButtons
          onPlayPause={onPlayPause}
          playing={playing}
          onNext={onNext}
        />
      </div>
    </div>
  );
};

export const buttonMotionProps = {
  whileHover: { backgroundColor: "rgba(255, 255, 255, 0.05)" },
  whileTap: {
    scale: 0.85,
    backgroundColor: "rgba(255, 255, 255, 0.1)",
  },
  transition: { duration: 0.125, ease: "easeInOut" },
  className: "flex flex-col items-center rounded-full p-2",
};

interface ControlButtonsProps {
  playing: boolean;
  onPlayPause: () => void;
  onNext: () => void;
  onPrev?: () => void;
}

const ControlButtons = ({
  playing,
  onPlayPause,
  onNext,
}: ControlButtonsProps) => {
  return (
    <div className="flex items-center pr-2 gap-2">
      <motion.button {...buttonMotionProps} onClick={onPlayPause}>
        {playing ? <PiPauseFill size={26} /> : <IoPlay size={26} />}
      </motion.button>
      <motion.button {...buttonMotionProps} onClick={onNext}>
        <IoPlayForward size={26} />
      </motion.button>
    </div>
  );
};

export interface ExpandedPlayerProps {
  song?: Song;
  isPlaying: boolean;
  onPlayPause: () => void;
  onNext: () => void;
  onPrev: () => void;
  onClose: () => void;
}

const ExpandedPlayer = ({
  song,
  isPlaying,
  onPlayPause,
  onNext,
  onPrev,
  onClose,
}: ExpandedPlayerProps) => {
  const { theme } = useTheme();
  const isDesktop = useMediaQuery("(min-width: 955px)");
  const [lyricsVisible, setLyricsVisible] = useState(false);
  const toggleLyrics = () => setLyricsVisible(!lyricsVisible);

  const PLACEHOLDER_IMAGE = useThemedPlaceholder();
  const IMAGEHD = SoundCloudKit.getHD(song?.artwork?.url || "");

  const currentTime = useAudioStoreNew((state) => state.currentTime ?? 0);
  const duration = useAudioStoreNew((state) => state.duration ?? 0);
  const seek = useAudioStoreNew((state) => state.seek);

  const handleSeekChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTime = parseFloat(e.target.value);
    seek(newTime);
  };

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        onClose();
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [onClose]);

  const controlsBaseProps = {
    // layout: true,
    className:
      "fixed inset-0 flex flex-col bg-black text-white z-[110] standalone:pt-10",
    initial: { opacity: 0, filter: "blur(10px)" },
    animate: { opacity: 1, filter: "blur(0px)" },
    exit: { opacity: 0, filter: "blur(10px)" },
    transition: { duration: 0.3, ease: "easeInOut" },
  };

  if (!isDesktop)
    return (
      <motion.div {...controlsBaseProps}>
        <motion.div layout style={{ zIndex: 10 }}>
          Mobile view
          <motion.div>
            <CloseButton onClick={onClose} />
          </motion.div>
          {/* Cover Art */}
          <motion.div
            {...playerImageProps}
            layout="preserve-aspect"
            layoutId="playerImage"
            style={{ display: "flex", justifyContent: "center" }}
          >
            <motion.span>
              <AppleCover
                imageSize={250}
                isDesktop={isDesktop}
                song={song}
                isAnimated={Boolean(song?.artwork?.animatedURL)}
              />
            </motion.span>
          </motion.div>
          {/* Controls & Info */}
          <motion.div
            style={{
              display: "flex",
              flexDirection: "column",
              alignContent: "center",
            }}
          >
            {/* Info */}
            <motion.div>
              <motion.h2 className="text-lg font-semibold text-center">
                {song?.name}
              </motion.h2>
              <motion.h2 className="text-sm text-center text-white/75">
                {song?.artist.name}
              </motion.h2>
            </motion.div>
            {/* Controls */}
            <motion.div
              style={{
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <DurationSlider
                duration={duration}
                currentTime={currentTime}
                onChange={handleSeekChange}
              />
              <ExpandedPlayerControls
                onPlayPause={onPlayPause}
                playing={isPlaying}
                onNext={onNext}
                onPrev={onPrev}
              />
            </motion.div>
          </motion.div>
        </motion.div>
        {/* {lyricsVisible && (
          <motion.span
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="flex flex-col size-full items-center justify-center"
          >
            <AppleLyrics />
          </motion.span>
        )} */}
        <BackgroundRender
          fps={30}
          playing={isPlaying}
          style={{
            position: "fixed",
            width: "100%",
            height: "100%",
            inset: "0",
          }}
          album={song?.artwork.url}
          // albumIsVideo={false}
        />
      </motion.div>
    );

  return (
    <motion.div {...controlsBaseProps}>
      <motion.div className="flex justify-start z-20 absolute w-full">
        <CloseButton onClick={onClose} />
      </motion.div>
      <motion.div
        className={`${
          !isDesktop ? "flex-col" : ""
        } flex-1 flex items-center justify-center z-10`}
      >
        <motion.span
          layout="preserve-aspect"
          className={`${
            isDesktop
              ? "justify-center h-full flex-col items-center"
              : "flex-row h-fit px-4 items-start mt-16 mb-8 justify-start"
          } flex w-full`}
        >
          <motion.div
            // {...playerImageProps}
            layout="position"
            layoutId="playerImage"
            className="relative"
          >
            <Image
              className={`${
                isDesktop ? "rounded-[1rem]" : "rounded-[6px]"
              } blur-md opacity-25 translate-y-1`}
              src={IMAGEHD || PLACEHOLDER_IMAGE}
              alt={song?.name || "Missing Image"}
              width={400}
              height={400}
              quality={10}
              unoptimized={true}
              draggable={false}
            />
            <span className="absolute inset-0 flex items-center justify-center">
              <AppleCover
                isAnimated={Boolean(song?.artwork?.animatedURL)}
                isDesktop={isDesktop}
                song={song}
              />
            </span>
          </motion.div>
          <motion.div
            layout="position"
            className={`${
              isDesktop ? "w-[20rem] flex-col mt-3" : "w-full h-fit px-4 -mt-2"
            } flex justify-center items-center`}
          >
            <motion.div
              layout="position"
              layoutId="playerInfo"
              className={`${
                isDesktop
                  ? "w-full justify-center items-center"
                  : "min-w-[100px]"
              } flex flex-col`}
            >
              <motion.h2
                layout="position"
                layoutId="playerTitle"
                className={`${
                  isDesktop ? "text-lg text-center" : "text-sm "
                } font-semibold`}
              >
                {song?.name}
              </motion.h2>
              <motion.h2
                layout="position"
                layoutId="playerArtist"
                className={`${
                  isDesktop ? "text-sm text-center" : "text-xs"
                } text-white/75 cursor-pointer`}
                onClick={() => {
                  const artistUrl = `/artist/${song?.artist.id}/${song?.artist.id}`;
                  if (
                    window.location.pathname.includes(
                      song?.artist.id.toString() || ""
                    )
                  ) {
                    onClose();
                  } else {
                    window.location.href = artistUrl;
                  }
                }}
              >
                {song?.artist.name}
              </motion.h2>
            </motion.div>
            <motion.div
              layout="position"
              layoutId="playerControls"
              className={`${
                isDesktop ? "flex-col mt-4" : "mt-0 justify-between"
              } flex items-center w-full gap-2`}
            >
              {isDesktop && (
                <div className="flex w-full items-center gap-2">
                  <span className="text-xs text-white/75">
                    {formatTime(currentTime)}
                  </span>
                  <DurationSlider
                    duration={duration}
                    currentTime={currentTime}
                    onChange={handleSeekChange}
                  />
                  <span className="text-xs text-white/75">
                    {formatTime(duration)}
                  </span>
                </div>
              )}
              <div>
                <ExpandedPlayerControls
                  onPlayPause={onPlayPause}
                  playing={isPlaying}
                  onNext={onNext}
                  onPrev={onPrev}
                />
              </div>
              <div
                className={`${
                  isDesktop ? "w-full" : ""
                } flex items-center gap-2 justify-between`}
              >
                {isDesktop && (
                  <LyricButton active={lyricsVisible} onClick={toggleLyrics} />
                )}
                <OptionsButton onClick={toggleLyrics} />
              </div>
            </motion.div>
          </motion.div>
        </motion.span>
        {lyricsVisible && (
          <motion.span
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="flex flex-col size-full items-center justify-center"
          >
            <AppleLyrics />
          </motion.span>
        )}
      </motion.div>
      <BackgroundRender
        fps={30}
        playing={isPlaying}
        style={{
          position: "fixed",
          width: "100%",
          height: "100%",
          inset: "0",
        }}
        album={song?.artwork.url}
        // albumIsVideo={false}
      />
    </motion.div>
  );
};

/**
 * Formats the given time in seconds to a mm:ss format.
 */
export function formatTime(seconds: number): string {
  if (!seconds || isNaN(seconds)) return "0:00";
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60)
    .toString()
    .padStart(2, "0");
  return `${m}:${s}`;
}

export const ExpandedPlayerControls = ({
  playing,
  onPlayPause,
  onNext,
  onPrev,
}: ControlButtonsProps) => {
  const buttonMotionProps = {
    whileHover: { backgroundColor: "rgba(255, 255, 255, 0.05)" },
    whileTap: {
      scale: 0.85,
      backgroundColor: "rgba(255, 255, 255, 0.1)",
    },
    transition: { duration: 0.125, ease: "easeInOut" },
    className: "flex flex-col items-center rounded-full p-2",
  };

  return (
    <div className="flex items-center gap-2">
      <motion.button {...buttonMotionProps} onClick={onPrev}>
        <IoPlayBack size={32} />
      </motion.button>
      <motion.button {...buttonMotionProps} onClick={onPlayPause}>
        {playing ? <PiPauseFill size={32} /> : <IoPlay size={32} />}
      </motion.button>
      <motion.button {...buttonMotionProps} onClick={onNext}>
        <IoPlayForward size={32} />
      </motion.button>
    </div>
  );
};

export const AppleCover = ({
  isDesktop,
  song,
  isAnimated,
  imageSize = 400,
}: {
  isDesktop: boolean;
  song: Song | undefined;
  isAnimated: boolean;
  imageSize?: number;
}) => {
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();
  const IMAGEHD = SoundCloudKit.getHD(song?.artwork?.url || "");

  const squircleStyle = {
    width: imageSize,
    height: imageSize,
    clipPath:
      'path("M0.0,27.3 C0.0,12.26 12.26,0.0 27.3,0.0 L372.7,0.0 C387.74,0.0 400,12.26 400,27.3 L400,372.7 C400,387.74 387.74,400 372.7,400 L27.3,400 C12.26,400 0.0,387.74 0.0,372.7 Z")',
    overflow: "hidden",
  };

  if (isAnimated) {
    return (
      <div className="select-none" style={squircleStyle}>
        <AnimatedCover
          style={{
            width: imageSize,
            height: imageSize,
          }}
          url={song?.artwork?.animatedURL || ""}
        />
      </div>
    );
  }

  return (
    <div className="select-none" style={squircleStyle}>
      <Image
        className={isDesktop ? "" : ""}
        src={IMAGEHD || PLACEHOLDER_IMAGE}
        alt={song?.name || "Missing Image"}
        width={imageSize}
        height={imageSize}
        unoptimized={true}
        draggable={false}
      />
    </div>
  );
};

export const LyricButton = ({
  onClick,
  active,
}: {
  onClick: () => void;
  active: boolean;
}) => {
  const buttonMotionProps = {
    whileHover: { backgroundColor: "rgba(255, 255, 255, 0.125)" },
    whileTap: {
      scale: 0.9,
      backgroundColor: "rgba(255, 255, 255, 0.2)",
    },
    transition: {
      type: "spring",
      stiffness: 400,
      damping: 17,
    },
    className: "flex flex-col items-center rounded-full p-2",
  };
  return (
    <motion.button
      title="Lyrics"
      {...buttonMotionProps}
      onClick={onClick}
      style={{
        backgroundColor: active
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(255, 255, 255, 0.05)",
      }}
      className="flex items-center justify-center size-8 rounded-full"
    >
      <LyricIcon className="size-[20px] fill-white" />
    </motion.button>
  );
};

export const OptionsButton = ({ onClick }: { onClick: () => void }) => {
  const buttonMotionProps = {
    whileHover: { backgroundColor: "rgba(255, 255, 255, 0.125)" },
    whileTap: {
      scale: 0.9,
      backgroundColor: "rgba(255, 255, 255, 0.2)",
    },
    transition: {
      type: "spring",
      stiffness: 400,
      damping: 17,
    },
    className:
      "flex flex-col items-center rounded-full p-2 justify-center size-8",
  };
  return (
    <motion.button
      style={{
        backgroundColor: "rgba(255, 255, 255, 0.05)",
      }}
      title="Options"
      {...buttonMotionProps}
      onClick={onClick}
    >
      <Options className="size-[24px] fill-white" />
    </motion.button>
  );
};

export const DurationSlider = ({
  duration,
  currentTime,
  onChange,
}: {
  duration: number;
  currentTime: number;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}) => {
  const sliderRef = useRef<HTMLInputElement>(null);

  // Calculate seek percentage only when needed
  const seekPercentage = useMemo(() => {
    return (currentTime / (duration || 1)) * 100 || 0;
  }, [currentTime, duration]);

  // Update the slider position using transform instead of CSS variables
  useEffect(() => {
    if (sliderRef.current) {
      // Use requestAnimationFrame for smoother updates
      requestAnimationFrame(() => {
        if (sliderRef.current) {
          sliderRef.current.style.setProperty(
            "--seek-value",
            `${seekPercentage}%`
          );
        }
      });
    }
  }, [seekPercentage]);

  return (
    <div className="flex items-center gap-2 w-full">
      <motion.input
        ref={sliderRef}
        type="range"
        min={0}
        max={duration || 1}
        value={currentTime}
        onChange={onChange}
        whileHover={{ scaleY: 1.5 }}
        whileTap={{ scaleY: 0.995 }}
        className="apple-slider seek-slider"
      />
    </div>
  );
};

export const VolumeSlider = ({
  volume,
  onChange,
}: {
  volume: number;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}) => {
  const [isMuted, setIsMuted] = useState(false);
  const [previousVolume, setPreviousVolume] = useState(volume);

  // Convert decimal volume (0-1) to percentage for display
  const volumePercentage = volume * 100;

  // Set CSS variable for volume slider track styling
  useEffect(() => {
    document.documentElement.style.setProperty(
      "--volume-value",
      `${volumePercentage}%`
    );
  }, [volumePercentage]);

  const handleMute = () => {
    if (isMuted) {
      // Unmute: restore previous volume
      const newEvent = {
        target: {
          value: previousVolume.toString(),
        },
      } as React.ChangeEvent<HTMLInputElement>;
      onChange(newEvent);
      setIsMuted(false);
    } else {
      // Mute: save current volume and set to 0
      setPreviousVolume(volume);
      const newEvent = {
        target: {
          value: "0",
        },
      } as React.ChangeEvent<HTMLInputElement>;
      onChange(newEvent);
      setIsMuted(true);
    }
  };

  return (
    <div className="flex items-center gap-2 w-full">
      <motion.button
        title={isMuted ? "Unmute" : "Mute"}
        whileHover={{ backgroundColor: "rgba(255, 255, 255, 0.125)" }}
        whileTap={{ scale: 0.9, backgroundColor: "rgba(255, 255, 255, 0.2)" }}
        transition={{ duration: 0.125, ease: "easeInOut" }}
        onClick={handleMute}
        className="p-1.5 rounded-full bg-transparent"
      >
        {volume === 0 || isMuted ? (
          <VolumeX size={20} className="text-white/80" />
        ) : (
          <Volume2 size={20} className="text-white/80" />
        )}
      </motion.button>
      <motion.input
        whileHover={{ scaleY: 1.5 }}
        whileTap={{ scaleY: 0.995 }}
        className="apple-slider volume-slider"
        type="range"
        min={0}
        max={1}
        step="0.01"
        value={volume}
        onChange={onChange}
      />
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\AppleLyrics.tsx
import React, { useEffect, useRef, useState } from "react";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { LyricPlayer, LyricPlayerRef } from "@applemusic-like-lyrics/react";
import { LyricLine, parseTTML } from "./lrc/utils/TTMLparser";
import { AppleKit } from "@/lib/audio/fetchers";
import { GakuStorage } from "@/lib/utils/storage";
import { dev } from "@/lib/utils";
import { QueueView } from "./QueueView";
import { motion, AnimatePresence } from "framer-motion";

// SegmentControl component for switching views
const SegmentControl = ({ activeView, onChange }: { activeView: "lyrics" | "queue"; onChange: (view: "lyrics" | "queue") => void }) => {
  return (
    <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-10 bg-neutral-600/25 backdrop-blur-lg rounded-full p-1 flex opacity-0 group-hover:opacity-100 transition-opacity duration-300">
      <button
        onClick={() => onChange("lyrics")}
        className={`px-4 py-1 rounded-full text-sm font-medium transition-colors ${
          activeView === "lyrics"
            ? "bg-neutral-300/15 text-white"
            : "text-white/60 hover:text-white"
        }`}
      >
        Lyrics
      </button>
      <button
        onClick={() => onChange("queue")}
        className={`px-4 py-1 rounded-full text-sm font-medium transition-colors ${
          activeView === "queue"
            ? "bg-neutral-300/15 text-white"
            : "text-white/60 hover:text-white"
        }`}
      >
        Queue
      </button>
    </div>
  );
};

export const AppleLyrics = () => {
  const [lyricLines, setLyricLines] = useState<LyricLine[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [activeView, setActiveView] = useState<"lyrics" | "queue">("lyrics");
  const lyricPlayerRef = useRef<LyricPlayerRef>(null);
  const lastTimeRef = useRef<number>(-1);
  const { fineProgress, currentSong, isPlaying, seek } = useAudioStoreNew();

  useEffect(() => {
    const loadLyrics = async () => {
      setIsLoading(true);
      try {
        const data = GakuStorage.getData();
        const currentTime = Date.now();
        const song = data.songs?.find(
          (s) =>
            s.name === currentSong?.name &&
            s.artist === currentSong?.artist.name
        );

        if (song?.lyrics && song.expiresAt && song.expiresAt > currentTime) {
          setLyricLines(song.lyrics);
          setIsLoading(false);
          return;
        }

        const lyrics = await AppleKit.getLyrics(
          currentSong?.name || "",
          currentSong?.artist.name || "",
          true
        );
        const parsedLyrics = parseTTML(lyrics).lyricLines;
        setLyricLines(parsedLyrics);

        GakuStorage.updateData((data) => {
          const songIndex = data.songs.findIndex(
            (s) =>
              s.name === currentSong?.name &&
              s.artist === currentSong?.artist.name
          );
          if (songIndex >= 0) {
            data.songs[songIndex].lyrics = parsedLyrics;
            data.songs[songIndex].expiresAt = currentTime + 60 * 60 * 1000;
          } else {
            data.songs.push({
              name: currentSong?.name,
              artist: currentSong?.artist.name,
              lyrics: parsedLyrics,
              expiresAt: currentTime + 60 * 60 * 1000,
            });
          }
          return data;
        });
      } catch (error) {
        console.error("Failed to load lyrics:", error);
        setLyricLines([]);
      } finally {
        setIsLoading(false);
      }
    };
    loadLyrics();
  }, [currentSong?.artist.name, currentSong?.name]);

  useEffect(() => {
    if (lyricPlayerRef.current?.lyricPlayer) {
      if (lastTimeRef.current === -1) {
        lastTimeRef.current = Date.now();
      }
      const currentTime = Date.now();
      lyricPlayerRef.current.lyricPlayer.update(
        currentTime - lastTimeRef.current
      );
      lastTimeRef.current = currentTime;
      lyricPlayerRef.current.lyricPlayer.setCurrentTime(fineProgress * 1000);
    }
  }, [fineProgress]);

  const onLyricLineClick = (line: any) => {
    dev.log("onLyricLineClick | Clicked on line:", line);
    seek(line.line.lyricLine.startTime / 1000);
  };

  if (isLoading) {
    return (
      <div className="h-screen w-full flex items-center justify-center">
        <QueryText>Loading lyrics...</QueryText>
      </div>
    );
  }

  return (
    <div className="h-screen w-full flex flex-col relative group">
      <SegmentControl activeView={activeView} onChange={setActiveView} />
      
      <AnimatePresence mode="wait">
        {activeView === "lyrics" ? (
          <motion.div 
            key="lyrics-view"
            className="flex-1"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
          >
            {!lyricLines.length ? (
              <div className="h-screen w-full flex items-center justify-center">
                <QueryText>No lyrics</QueryText>
              </div>
            ) : (
              <LyricPlayer
                style={{
                  width: "100%",
                  height: "100%",
                  maxWidth: "100%",
                  maxHeight: "100%",
                  scale: 0.95,
                  mixBlendMode: "plus-lighter",
                  fontWeight: "bold",
                }}
                currentTime={fineProgress * 1000}
                alignAnchor="center"
                playing={isPlaying}
                lyricLines={lyricLines}
                onLyricLineClick={onLyricLineClick}
              />
            )}
          </motion.div>
        ) : (
          <motion.div 
            key="queue-view"
            className="flex-1"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
          >
            <QueueView />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

const QueryText = ({ children }: { children: React.ReactNode }) => {
  return <p className="opacity-50 select-none">{children}</p>;
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\data\__mock__.ts
export const lyrics = [
  "I am light as a feather and as stiff as a board",
  "I pay attention to things that most people ignore",
  "And I'm alright with the movies that make jokes 'bout senseless cruelty",
  "That's for sure",
  "And I am built like a mother and a total machine",
  "I feel for your every little issue, I know just what you mean",
  "And I make light of the darkness, I've got sun in my motherfuckin' pocket",
  "Best believe, yeah, you know me, I",
  "Forgive and I forget",
  "I know my age and I act like it",
  "Got what you can't resist",
  "I'm a perfect all-American",
  "I am light as a feather, I'm as fresh as the air",
  "Coca-Cola bottles that I only use to curl my hair",
  "I got class and integrity just like a goddamn Kennedy",
  "I swear, with love to spare, I",
  "Forgive and I forget",
  "I know my age and I act like it",
  "Got what you can't resist",
  "I'm a perfect all-American bitch",
  "With perfect all-American lips",
  "And perfect all-American hips",
  "I know my place, I know my place",
  "And this is it",
  "I don't get angry when I'm pissed",
  "I'm the eternal optimist",
  "I scream inside to deal with it",
  'Like, "Ah"',
  'Like, "Ah"',
  "(Oh my fucking god, yeah)",
  "All the time",
  "I'm grateful all the time",
  "I'm sexy and I'm kind",
  "I'm pretty when I cry",
  "Oh, all the time (the time)",
  "I'm grateful all the time (fucking time)",
  "I'm sexy and I'm kind",
  "I'm pretty when I cry",
];

export const ttml =
  '<tt xmlns="http://www.w3.org/ns/ttml" xmlns:itunes="http://music.apple.com/lyric-ttml-internal" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" itunes:timing="Word" xml:lang="en"><body dur="2:45.834"><div begin="6.430" end="26.481" itunes:songPart="Verse"><p begin="6.430" end="11.175" itunes:key="L1" ttm:agent="v1"><span begin="6.430" end="6.762">i</span> <span begin="6.762" end="7.130">am</span> <span begin="7.130" end="7.546">light</span> <span begin="7.546" end="7.730">as</span> <span begin="7.730" end="7.911">a</span> <span begin="7.911" end="8.330">feather,</span> <span begin="8.330" end="8.514">i\'m</span> <span begin="8.514" end="8.679">as</span> <span begin="8.679" end="8.895">stiff</span> <span begin="8.895" end="9.114">as</span> <span begin="9.114" end="9.247">a</span> <span begin="9.247" end="11.175">board</span></p><p begin="12.510" end="18.023" itunes:key="L2" ttm:agent="v1"><span begin="12.510" end="12.879">i</span> <span begin="12.879" end="13.079">pay</span> <span begin="13.079" end="13.663">attention</span> <span begin="13.663" end="13.863">to</span> <span begin="13.863" end="14.345">things</span> <span begin="14.345" end="14.479">that</span> <span begin="14.479" end="14.863">most</span> <span begin="14.863" end="15.161">people</span> <span begin="15.161" end="15.418">ign</span><span begin="15.418" end="18.023">ore</span></p><p begin="18.549" end="21.762" itunes:key="L3" ttm:agent="v1"><span begin="18.549" end="18.681">and</span> <span begin="18.681" end="18.996">i\'m</span> <span begin="18.996" end="19.897">alright</span> <span begin="19.897" end="20.081">with</span> <span begin="20.081" end="20.236">the</span> <span begin="20.236" end="21.018">movies</span> <span begin="21.018" end="21.301">that</span> <span begin="21.301" end="21.762">make</span></p><p begin="21.762" end="26.481" itunes:key="L4" ttm:agent="v1"><span begin="21.762" end="22.109">jokes</span> <span begin="22.109" end="22.458">\'bout</span> <span begin="22.458" end="23.258">senseless</span> <span begin="23.258" end="24.042">cruelty,</span> <span begin="24.042" end="24.455">that\'s</span> <span begin="24.455" end="24.788">for</span> <span begin="24.788" end="26.481">sure</span></p></div><div begin="27.751" end="51.975" itunes:songPart="Verse"><p begin="27.751" end="32.537" itunes:key="L5" ttm:agent="v1"><span begin="27.751" end="27.914">and</span> <span begin="27.914" end="28.295">i</span> <span begin="28.295" end="28.663">am</span> <span begin="28.663" end="29.079">built</span> <span begin="29.079" end="29.263">like</span> <span begin="29.263" end="29.428">a</span> <span begin="29.428" end="29.951">mother</span> <span begin="29.951" end="30.084">and</span> <span begin="30.084" end="30.258">a</span> <span begin="30.258" end="30.583">total</span> <span begin="30.583" end="30.852">mach</span><span begin="30.852" end="32.537">ine</span></p><p begin="33.884" end="39.452" itunes:key="L6" ttm:agent="v1"><span begin="33.884" end="34.103">i</span> <span begin="34.103" end="34.436">feel</span> <span begin="34.436" end="34.607">for</span> <span begin="34.607" end="34.753">your</span> <span begin="34.753" end="35.153">every</span> <span begin="35.153" end="35.535">little</span> <span begin="35.535" end="36.058">issue,</span> <span begin="36.058" end="36.253">i</span> <span begin="36.253" end="36.423">know</span> <span begin="36.423" end="36.618">just</span> <span begin="36.618" end="36.786">what</span> <span begin="36.786" end="36.951">you</span> <span begin="36.951" end="39.452">mean</span></p><p begin="40.133" end="42.638" itunes:key="L7" ttm:agent="v1"><span begin="40.133" end="40.352">and</span> <span begin="40.352" end="40.669">i</span> <span begin="40.669" end="41.034">make</span> <span begin="41.034" end="41.402">light</span> <span begin="41.402" end="41.586">of</span> <span begin="41.586" end="41.754">the</span> <span begin="41.754" end="42.638">darkness</span></p><p begin="42.638" end="47.929" itunes:key="L8" ttm:agent="v1"><span begin="42.638" end="42.971">i\'ve</span> <span begin="42.971" end="43.321">got</span> <span begin="43.321" end="43.673">sun</span> <span begin="43.673" end="44.073">coming</span> <span begin="44.073" end="44.230">out</span> <span begin="44.230" end="44.395">of</span> <span begin="44.395" end="44.806">my</span> <span begin="44.806" end="45.574">pockets,</span> <span begin="45.574" end="45.891">best</span> <span begin="45.891" end="47.929">believe</span></p><p begin="48.311" end="51.975" itunes:key="L9" ttm:agent="v1"><span begin="48.311" end="48.698">yeah,</span> <span begin="48.698" end="48.871">you</span> <span begin="48.871" end="49.399">know</span> <span begin="49.399" end="50.271">me,</span> <span begin="50.271" end="51.975">i</span></p></div><div begin="52.834" end="1:04.686" itunes:songPart="Chorus"><p begin="52.834" end="55.874" itunes:key="L10" ttm:agent="v1"><span begin="52.834" end="54.066">forgive</span> <span begin="54.066" end="54.365">and</span> <span begin="54.365" end="54.733">i</span> <span begin="54.733" end="55.874">forget</span></p><p begin="55.974" end="59.021" itunes:key="L11" ttm:agent="v1"><span begin="55.974" end="56.283">i</span> <span begin="56.283" end="56.617">know</span> <span begin="56.617" end="57.099">my</span> <span begin="57.099" end="57.483">age</span> <span begin="57.483" end="57.665">and</span> <span begin="57.665" end="57.841">i</span> <span begin="57.841" end="58.233">act</span> <span begin="58.233" end="58.633">like</span> <span begin="58.633" end="59.021">it</span></p><p begin="59.021" end="1:02.505" itunes:key="L12" ttm:agent="v1"><span begin="59.021" end="59.352">got</span> <span begin="59.352" end="1:00.133">what</span> <span begin="1:00.133" end="1:00.501">you</span> <span begin="1:00.501" end="1:00.850">can\'t</span> <span begin="1:00.850" end="1:02.505">resist</span></p><p begin="1:02.802" end="1:04.686" itunes:key="L13" ttm:agent="v1"><span begin="1:02.802" end="1:03.031">i\'m</span> <span begin="1:03.031" end="1:03.197">a</span> <span begin="1:03.197" end="1:03.683">perfect</span> <span begin="1:03.683" end="1:03.851">all-</span><span begin="1:03.851" end="1:04.686">american</span></p></div><div begin="1:04.786" end="1:29.363" itunes:songPart="Verse"><p begin="1:04.786" end="1:09.187" itunes:key="L14" ttm:agent="v1"><span begin="1:04.786" end="1:05.149">i</span> <span begin="1:05.149" end="1:05.533">am</span> <span begin="1:05.533" end="1:05.933">light</span> <span begin="1:05.933" end="1:06.133">as</span> <span begin="1:06.133" end="1:06.298">a</span> <span begin="1:06.298" end="1:06.666">feather,</span> <span begin="1:06.666" end="1:06.882">i\'m</span> <span begin="1:06.882" end="1:07.039">as</span> <span begin="1:07.039" end="1:07.338">fresh</span> <span begin="1:07.338" end="1:07.498">as</span> <span begin="1:07.498" end="1:07.738">the</span> <span begin="1:07.738" end="1:09.187">air</span></p><p begin="1:10.887" end="1:16.275" itunes:key="L15" ttm:agent="v1"><span begin="1:10.887" end="1:11.250">coca-</span><span begin="1:11.250" end="1:11.612">cola</span> <span begin="1:11.612" end="1:12.028">bottles</span> <span begin="1:12.028" end="1:12.186">that</span> <span begin="1:12.186" end="1:12.335">i</span> <span begin="1:12.335" end="1:12.730">only</span> <span begin="1:12.730" end="1:13.035">use</span> <span begin="1:13.035" end="1:13.221">to</span> <span begin="1:13.221" end="1:13.392">curl</span> <span begin="1:13.392" end="1:13.736">my</span> <span begin="1:13.736" end="1:16.275">hair</span></p><p begin="1:16.856" end="1:19.461" itunes:key="L16" ttm:agent="v1"><span begin="1:16.856" end="1:17.011">i</span> <span begin="1:17.011" end="1:17.357">got</span> <span begin="1:17.357" end="1:17.723">class</span> <span begin="1:17.723" end="1:18.107">and</span> <span begin="1:18.107" end="1:19.461">integrity</span></p><p begin="1:19.461" end="1:24.702" itunes:key="L17" ttm:agent="v1"><span begin="1:19.461" end="1:19.957">i\'m</span> <span begin="1:19.957" end="1:20.608">graceful</span> <span begin="1:20.608" end="1:21.288">as</span> <span begin="1:21.288" end="1:21.587">a</span> <span begin="1:21.587" end="1:22.555">kennedy,</span> <span begin="1:22.555" end="1:22.968">i</span> <span begin="1:22.968" end="1:24.702">swear</span></p><p begin="1:25.182" end="1:29.363" itunes:key="L18" ttm:agent="v1"><span begin="1:25.182" end="1:25.366">with</span> <span begin="1:25.366" end="1:25.750">love</span> <span begin="1:25.750" end="1:26.015">to</span> <span begin="1:26.015" end="1:28.528">spare,</span> <span begin="1:28.528" end="1:29.363">i</span></p></div><div begin="1:29.509" end="1:42.371" itunes:songPart="Chorus"><p begin="1:29.509" end="1:32.622" itunes:key="L19" ttm:agent="v1"><span begin="1:29.509" end="1:30.682">forgive</span> <span begin="1:30.682" end="1:31.082">and</span> <span begin="1:31.082" end="1:31.466">i</span> <span begin="1:31.466" end="1:32.622">forget</span></p><p begin="1:32.622" end="1:35.669" itunes:key="L20" ttm:agent="v1"><span begin="1:32.622" end="1:33.006">i</span> <span begin="1:33.006" end="1:33.441">know</span> <span begin="1:33.441" end="1:33.841">my</span> <span begin="1:33.841" end="1:34.222">age</span> <span begin="1:34.222" end="1:34.387">and</span> <span begin="1:34.387" end="1:34.545">i</span> <span begin="1:34.545" end="1:34.923">act</span> <span begin="1:34.923" end="1:35.323">like</span> <span begin="1:35.323" end="1:35.669">it</span></p><p begin="1:35.669" end="1:39.167" itunes:key="L21" ttm:agent="v1"><span begin="1:35.669" end="1:36.050">got</span> <span begin="1:36.050" end="1:36.832">what</span> <span begin="1:36.832" end="1:37.200">you</span> <span begin="1:37.200" end="1:37.584">can\'t</span> <span begin="1:37.584" end="1:39.167">resist</span></p><p begin="1:39.526" end="1:42.371" itunes:key="L22" ttm:agent="v1"><span begin="1:39.526" end="1:39.793">i\'m</span> <span begin="1:39.793" end="1:39.953">a</span> <span begin="1:39.953" end="1:40.364">perfect</span> <span begin="1:40.364" end="1:40.532">all-</span><span begin="1:40.532" end="1:41.353">american</span> <span begin="1:41.353" end="1:42.371">bitch</span></p></div><div begin="1:42.782" end="2:13.590" itunes:songPart="Bridge"><p begin="1:42.782" end="1:45.786" itunes:key="L23" ttm:agent="v1"><span begin="1:42.782" end="1:42.982">with</span> <span begin="1:42.982" end="1:43.315">perfect</span> <span begin="1:43.315" end="1:43.547">all-</span><span begin="1:43.547" end="1:44.798">american</span> <span begin="1:44.798" end="1:45.786">lips</span></p><p begin="1:45.878" end="1:48.576" itunes:key="L24" ttm:agent="v1"><span begin="1:45.878" end="1:46.091">and</span> <span begin="1:46.091" end="1:46.392">perfect</span> <span begin="1:46.392" end="1:46.624">all-</span><span begin="1:46.624" end="1:47.466">american</span> <span begin="1:47.509" end="1:48.576">hips</span></p><p begin="1:48.726" end="1:53.398" itunes:key="L25" ttm:agent="v1"><span begin="1:48.726" end="1:49.137">i</span> <span begin="1:49.137" end="1:49.505">know</span> <span begin="1:49.505" end="1:49.871">my</span> <span begin="1:49.871" end="1:50.327">place,</span> <span begin="1:50.439" end="1:50.623">i</span> <span begin="1:50.623" end="1:51.039">know</span> <span begin="1:51.039" end="1:51.380">my</span> <span begin="1:51.380" end="1:51.828">place</span> <span begin="1:51.964" end="1:52.132">and</span> <span begin="1:52.132" end="1:52.514">this</span> <span begin="1:52.514" end="1:52.866">is</span> <span begin="1:52.866" end="1:53.398">it</span></p><p begin="1:53.398" end="1:56.381" itunes:key="L26" ttm:agent="v1"><span begin="1:53.398" end="1:53.707">i</span> <span begin="1:53.707" end="1:54.024">don\'t</span> <span begin="1:54.024" end="1:54.424">get</span> <span begin="1:54.424" end="1:55.256">angry</span> <span begin="1:55.256" end="1:55.573">when</span> <span begin="1:55.573" end="1:55.939">i\'m</span> <span begin="1:55.939" end="1:56.381">pissed</span></p><p begin="1:56.481" end="1:59.391" itunes:key="L27" ttm:agent="v1"><span begin="1:56.481" end="1:56.746">i\'m</span> <span begin="1:56.746" end="1:57.098">the</span> <span begin="1:57.098" end="1:58.264">eternal</span> <span begin="1:58.264" end="1:59.391">optimist</span></p><p begin="1:59.491" end="2:05.457" itunes:key="L28" ttm:agent="v1"><span begin="1:59.491" end="1:59.840">i</span> <span begin="1:59.840" end="2:00.158">scream</span> <span begin="2:00.158" end="2:00.923">inside</span> <span begin="2:00.923" end="2:01.339">to</span> <span begin="2:01.339" end="2:01.707">deal</span> <span begin="2:01.707" end="2:02.091">with</span> <span begin="2:02.091" end="2:02.397">it</span> <span begin="2:02.397" end="2:02.753">like,</span> <span begin="2:02.753" end="2:05.457">"ah!"</span></p><p begin="2:05.509" end="2:13.590" itunes:key="L29" ttm:agent="v1"><span begin="2:05.509" end="2:05.935">like,</span> <span begin="2:05.935" end="2:13.590">"ah!"</span></p></div><div begin="2:18.165" end="2:42.661" itunes:songPart="Outro"><p begin="2:18.165" end="2:20.641" itunes:key="L30" ttm:agent="v1"><span begin="2:18.165" end="2:18.880">all</span> <span begin="2:18.880" end="2:19.666">the</span> <span begin="2:19.666" end="2:20.641">time</span></p><p begin="2:20.869" end="2:23.698" itunes:key="L31" ttm:agent="v1"><span begin="2:20.869" end="2:21.182">i\'m</span> <span begin="2:21.182" end="2:22.014">grateful</span> <span begin="2:22.014" end="2:22.382">all</span> <span begin="2:22.382" end="2:22.747">the</span> <span begin="2:22.747" end="2:23.698">time</span></p><p begin="2:23.899" end="2:26.837" itunes:key="L32" ttm:agent="v1"><span begin="2:23.899" end="2:24.219">i\'m</span> <span begin="2:24.219" end="2:25.051">sexy</span> <span begin="2:25.051" end="2:25.200">and</span> <span begin="2:25.200" end="2:25.752">i\'m</span> <span begin="2:25.752" end="2:26.837">kind</span></p><p begin="2:26.946" end="2:29.796" itunes:key="L33" ttm:agent="v1"><span begin="2:26.946" end="2:27.279">i\'m</span> <span begin="2:27.279" end="2:28.040">pretty</span> <span begin="2:28.040" end="2:28.263">when</span> <span begin="2:28.263" end="2:28.801">i</span> <span begin="2:28.801" end="2:29.796">cry</span></p><p begin="2:30.019" end="2:32.882" itunes:key="L34" ttm:agent="v1"><span begin="2:30.019" end="2:30.365">oh,</span> <span begin="2:30.365" end="2:31.115">all</span> <span begin="2:31.115" end="2:31.880">the</span> <span begin="2:31.880" end="2:32.882">time</span></p><p begin="2:33.083" end="2:36.572" itunes:key="L35" ttm:agent="v1"><span begin="2:33.083" end="2:33.411">i\'m</span> <span begin="2:33.411" end="2:34.227">grateful</span> <span begin="2:34.227" end="2:34.595">all</span> <span begin="2:34.595" end="2:34.944">the</span> <span begin="2:34.944" end="2:35.938">time</span> <span ttm:role="x-bg"><span begin="2:33.088" end="2:33.395">(i\'m</span> <span begin="2:33.395" end="2:34.179">grateful,</span> <span begin="2:34.179" end="2:34.963">grateful</span> <span begin="2:34.963" end="2:35.328">all</span> <span begin="2:35.328" end="2:35.512">the</span> <span begin="2:35.512" end="2:36.572">time)</span></span></p><p begin="2:36.123" end="2:38.972" itunes:key="L36" ttm:agent="v1"><span begin="2:36.123" end="2:36.367">i\'m</span> <span begin="2:36.367" end="2:37.285">sexy</span> <span begin="2:37.285" end="2:37.434">and</span> <span begin="2:37.434" end="2:37.967">i\'m</span> <span begin="2:37.967" end="2:38.972">kind</span></p><p begin="2:39.200" end="2:42.661" itunes:key="L37" ttm:agent="v1"><span begin="2:39.200" end="2:39.475">i\'m</span> <span begin="2:39.475" end="2:40.291">pretty</span> <span begin="2:40.291" end="2:40.491">when</span> <span begin="2:40.491" end="2:41.008">i</span> <span begin="2:41.008" end="2:42.661">cry</span></p></div></body></tt>';

export const parsedJson = {
  body: {
    "@xmlns": "http://www.w3.org/ns/ttml",
    "@dur": "2:45.834",
    div: [
      {
        "@begin": "6.430",
        "@end": "26.481",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Verse",
        p: [
          {
            "@begin": "6.430",
            "@end": "11.175",
            "@itunes:key": "L1",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "6.430",
                "@end": "6.762",
                "#text": "i",
              },
              {
                "@begin": "6.762",
                "@end": "7.130",
                "#text": "am",
              },
              {
                "@begin": "7.130",
                "@end": "7.546",
                "#text": "light",
              },
              {
                "@begin": "7.546",
                "@end": "7.730",
                "#text": "as",
              },
              {
                "@begin": "7.730",
                "@end": "7.911",
                "#text": "a",
              },
              {
                "@begin": "7.911",
                "@end": "8.330",
                "#text": "feather,",
              },
              {
                "@begin": "8.330",
                "@end": "8.514",
                "#text": "i'm",
              },
              {
                "@begin": "8.514",
                "@end": "8.679",
                "#text": "as",
              },
              {
                "@begin": "8.679",
                "@end": "8.895",
                "#text": "stiff",
              },
              {
                "@begin": "8.895",
                "@end": "9.114",
                "#text": "as",
              },
              {
                "@begin": "9.114",
                "@end": "9.247",
                "#text": "a",
              },
              {
                "@begin": "9.247",
                "@end": "11.175",
                "#text": "board",
              },
            ],
          },
          {
            "@begin": "12.510",
            "@end": "18.023",
            "@itunes:key": "L2",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "12.510",
                "@end": "12.879",
                "#text": "i",
              },
              {
                "@begin": "12.879",
                "@end": "13.079",
                "#text": "pay",
              },
              {
                "@begin": "13.079",
                "@end": "13.663",
                "#text": "attention",
              },
              {
                "@begin": "13.663",
                "@end": "13.863",
                "#text": "to",
              },
              {
                "@begin": "13.863",
                "@end": "14.345",
                "#text": "things",
              },
              {
                "@begin": "14.345",
                "@end": "14.479",
                "#text": "that",
              },
              {
                "@begin": "14.479",
                "@end": "14.863",
                "#text": "most",
              },
              {
                "@begin": "14.863",
                "@end": "15.161",
                "#text": "people",
              },
              {
                "@begin": "15.161",
                "@end": "15.418",
                "#text": "ign",
              },
              {
                "@begin": "15.418",
                "@end": "18.023",
                "#text": "ore",
              },
            ],
          },
          {
            "@begin": "18.549",
            "@end": "21.762",
            "@itunes:key": "L3",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "18.549",
                "@end": "18.681",
                "#text": "and",
              },
              {
                "@begin": "18.681",
                "@end": "18.996",
                "#text": "i'm",
              },
              {
                "@begin": "18.996",
                "@end": "19.897",
                "#text": "alright",
              },
              {
                "@begin": "19.897",
                "@end": "20.081",
                "#text": "with",
              },
              {
                "@begin": "20.081",
                "@end": "20.236",
                "#text": "the",
              },
              {
                "@begin": "20.236",
                "@end": "21.018",
                "#text": "movies",
              },
              {
                "@begin": "21.018",
                "@end": "21.301",
                "#text": "that",
              },
              {
                "@begin": "21.301",
                "@end": "21.762",
                "#text": "make",
              },
            ],
          },
          {
            "@begin": "21.762",
            "@end": "26.481",
            "@itunes:key": "L4",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "21.762",
                "@end": "22.109",
                "#text": "jokes",
              },
              {
                "@begin": "22.109",
                "@end": "22.458",
                "#text": "'bout",
              },
              {
                "@begin": "22.458",
                "@end": "23.258",
                "#text": "senseless",
              },
              {
                "@begin": "23.258",
                "@end": "24.042",
                "#text": "cruelty,",
              },
              {
                "@begin": "24.042",
                "@end": "24.455",
                "#text": "that's",
              },
              {
                "@begin": "24.455",
                "@end": "24.788",
                "#text": "for",
              },
              {
                "@begin": "24.788",
                "@end": "26.481",
                "#text": "sure",
              },
            ],
          },
        ],
      },
      {
        "@begin": "27.751",
        "@end": "51.975",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Verse",
        p: [
          {
            "@begin": "27.751",
            "@end": "32.537",
            "@itunes:key": "L5",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "27.751",
                "@end": "27.914",
                "#text": "and",
              },
              {
                "@begin": "27.914",
                "@end": "28.295",
                "#text": "i",
              },
              {
                "@begin": "28.295",
                "@end": "28.663",
                "#text": "am",
              },
              {
                "@begin": "28.663",
                "@end": "29.079",
                "#text": "built",
              },
              {
                "@begin": "29.079",
                "@end": "29.263",
                "#text": "like",
              },
              {
                "@begin": "29.263",
                "@end": "29.428",
                "#text": "a",
              },
              {
                "@begin": "29.428",
                "@end": "29.951",
                "#text": "mother",
              },
              {
                "@begin": "29.951",
                "@end": "30.084",
                "#text": "and",
              },
              {
                "@begin": "30.084",
                "@end": "30.258",
                "#text": "a",
              },
              {
                "@begin": "30.258",
                "@end": "30.583",
                "#text": "total",
              },
              {
                "@begin": "30.583",
                "@end": "30.852",
                "#text": "mach",
              },
              {
                "@begin": "30.852",
                "@end": "32.537",
                "#text": "ine",
              },
            ],
          },
          {
            "@begin": "33.884",
            "@end": "39.452",
            "@itunes:key": "L6",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "33.884",
                "@end": "34.103",
                "#text": "i",
              },
              {
                "@begin": "34.103",
                "@end": "34.436",
                "#text": "feel",
              },
              {
                "@begin": "34.436",
                "@end": "34.607",
                "#text": "for",
              },
              {
                "@begin": "34.607",
                "@end": "34.753",
                "#text": "your",
              },
              {
                "@begin": "34.753",
                "@end": "35.153",
                "#text": "every",
              },
              {
                "@begin": "35.153",
                "@end": "35.535",
                "#text": "little",
              },
              {
                "@begin": "35.535",
                "@end": "36.058",
                "#text": "issue,",
              },
              {
                "@begin": "36.058",
                "@end": "36.253",
                "#text": "i",
              },
              {
                "@begin": "36.253",
                "@end": "36.423",
                "#text": "know",
              },
              {
                "@begin": "36.423",
                "@end": "36.618",
                "#text": "just",
              },
              {
                "@begin": "36.618",
                "@end": "36.786",
                "#text": "what",
              },
              {
                "@begin": "36.786",
                "@end": "36.951",
                "#text": "you",
              },
              {
                "@begin": "36.951",
                "@end": "39.452",
                "#text": "mean",
              },
            ],
          },
          {
            "@begin": "40.133",
            "@end": "42.638",
            "@itunes:key": "L7",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "40.133",
                "@end": "40.352",
                "#text": "and",
              },
              {
                "@begin": "40.352",
                "@end": "40.669",
                "#text": "i",
              },
              {
                "@begin": "40.669",
                "@end": "41.034",
                "#text": "make",
              },
              {
                "@begin": "41.034",
                "@end": "41.402",
                "#text": "light",
              },
              {
                "@begin": "41.402",
                "@end": "41.586",
                "#text": "of",
              },
              {
                "@begin": "41.586",
                "@end": "41.754",
                "#text": "the",
              },
              {
                "@begin": "41.754",
                "@end": "42.638",
                "#text": "darkness",
              },
            ],
          },
          {
            "@begin": "42.638",
            "@end": "47.929",
            "@itunes:key": "L8",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "42.638",
                "@end": "42.971",
                "#text": "i've",
              },
              {
                "@begin": "42.971",
                "@end": "43.321",
                "#text": "got",
              },
              {
                "@begin": "43.321",
                "@end": "43.673",
                "#text": "sun",
              },
              {
                "@begin": "43.673",
                "@end": "44.073",
                "#text": "coming",
              },
              {
                "@begin": "44.073",
                "@end": "44.230",
                "#text": "out",
              },
              {
                "@begin": "44.230",
                "@end": "44.395",
                "#text": "of",
              },
              {
                "@begin": "44.395",
                "@end": "44.806",
                "#text": "my",
              },
              {
                "@begin": "44.806",
                "@end": "45.574",
                "#text": "pockets,",
              },
              {
                "@begin": "45.574",
                "@end": "45.891",
                "#text": "best",
              },
              {
                "@begin": "45.891",
                "@end": "47.929",
                "#text": "believe",
              },
            ],
          },
          {
            "@begin": "48.311",
            "@end": "51.975",
            "@itunes:key": "L9",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "48.311",
                "@end": "48.698",
                "#text": "yeah,",
              },
              {
                "@begin": "48.698",
                "@end": "48.871",
                "#text": "you",
              },
              {
                "@begin": "48.871",
                "@end": "49.399",
                "#text": "know",
              },
              {
                "@begin": "49.399",
                "@end": "50.271",
                "#text": "me,",
              },
              {
                "@begin": "50.271",
                "@end": "51.975",
                "#text": "i",
              },
            ],
          },
        ],
      },
      {
        "@begin": "52.834",
        "@end": "1:04.686",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Chorus",
        p: [
          {
            "@begin": "52.834",
            "@end": "55.874",
            "@itunes:key": "L10",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "52.834",
                "@end": "54.066",
                "#text": "forgive",
              },
              {
                "@begin": "54.066",
                "@end": "54.365",
                "#text": "and",
              },
              {
                "@begin": "54.365",
                "@end": "54.733",
                "#text": "i",
              },
              {
                "@begin": "54.733",
                "@end": "55.874",
                "#text": "forget",
              },
            ],
          },
          {
            "@begin": "55.974",
            "@end": "59.021",
            "@itunes:key": "L11",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "55.974",
                "@end": "56.283",
                "#text": "i",
              },
              {
                "@begin": "56.283",
                "@end": "56.617",
                "#text": "know",
              },
              {
                "@begin": "56.617",
                "@end": "57.099",
                "#text": "my",
              },
              {
                "@begin": "57.099",
                "@end": "57.483",
                "#text": "age",
              },
              {
                "@begin": "57.483",
                "@end": "57.665",
                "#text": "and",
              },
              {
                "@begin": "57.665",
                "@end": "57.841",
                "#text": "i",
              },
              {
                "@begin": "57.841",
                "@end": "58.233",
                "#text": "act",
              },
              {
                "@begin": "58.233",
                "@end": "58.633",
                "#text": "like",
              },
              {
                "@begin": "58.633",
                "@end": "59.021",
                "#text": "it",
              },
            ],
          },
          {
            "@begin": "59.021",
            "@end": "1:02.505",
            "@itunes:key": "L12",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "59.021",
                "@end": "59.352",
                "#text": "got",
              },
              {
                "@begin": "59.352",
                "@end": "1:00.133",
                "#text": "what",
              },
              {
                "@begin": "1:00.133",
                "@end": "1:00.501",
                "#text": "you",
              },
              {
                "@begin": "1:00.501",
                "@end": "1:00.850",
                "#text": "can't",
              },
              {
                "@begin": "1:00.850",
                "@end": "1:02.505",
                "#text": "resist",
              },
            ],
          },
          {
            "@begin": "1:02.802",
            "@end": "1:04.686",
            "@itunes:key": "L13",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:02.802",
                "@end": "1:03.031",
                "#text": "i'm",
              },
              {
                "@begin": "1:03.031",
                "@end": "1:03.197",
                "#text": "a",
              },
              {
                "@begin": "1:03.197",
                "@end": "1:03.683",
                "#text": "perfect",
              },
              {
                "@begin": "1:03.683",
                "@end": "1:03.851",
                "#text": "all-",
              },
              {
                "@begin": "1:03.851",
                "@end": "1:04.686",
                "#text": "american",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:04.786",
        "@end": "1:29.363",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Verse",
        p: [
          {
            "@begin": "1:04.786",
            "@end": "1:09.187",
            "@itunes:key": "L14",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:04.786",
                "@end": "1:05.149",
                "#text": "i",
              },
              {
                "@begin": "1:05.149",
                "@end": "1:05.533",
                "#text": "am",
              },
              {
                "@begin": "1:05.533",
                "@end": "1:05.933",
                "#text": "light",
              },
              {
                "@begin": "1:05.933",
                "@end": "1:06.133",
                "#text": "as",
              },
              {
                "@begin": "1:06.133",
                "@end": "1:06.298",
                "#text": "a",
              },
              {
                "@begin": "1:06.298",
                "@end": "1:06.666",
                "#text": "feather,",
              },
              {
                "@begin": "1:06.666",
                "@end": "1:06.882",
                "#text": "i'm",
              },
              {
                "@begin": "1:06.882",
                "@end": "1:07.039",
                "#text": "as",
              },
              {
                "@begin": "1:07.039",
                "@end": "1:07.338",
                "#text": "fresh",
              },
              {
                "@begin": "1:07.338",
                "@end": "1:07.498",
                "#text": "as",
              },
              {
                "@begin": "1:07.498",
                "@end": "1:07.738",
                "#text": "the",
              },
              {
                "@begin": "1:07.738",
                "@end": "1:09.187",
                "#text": "air",
              },
            ],
          },
          {
            "@begin": "1:10.887",
            "@end": "1:16.275",
            "@itunes:key": "L15",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:10.887",
                "@end": "1:11.250",
                "#text": "coca-",
              },
              {
                "@begin": "1:11.250",
                "@end": "1:11.612",
                "#text": "cola",
              },
              {
                "@begin": "1:11.612",
                "@end": "1:12.028",
                "#text": "bottles",
              },
              {
                "@begin": "1:12.028",
                "@end": "1:12.186",
                "#text": "that",
              },
              {
                "@begin": "1:12.186",
                "@end": "1:12.335",
                "#text": "i",
              },
              {
                "@begin": "1:12.335",
                "@end": "1:12.730",
                "#text": "only",
              },
              {
                "@begin": "1:12.730",
                "@end": "1:13.035",
                "#text": "use",
              },
              {
                "@begin": "1:13.035",
                "@end": "1:13.221",
                "#text": "to",
              },
              {
                "@begin": "1:13.221",
                "@end": "1:13.392",
                "#text": "curl",
              },
              {
                "@begin": "1:13.392",
                "@end": "1:13.736",
                "#text": "my",
              },
              {
                "@begin": "1:13.736",
                "@end": "1:16.275",
                "#text": "hair",
              },
            ],
          },
          {
            "@begin": "1:16.856",
            "@end": "1:19.461",
            "@itunes:key": "L16",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:16.856",
                "@end": "1:17.011",
                "#text": "i",
              },
              {
                "@begin": "1:17.011",
                "@end": "1:17.357",
                "#text": "got",
              },
              {
                "@begin": "1:17.357",
                "@end": "1:17.723",
                "#text": "class",
              },
              {
                "@begin": "1:17.723",
                "@end": "1:18.107",
                "#text": "and",
              },
              {
                "@begin": "1:18.107",
                "@end": "1:19.461",
                "#text": "integrity",
              },
            ],
          },
          {
            "@begin": "1:19.461",
            "@end": "1:24.702",
            "@itunes:key": "L17",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:19.461",
                "@end": "1:19.957",
                "#text": "i'm",
              },
              {
                "@begin": "1:19.957",
                "@end": "1:20.608",
                "#text": "graceful",
              },
              {
                "@begin": "1:20.608",
                "@end": "1:21.288",
                "#text": "as",
              },
              {
                "@begin": "1:21.288",
                "@end": "1:21.587",
                "#text": "a",
              },
              {
                "@begin": "1:21.587",
                "@end": "1:22.555",
                "#text": "kennedy,",
              },
              {
                "@begin": "1:22.555",
                "@end": "1:22.968",
                "#text": "i",
              },
              {
                "@begin": "1:22.968",
                "@end": "1:24.702",
                "#text": "swear",
              },
            ],
          },
          {
            "@begin": "1:25.182",
            "@end": "1:29.363",
            "@itunes:key": "L18",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:25.182",
                "@end": "1:25.366",
                "#text": "with",
              },
              {
                "@begin": "1:25.366",
                "@end": "1:25.750",
                "#text": "love",
              },
              {
                "@begin": "1:25.750",
                "@end": "1:26.015",
                "#text": "to",
              },
              {
                "@begin": "1:26.015",
                "@end": "1:28.528",
                "#text": "spare,",
              },
              {
                "@begin": "1:28.528",
                "@end": "1:29.363",
                "#text": "i",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:29.509",
        "@end": "1:42.371",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Chorus",
        p: [
          {
            "@begin": "1:29.509",
            "@end": "1:32.622",
            "@itunes:key": "L19",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:29.509",
                "@end": "1:30.682",
                "#text": "forgive",
              },
              {
                "@begin": "1:30.682",
                "@end": "1:31.082",
                "#text": "and",
              },
              {
                "@begin": "1:31.082",
                "@end": "1:31.466",
                "#text": "i",
              },
              {
                "@begin": "1:31.466",
                "@end": "1:32.622",
                "#text": "forget",
              },
            ],
          },
          {
            "@begin": "1:32.622",
            "@end": "1:35.669",
            "@itunes:key": "L20",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:32.622",
                "@end": "1:33.006",
                "#text": "i",
              },
              {
                "@begin": "1:33.006",
                "@end": "1:33.441",
                "#text": "know",
              },
              {
                "@begin": "1:33.441",
                "@end": "1:33.841",
                "#text": "my",
              },
              {
                "@begin": "1:33.841",
                "@end": "1:34.222",
                "#text": "age",
              },
              {
                "@begin": "1:34.222",
                "@end": "1:34.387",
                "#text": "and",
              },
              {
                "@begin": "1:34.387",
                "@end": "1:34.545",
                "#text": "i",
              },
              {
                "@begin": "1:34.545",
                "@end": "1:34.923",
                "#text": "act",
              },
              {
                "@begin": "1:34.923",
                "@end": "1:35.323",
                "#text": "like",
              },
              {
                "@begin": "1:35.323",
                "@end": "1:35.669",
                "#text": "it",
              },
            ],
          },
          {
            "@begin": "1:35.669",
            "@end": "1:39.167",
            "@itunes:key": "L21",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:35.669",
                "@end": "1:36.050",
                "#text": "got",
              },
              {
                "@begin": "1:36.050",
                "@end": "1:36.832",
                "#text": "what",
              },
              {
                "@begin": "1:36.832",
                "@end": "1:37.200",
                "#text": "you",
              },
              {
                "@begin": "1:37.200",
                "@end": "1:37.584",
                "#text": "can't",
              },
              {
                "@begin": "1:37.584",
                "@end": "1:39.167",
                "#text": "resist",
              },
            ],
          },
          {
            "@begin": "1:39.526",
            "@end": "1:42.371",
            "@itunes:key": "L22",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:39.526",
                "@end": "1:39.793",
                "#text": "i'm",
              },
              {
                "@begin": "1:39.793",
                "@end": "1:39.953",
                "#text": "a",
              },
              {
                "@begin": "1:39.953",
                "@end": "1:40.364",
                "#text": "perfect",
              },
              {
                "@begin": "1:40.364",
                "@end": "1:40.532",
                "#text": "all-",
              },
              {
                "@begin": "1:40.532",
                "@end": "1:41.353",
                "#text": "american",
              },
              {
                "@begin": "1:41.353",
                "@end": "1:42.371",
                "#text": "bitch",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:42.782",
        "@end": "2:13.590",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Bridge",
        p: [
          {
            "@begin": "1:42.782",
            "@end": "1:45.786",
            "@itunes:key": "L23",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:42.782",
                "@end": "1:42.982",
                "#text": "with",
              },
              {
                "@begin": "1:42.982",
                "@end": "1:43.315",
                "#text": "perfect",
              },
              {
                "@begin": "1:43.315",
                "@end": "1:43.547",
                "#text": "all-",
              },
              {
                "@begin": "1:43.547",
                "@end": "1:44.798",
                "#text": "american",
              },
              {
                "@begin": "1:44.798",
                "@end": "1:45.786",
                "#text": "lips",
              },
            ],
          },
          {
            "@begin": "1:45.878",
            "@end": "1:48.576",
            "@itunes:key": "L24",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:45.878",
                "@end": "1:46.091",
                "#text": "and",
              },
              {
                "@begin": "1:46.091",
                "@end": "1:46.392",
                "#text": "perfect",
              },
              {
                "@begin": "1:46.392",
                "@end": "1:46.624",
                "#text": "all-",
              },
              {
                "@begin": "1:46.624",
                "@end": "1:47.466",
                "#text": "american",
              },
              {
                "@begin": "1:47.509",
                "@end": "1:48.576",
                "#text": "hips",
              },
            ],
          },
          {
            "@begin": "1:48.726",
            "@end": "1:53.398",
            "@itunes:key": "L25",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:48.726",
                "@end": "1:49.137",
                "#text": "i",
              },
              {
                "@begin": "1:49.137",
                "@end": "1:49.505",
                "#text": "know",
              },
              {
                "@begin": "1:49.505",
                "@end": "1:49.871",
                "#text": "my",
              },
              {
                "@begin": "1:49.871",
                "@end": "1:50.327",
                "#text": "place,",
              },
              {
                "@begin": "1:50.439",
                "@end": "1:50.623",
                "#text": "i",
              },
              {
                "@begin": "1:50.623",
                "@end": "1:51.039",
                "#text": "know",
              },
              {
                "@begin": "1:51.039",
                "@end": "1:51.380",
                "#text": "my",
              },
              {
                "@begin": "1:51.380",
                "@end": "1:51.828",
                "#text": "place",
              },
              {
                "@begin": "1:51.964",
                "@end": "1:52.132",
                "#text": "and",
              },
              {
                "@begin": "1:52.132",
                "@end": "1:52.514",
                "#text": "this",
              },
              {
                "@begin": "1:52.514",
                "@end": "1:52.866",
                "#text": "is",
              },
              {
                "@begin": "1:52.866",
                "@end": "1:53.398",
                "#text": "it",
              },
            ],
          },
          {
            "@begin": "1:53.398",
            "@end": "1:56.381",
            "@itunes:key": "L26",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:53.398",
                "@end": "1:53.707",
                "#text": "i",
              },
              {
                "@begin": "1:53.707",
                "@end": "1:54.024",
                "#text": "don't",
              },
              {
                "@begin": "1:54.024",
                "@end": "1:54.424",
                "#text": "get",
              },
              {
                "@begin": "1:54.424",
                "@end": "1:55.256",
                "#text": "angry",
              },
              {
                "@begin": "1:55.256",
                "@end": "1:55.573",
                "#text": "when",
              },
              {
                "@begin": "1:55.573",
                "@end": "1:55.939",
                "#text": "i'm",
              },
              {
                "@begin": "1:55.939",
                "@end": "1:56.381",
                "#text": "pissed",
              },
            ],
          },
          {
            "@begin": "1:56.481",
            "@end": "1:59.391",
            "@itunes:key": "L27",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:56.481",
                "@end": "1:56.746",
                "#text": "i'm",
              },
              {
                "@begin": "1:56.746",
                "@end": "1:57.098",
                "#text": "the",
              },
              {
                "@begin": "1:57.098",
                "@end": "1:58.264",
                "#text": "eternal",
              },
              {
                "@begin": "1:58.264",
                "@end": "1:59.391",
                "#text": "optimist",
              },
            ],
          },
          {
            "@begin": "1:59.491",
            "@end": "2:05.457",
            "@itunes:key": "L28",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:59.491",
                "@end": "1:59.840",
                "#text": "i",
              },
              {
                "@begin": "1:59.840",
                "@end": "2:00.158",
                "#text": "scream",
              },
              {
                "@begin": "2:00.158",
                "@end": "2:00.923",
                "#text": "inside",
              },
              {
                "@begin": "2:00.923",
                "@end": "2:01.339",
                "#text": "to",
              },
              {
                "@begin": "2:01.339",
                "@end": "2:01.707",
                "#text": "deal",
              },
              {
                "@begin": "2:01.707",
                "@end": "2:02.091",
                "#text": "with",
              },
              {
                "@begin": "2:02.091",
                "@end": "2:02.397",
                "#text": "it",
              },
              {
                "@begin": "2:02.397",
                "@end": "2:02.753",
                "#text": "like,",
              },
              {
                "@begin": "2:02.753",
                "@end": "2:05.457",
                "#text": '"ah!"',
              },
            ],
          },
          {
            "@begin": "2:05.509",
            "@end": "2:13.590",
            "@itunes:key": "L29",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:05.509",
                "@end": "2:05.935",
                "#text": "like,",
              },
              {
                "@begin": "2:05.935",
                "@end": "2:13.590",
                "#text": '"ah!"',
              },
            ],
          },
        ],
      },
      {
        "@begin": "2:18.165",
        "@end": "2:42.661",
        "@xmlns:itunes": "http://music.apple.com/lyric-ttml-internal",
        "@itunes:songpart": "Outro",
        p: [
          {
            "@begin": "2:18.165",
            "@end": "2:20.641",
            "@itunes:key": "L30",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:18.165",
                "@end": "2:18.880",
                "#text": "all",
              },
              {
                "@begin": "2:18.880",
                "@end": "2:19.666",
                "#text": "the",
              },
              {
                "@begin": "2:19.666",
                "@end": "2:20.641",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "2:20.869",
            "@end": "2:23.698",
            "@itunes:key": "L31",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:20.869",
                "@end": "2:21.182",
                "#text": "i'm",
              },
              {
                "@begin": "2:21.182",
                "@end": "2:22.014",
                "#text": "grateful",
              },
              {
                "@begin": "2:22.014",
                "@end": "2:22.382",
                "#text": "all",
              },
              {
                "@begin": "2:22.382",
                "@end": "2:22.747",
                "#text": "the",
              },
              {
                "@begin": "2:22.747",
                "@end": "2:23.698",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "2:23.899",
            "@end": "2:26.837",
            "@itunes:key": "L32",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:23.899",
                "@end": "2:24.219",
                "#text": "i'm",
              },
              {
                "@begin": "2:24.219",
                "@end": "2:25.051",
                "#text": "sexy",
              },
              {
                "@begin": "2:25.051",
                "@end": "2:25.200",
                "#text": "and",
              },
              {
                "@begin": "2:25.200",
                "@end": "2:25.752",
                "#text": "i'm",
              },
              {
                "@begin": "2:25.752",
                "@end": "2:26.837",
                "#text": "kind",
              },
            ],
          },
          {
            "@begin": "2:26.946",
            "@end": "2:29.796",
            "@itunes:key": "L33",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:26.946",
                "@end": "2:27.279",
                "#text": "i'm",
              },
              {
                "@begin": "2:27.279",
                "@end": "2:28.040",
                "#text": "pretty",
              },
              {
                "@begin": "2:28.040",
                "@end": "2:28.263",
                "#text": "when",
              },
              {
                "@begin": "2:28.263",
                "@end": "2:28.801",
                "#text": "i",
              },
              {
                "@begin": "2:28.801",
                "@end": "2:29.796",
                "#text": "cry",
              },
            ],
          },
          {
            "@begin": "2:30.019",
            "@end": "2:32.882",
            "@itunes:key": "L34",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:30.019",
                "@end": "2:30.365",
                "#text": "oh,",
              },
              {
                "@begin": "2:30.365",
                "@end": "2:31.115",
                "#text": "all",
              },
              {
                "@begin": "2:31.115",
                "@end": "2:31.880",
                "#text": "the",
              },
              {
                "@begin": "2:31.880",
                "@end": "2:32.882",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "2:33.083",
            "@end": "2:36.572",
            "@itunes:key": "L35",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:33.083",
                "@end": "2:33.411",
                "#text": "i'm",
              },
              {
                "@begin": "2:33.411",
                "@end": "2:34.227",
                "#text": "grateful",
              },
              {
                "@begin": "2:34.227",
                "@end": "2:34.595",
                "#text": "all",
              },
              {
                "@begin": "2:34.595",
                "@end": "2:34.944",
                "#text": "the",
              },
              {
                "@begin": "2:34.944",
                "@end": "2:35.938",
                "#text": "time",
              },
              {
                "@ttm:role": "x-bg",
                span: [
                  {
                    "@begin": "2:33.088",
                    "@end": "2:33.395",
                    "#text": "(i'm",
                  },
                  {
                    "@begin": "2:33.395",
                    "@end": "2:34.179",
                    "#text": "grateful,",
                  },
                  {
                    "@begin": "2:34.179",
                    "@end": "2:34.963",
                    "#text": "grateful",
                  },
                  {
                    "@begin": "2:34.963",
                    "@end": "2:35.328",
                    "#text": "all",
                  },
                  {
                    "@begin": "2:35.328",
                    "@end": "2:35.512",
                    "#text": "the",
                  },
                  {
                    "@begin": "2:35.512",
                    "@end": "2:36.572",
                    "#text": "time)",
                  },
                ],
              },
            ],
          },
          {
            "@begin": "2:36.123",
            "@end": "2:38.972",
            "@itunes:key": "L36",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:36.123",
                "@end": "2:36.367",
                "#text": "i'm",
              },
              {
                "@begin": "2:36.367",
                "@end": "2:37.285",
                "#text": "sexy",
              },
              {
                "@begin": "2:37.285",
                "@end": "2:37.434",
                "#text": "and",
              },
              {
                "@begin": "2:37.434",
                "@end": "2:37.967",
                "#text": "i'm",
              },
              {
                "@begin": "2:37.967",
                "@end": "2:38.972",
                "#text": "kind",
              },
            ],
          },
          {
            "@begin": "2:39.200",
            "@end": "2:42.661",
            "@itunes:key": "L37",
            "@xmlns:ttm": "http://www.w3.org/ns/ttml#metadata",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "2:39.200",
                "@end": "2:39.475",
                "#text": "i'm",
              },
              {
                "@begin": "2:39.475",
                "@end": "2:40.291",
                "#text": "pretty",
              },
              {
                "@begin": "2:40.291",
                "@end": "2:40.491",
                "#text": "when",
              },
              {
                "@begin": "2:40.491",
                "@end": "2:41.008",
                "#text": "i",
              },
              {
                "@begin": "2:41.008",
                "@end": "2:42.661",
                "#text": "cry",
              },
            ],
          },
        ],
      },
    ],
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\data\__mock__copy.ts
export const parsedJson = {
  body: {
    "@xmlns": "http://www.w3.org/ns/ttml",
    "@dur": "2:15.053",
    div: [
      {
        "@begin": "0.312",
        "@end": "8.256",
        "@itunes:songPart": "Intro",
        p: [
          {
            "@begin": "0.312",
            "@end": "4.056",
            "@itunes:key": "L1",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "0.312",
                "@end": "0.736",
                "#text": "What's",
              },
              {
                "@begin": "0.736",
                "@end": "0.971",
                "#text": "the",
              },
              {
                "@begin": "0.971",
                "@end": "1.485",
                "#text": "rush?",
              },
              {
                "@begin": "1.485",
                "@end": "1.803",
                "#text": "What's",
              },
              {
                "@begin": "1.803",
                "@end": "2.104",
                "#text": "the",
              },
              {
                "@begin": "2.104",
                "@end": "2.752",
                "#text": "rush?",
              },
              {
                "@begin": "2.752",
                "@end": "3.101",
                "#text": "What's",
              },
              {
                "@begin": "3.101",
                "@end": "3.419",
                "#text": "the",
              },
              {
                "@begin": "3.419",
                "@end": "4.056",
                "#text": "rush?",
              },
            ],
          },
          {
            "@begin": "3.656",
            "@end": "8.256",
            "@itunes:key": "L2",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "3.656",
                "@end": "5.288",
                "#text": "Rush,",
              },
              {
                "@begin": "6.624",
                "@end": "8.256",
                "#text": "rush",
              },
            ],
          },
        ],
      },
      {
        "@begin": "10.767",
        "@end": "40.098",
        "@itunes:songPart": "Verse",
        p: [
          {
            "@begin": "10.767",
            "@end": "12.215",
            "@itunes:key": "L3",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "10.767",
                "@end": "10.903",
                "#text": "I'm",
              },
              {
                "@begin": "10.903",
                "@end": "11.183",
                "#text": "tryna",
              },
              {
                "@begin": "11.183",
                "@end": "11.424",
                "#text": "see",
              },
              {
                "@begin": "11.424",
                "@end": "11.629",
                "#text": "what",
              },
              {
                "@begin": "11.629",
                "@end": "11.729",
                "#text": "I",
              },
              {
                "@begin": "11.729",
                "@end": "12.215",
                "#text": "like",
              },
            ],
          },
          {
            "@begin": "13.338",
            "@end": "14.666",
            "@itunes:key": "L4",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "13.338",
                "@end": "13.470",
                "#text": "You",
              },
              {
                "@begin": "13.470",
                "@end": "13.777",
                "#text": "tryna",
              },
              {
                "@begin": "13.777",
                "@end": "13.975",
                "#text": "see",
              },
              {
                "@begin": "13.975",
                "@end": "14.116",
                "#text": "what",
              },
              {
                "@begin": "14.116",
                "@end": "14.257",
                "#text": "you",
              },
              {
                "@begin": "14.257",
                "@end": "14.666",
                "#text": "like",
              },
            ],
          },
          {
            "@begin": "15.879",
            "@end": "17.942",
            "@itunes:key": "L5",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "15.879",
                "@end": "16.229",
                "#text": "Slow",
              },
              {
                "@begin": "16.229",
                "@end": "17.155",
                "#text": "down",
              },
              {
                "@begin": "17.155",
                "@end": "17.366",
                "#text": "for",
              },
              {
                "@begin": "17.366",
                "@end": "17.468",
                "#text": "a",
              },
              {
                "@begin": "17.468",
                "@end": "17.942",
                "#text": "minute",
              },
            ],
          },
          {
            "@begin": "18.362",
            "@end": "20.192",
            "@itunes:key": "L6",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "18.362",
                "@end": "18.710",
                "#text": "Get",
              },
              {
                "@begin": "18.710",
                "@end": "19.085",
                "#text": "real",
              },
              {
                "@begin": "19.085",
                "@end": "19.293",
                "#text": "for",
              },
              {
                "@begin": "19.293",
                "@end": "19.393",
                "#text": "a",
              },
              {
                "@begin": "19.393",
                "@end": "19.672",
                "#text": "minute",
              },
              {
                "@begin": "19.672",
                "@end": "19.808",
                "#text": "with",
              },
              {
                "@begin": "19.808",
                "@end": "20.192",
                "#text": "me",
              },
            ],
          },
          {
            "@begin": "20.637",
            "@end": "22.402",
            "@itunes:key": "L7",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "20.637",
                "@end": "20.848",
                "#text": "Maybe",
              },
              {
                "@begin": "20.848",
                "@end": "21.102",
                "#text": "I'm",
              },
              {
                "@begin": "21.102",
                "@end": "21.480",
                "#text": "bad",
              },
              {
                "@begin": "21.480",
                "@end": "21.608",
                "#text": "for",
              },
              {
                "@begin": "21.608",
                "@end": "22.402",
                "#text": "myself",
              },
            ],
          },
          {
            "@begin": "23.072",
            "@end": "25.272",
            "@itunes:key": "L8",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "23.072",
                "@end": "23.420",
                "#text": "Maybe",
              },
              {
                "@begin": "23.420",
                "@end": "23.694",
                "#text": "I'm",
              },
              {
                "@begin": "23.694",
                "@end": "23.913",
                "#text": "bad",
              },
              {
                "@begin": "23.913",
                "@end": "24.019",
                "#text": "for",
              },
              {
                "@begin": "24.019",
                "@end": "25.272",
                "#text": "myself",
              },
            ],
          },
          {
            "@begin": "25.560",
            "@end": "26.944",
            "@itunes:key": "L9",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "25.560",
                "@end": "25.854",
                "#text": "Every",
              },
              {
                "@begin": "25.854",
                "@end": "26.095",
                "#text": "time",
              },
              {
                "@begin": "26.095",
                "@end": "26.241",
                "#text": "we",
              },
              {
                "@begin": "26.241",
                "@end": "26.425",
                "#text": "take",
              },
              {
                "@begin": "26.425",
                "@end": "26.525",
                "#text": "a",
              },
              {
                "@begin": "26.525",
                "@end": "26.944",
                "#text": "picture",
              },
            ],
          },
          {
            "@begin": "27.776",
            "@end": "29.827",
            "@itunes:key": "L10",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "27.776",
                "@end": "28.036",
                "#text": "Getting",
              },
              {
                "@begin": "28.036",
                "@end": "28.244",
                "#text": "high",
              },
              {
                "@begin": "28.244",
                "@end": "28.344",
                "#text": "and",
              },
              {
                "@begin": "28.344",
                "@end": "28.555",
                "#text": "drunk,",
              },
              {
                "@begin": "28.555",
                "@end": "28.700",
                "#text": "the",
              },
              {
                "@begin": "28.700",
                "@end": "29.045",
                "#text": "perfect",
              },
              {
                "@begin": "29.045",
                "@end": "29.827",
                "#text": "mixture",
              },
            ],
          },
          {
            "@begin": "29.827",
            "@end": "32.035",
            "@itunes:key": "L11",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "29.827",
                "@end": "29.927",
                "#text": "I",
              },
              {
                "@begin": "29.927",
                "@end": "30.217",
                "#text": "wanna",
              },
              {
                "@begin": "30.217",
                "@end": "30.456",
                "#text": "see",
              },
              {
                "@begin": "30.456",
                "@end": "30.561",
                "#text": "a",
              },
              {
                "@begin": "30.561",
                "@end": "30.858",
                "#text": "little,",
              },
              {
                "@begin": "30.858",
                "@end": "31.000",
                "#text": "you",
              },
              {
                "@begin": "31.000",
                "@end": "31.243",
                "#text": "wanna",
              },
              {
                "@begin": "31.243",
                "@end": "31.350",
                "#text": "see",
              },
              {
                "@begin": "31.350",
                "@end": "31.518",
                "#text": "a",
              },
              {
                "@begin": "31.518",
                "@end": "32.035",
                "#text": "lot",
              },
            ],
          },
          {
            "@begin": "32.144",
            "@end": "34.546",
            "@itunes:key": "L12",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "32.144",
                "@end": "32.532",
                "#text": "Yeah,",
              },
              {
                "@begin": "32.532",
                "@end": "32.812",
                "#text": "heart",
              },
              {
                "@begin": "32.812",
                "@end": "33.106",
                "#text": "beat",
              },
              {
                "@begin": "33.106",
                "@end": "33.522",
                "#text": "racing,",
              },
              {
                "@begin": "33.522",
                "@end": "33.714",
                "#text": "you",
              },
              {
                "@begin": "33.714",
                "@end": "33.969",
                "#text": "breathe",
              },
              {
                "@begin": "33.969",
                "@end": "34.069",
                "#text": "a",
              },
              {
                "@begin": "34.069",
                "@end": "34.546",
                "#text": "lot",
              },
            ],
          },
          {
            "@begin": "34.651",
            "@end": "37.476",
            "@itunes:key": "L13",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "34.651",
                "@end": "34.823",
                "#text": "Why",
              },
              {
                "@begin": "34.823",
                "@end": "35.007",
                "#text": "you",
              },
              {
                "@begin": "35.007",
                "@end": "35.559",
                "#text": "rushing,",
              },
              {
                "@begin": "35.559",
                "@end": "35.769",
                "#text": "why",
              },
              {
                "@begin": "35.769",
                "@end": "35.914",
                "#text": "you",
              },
              {
                "@begin": "35.914",
                "@end": "36.279",
                "#text": "rush",
              },
              {
                "@begin": "36.279",
                "@end": "37.476",
                "#text": "ing?",
              },
            ],
          },
          {
            "@begin": "37.790",
            "@end": "40.098",
            "@itunes:key": "L14",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "37.790",
                "@end": "38.150",
                "#text": "R-",
              },
              {
                "@begin": "38.150",
                "@end": "38.439",
                "#text": "r-",
              },
              {
                "@begin": "38.439",
                "@end": "39.012",
                "#text": "rush",
              },
              {
                "@begin": "39.012",
                "@end": "39.345",
                "#text": "shing",
              },
              {
                "@begin": "39.345",
                "@end": "39.650",
                "#text": "-shing",
              },
              {
                "@begin": "39.650",
                "@end": "40.098",
                "#text": "-shing",
              },
            ],
          },
        ],
      },
      {
        "@begin": "48.960",
        "@end": "58.983",
        "@itunes:songPart": "Chorus",
        p: [
          {
            "@begin": "48.960",
            "@end": "51.670",
            "@itunes:key": "L15",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "48.960",
                "@end": "49.100",
                "#text": "B-",
              },
              {
                "@begin": "49.100",
                "@end": "49.275",
                "#text": "b-",
              },
              {
                "@begin": "49.275",
                "@end": "49.423",
                "#text": "b-",
              },
              {
                "@begin": "49.423",
                "@end": "49.567",
                "#text": "b-",
              },
              {
                "@begin": "49.567",
                "@end": "49.699",
                "#text": "b-",
              },
              {
                "@begin": "49.699",
                "@end": "49.941",
                "#text": "been",
              },
              {
                "@begin": "49.941",
                "@end": "50.327",
                "#text": "away",
              },
              {
                "@begin": "50.327",
                "@end": "50.487",
                "#text": "for",
              },
              {
                "@begin": "50.487",
                "@end": "50.594",
                "#text": "a",
              },
              {
                "@begin": "50.594",
                "@end": "50.957",
                "#text": "minute",
              },
              {
                "@begin": "50.957",
                "@end": "51.670",
                "#text": "now",
              },
            ],
          },
          {
            "@begin": "52.816",
            "@end": "53.846",
            "@itunes:key": "L16",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "52.816",
                "@end": "52.945",
                "#text": "Know",
              },
              {
                "@begin": "52.945",
                "@end": "53.093",
                "#text": "you",
              },
              {
                "@begin": "53.093",
                "@end": "53.386",
                "#text": "felt",
              },
              {
                "@begin": "53.386",
                "@end": "53.846",
                "#text": "that",
              },
            ],
          },
          {
            "@begin": "54.647",
            "@end": "56.448",
            "@itunes:key": "L17",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "54.647",
                "@end": "54.838",
                "#text": "Been",
              },
              {
                "@begin": "54.838",
                "@end": "55.255",
                "#text": "away",
              },
              {
                "@begin": "55.255",
                "@end": "55.434",
                "#text": "for",
              },
              {
                "@begin": "55.434",
                "@end": "55.534",
                "#text": "a",
              },
              {
                "@begin": "55.534",
                "@end": "55.867",
                "#text": "minute",
              },
              {
                "@begin": "55.867",
                "@end": "56.448",
                "#text": "now",
              },
            ],
          },
          {
            "@begin": "57.767",
            "@end": "58.983",
            "@itunes:key": "L18",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "57.767",
                "@end": "57.898",
                "#text": "Know",
              },
              {
                "@begin": "57.898",
                "@end": "58.038",
                "#text": "you",
              },
              {
                "@begin": "58.038",
                "@end": "58.356",
                "#text": "felt",
              },
              {
                "@begin": "58.356",
                "@end": "58.983",
                "#text": "that",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:00.274",
        "@end": "1:30.042",
        "@itunes:songPart": "Verse",
        p: [
          {
            "@begin": "1:00.274",
            "@end": "1:01.754",
            "@itunes:key": "L19",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:00.274",
                "@end": "1:00.494",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:00.494",
                "@end": "1:00.594",
                "#text": "I'm",
              },
              {
                "@begin": "1:00.594",
                "@end": "1:00.901",
                "#text": "high",
              },
              {
                "@begin": "1:00.901",
                "@end": "1:01.017",
                "#text": "all",
              },
              {
                "@begin": "1:01.017",
                "@end": "1:01.183",
                "#text": "the",
              },
              {
                "@begin": "1:01.183",
                "@end": "1:01.754",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "1:01.890",
            "@end": "1:04.378",
            "@itunes:key": "L20",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:01.890",
                "@end": "1:02.060",
                "#text": "Why",
              },
              {
                "@begin": "1:02.060",
                "@end": "1:02.220",
                "#text": "she",
              },
              {
                "@begin": "1:02.220",
                "@end": "1:02.468",
                "#text": "like,",
              },
              {
                "@begin": "1:02.468",
                "@end": "1:02.688",
                "#text": '"Why',
              },
              {
                "@begin": "1:02.688",
                "@end": "1:02.835",
                "#text": "you",
              },
              {
                "@begin": "1:02.835",
                "@end": "1:03.091",
                "#text": "always",
              },
              {
                "@begin": "1:03.091",
                "@end": "1:03.447",
                "#text": "high",
              },
              {
                "@begin": "1:03.447",
                "@end": "1:03.594",
                "#text": "all",
              },
              {
                "@begin": "1:03.594",
                "@end": "1:03.731",
                "#text": "the",
              },
              {
                "@begin": "1:03.731",
                "@end": "1:04.378",
                "#text": 'time?"',
              },
            ],
          },
          {
            "@begin": "1:04.378",
            "@end": "1:07.247",
            "@itunes:key": "L21",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:04.378",
                "@end": "1:04.670",
                "#text": "God",
              },
              {
                "@begin": "1:04.670",
                "@end": "1:05.217",
                "#text": "damnit,",
              },
              {
                "@begin": "1:05.592",
                "@end": "1:05.694",
                "#text": "I",
              },
              {
                "@begin": "1:05.694",
                "@end": "1:05.846",
                "#text": "be",
              },
              {
                "@begin": "1:05.846",
                "@end": "1:06.036",
                "#text": "out",
              },
              {
                "@begin": "1:06.036",
                "@end": "1:06.230",
                "#text": "my",
              },
              {
                "@begin": "1:06.230",
                "@end": "1:06.512",
                "#text": "mind",
              },
              {
                "@begin": "1:06.512",
                "@end": "1:06.663",
                "#text": "in",
              },
              {
                "@begin": "1:06.663",
                "@end": "1:06.844",
                "#text": "this",
              },
              {
                "@begin": "1:06.844",
                "@end": "1:07.247",
                "#text": "shit",
              },
            ],
          },
          {
            "@begin": "1:07.247",
            "@end": "1:10.055",
            "@itunes:key": "L22",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:07.247",
                "@end": "1:07.793",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:07.793",
                "@end": "1:07.893",
                "#text": "I",
              },
              {
                "@begin": "1:07.893",
                "@end": "1:08.175",
                "#text": "turn",
              },
              {
                "@begin": "1:08.175",
                "@end": "1:08.442",
                "#text": "deaf",
              },
              {
                "@begin": "1:08.442",
                "@end": "1:08.749",
                "#text": "folk",
              },
              {
                "@begin": "1:08.749",
                "@end": "1:09.069",
                "#text": "blind",
              },
              {
                "@begin": "1:09.069",
                "@end": "1:09.216",
                "#text": "in",
              },
              {
                "@begin": "1:09.216",
                "@end": "1:09.361",
                "#text": "this",
              },
              {
                "@begin": "1:09.361",
                "@end": "1:09.643",
                "#text": "bitch.",
              },
              {
                "@begin": "1:09.643",
                "@end": "1:10.055",
                "#text": "uh",
              },
            ],
          },
          {
            "@begin": "1:10.602",
            "@end": "1:12.283",
            "@itunes:key": "L23",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:10.602",
                "@end": "1:10.756",
                "#text": "Why",
              },
              {
                "@begin": "1:10.756",
                "@end": "1:10.933",
                "#text": "you",
              },
              {
                "@begin": "1:10.933",
                "@end": "1:11.253",
                "#text": "always",
              },
              {
                "@begin": "1:11.253",
                "@end": "1:11.547",
                "#text": "lying",
              },
              {
                "@begin": "1:11.547",
                "@end": "1:11.707",
                "#text": "like",
              },
              {
                "@begin": "1:11.707",
                "@end": "1:11.827",
                "#text": "a",
              },
              {
                "@begin": "1:11.827",
                "@end": "1:12.283",
                "#text": "bitch?",
              },
            ],
          },
          {
            "@begin": "1:12.283",
            "@end": "1:14.996",
            "@itunes:key": "L24",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:12.283",
                "@end": "1:12.777",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:12.777",
                "@end": "1:12.966",
                "#text": "take",
              },
              {
                "@begin": "1:12.966",
                "@end": "1:13.113",
                "#text": "the",
              },
              {
                "@begin": "1:13.113",
                "@end": "1:13.409",
                "#text": "picture,",
              },
              {
                "@begin": "1:13.409",
                "@end": "1:13.655",
                "#text": "go",
              },
              {
                "@begin": "1:13.655",
                "@end": "1:14.045",
                "#text": "timeless",
              },
              {
                "@begin": "1:14.045",
                "@end": "1:14.167",
                "#text": "in",
              },
              {
                "@begin": "1:14.167",
                "@end": "1:14.312",
                "#text": "this",
              },
              {
                "@begin": "1:14.312",
                "@end": "1:14.647",
                "#text": "bitch,",
              },
              {
                "@begin": "1:14.647",
                "@end": "1:14.996",
                "#text": "uh",
              },
            ],
          },
          {
            "@begin": "1:14.996",
            "@end": "1:16.596",
            "@itunes:key": "L25",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:14.996",
                "@end": "1:15.181",
                "#text": "Time",
              },
              {
                "@begin": "1:15.181",
                "@end": "1:15.281",
                "#text": "to",
              },
              {
                "@begin": "1:15.281",
                "@end": "1:15.506",
                "#text": "make",
              },
              {
                "@begin": "1:15.506",
                "@end": "1:15.613",
                "#text": "the",
              },
              {
                "@begin": "1:15.613",
                "@end": "1:16.596",
                "#text": "switch",
              },
            ],
          },
          {
            "@begin": "1:16.596",
            "@end": "1:19.697",
            "@itunes:key": "L26",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:16.596",
                "@end": "1:16.732",
                "#text": "They",
              },
              {
                "@begin": "1:16.732",
                "@end": "1:16.855",
                "#text": "done",
              },
              {
                "@begin": "1:16.855",
                "@end": "1:17.057",
                "#text": "fucked",
              },
              {
                "@begin": "1:17.057",
                "@end": "1:17.172",
                "#text": "up,",
              },
              {
                "@begin": "1:17.172",
                "@end": "1:17.312",
                "#text": "they",
              },
              {
                "@begin": "1:17.312",
                "@end": "1:17.486",
                "#text": "done",
              },
              {
                "@begin": "1:17.486",
                "@end": "1:17.651",
                "#text": "got",
              },
              {
                "@begin": "1:17.651",
                "@end": "1:17.770",
                "#text": "me",
              },
              {
                "@begin": "1:17.770",
                "@end": "1:17.989",
                "#text": "way",
              },
              {
                "@begin": "1:17.989",
                "@end": "1:18.151",
                "#text": "too",
              },
              {
                "@begin": "1:18.151",
                "@end": "1:18.431",
                "#text": "rich,",
              },
              {
                "@begin": "1:18.431",
                "@end": "1:19.071",
                "#text": "yeah,",
              },
              {
                "@begin": "1:19.071",
                "@end": "1:19.697",
                "#text": "ho",
              },
            ],
          },
          {
            "@begin": "1:22.188",
            "@end": "1:23.479",
            "@itunes:key": "L27",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:22.188",
                "@end": "1:22.380",
                "#text": "Fuck",
              },
              {
                "@begin": "1:22.380",
                "@end": "1:22.480",
                "#text": "it,",
              },
              {
                "@begin": "1:22.480",
                "@end": "1:22.591",
                "#text": "throw",
              },
              {
                "@begin": "1:22.591",
                "@end": "1:22.691",
                "#text": "me",
              },
              {
                "@begin": "1:22.691",
                "@end": "1:23.152",
                "#text": "another",
              },
              {
                "@begin": "1:23.152",
                "@end": "1:23.479",
                "#text": "cup",
              },
            ],
          },
          {
            "@begin": "1:26.588",
            "@end": "1:30.042",
            "@itunes:key": "L28",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:26.588",
                "@end": "1:26.757",
                "#text": "'Cause",
              },
              {
                "@begin": "1:26.757",
                "@end": "1:26.857",
                "#text": "it",
              },
              {
                "@begin": "1:26.857",
                "@end": "1:27.035",
                "#text": "ain't",
              },
              {
                "@begin": "1:27.035",
                "@end": "1:27.266",
                "#text": "gon'",
              },
              {
                "@begin": "1:27.266",
                "@end": "1:27.559",
                "#text": "get",
              },
              {
                "@begin": "1:27.559",
                "@end": "1:28.265",
                "#text": "colder",
              },
              {
                "@begin": "1:29.099",
                "@end": "1:29.259",
                "#text": "when",
              },
              {
                "@begin": "1:29.259",
                "@end": "1:29.404",
                "#text": "it's",
              },
              {
                "@begin": "1:29.404",
                "@end": "1:30.042",
                "#text": "over",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:30.042",
        "@end": "1:43.942",
        "@itunes:songPart": "Chorus",
        p: [
          {
            "@begin": "1:30.042",
            "@end": "1:31.423",
            "@itunes:key": "L29",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:30.042",
                "@end": "1:30.142",
                "#text": "Tell",
              },
              {
                "@begin": "1:30.142",
                "@end": "1:30.319",
                "#text": "'em",
              },
              {
                "@begin": "1:30.319",
                "@end": "1:30.465",
                "#text": "go",
              },
              {
                "@begin": "1:30.465",
                "@end": "1:30.614",
                "#text": "get",
              },
              {
                "@begin": "1:30.614",
                "@end": "1:30.772",
                "#text": "back",
              },
              {
                "@begin": "1:30.772",
                "@end": "1:30.904",
                "#text": "in",
              },
              {
                "@begin": "1:30.904",
                "@end": "1:31.423",
                "#text": "line",
              },
            ],
          },
          {
            "@begin": "1:31.572",
            "@end": "1:33.956",
            "@itunes:key": "L30",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:31.572",
                "@end": "1:31.718",
                "#text": "And",
              },
              {
                "@begin": "1:31.718",
                "@end": "1:31.851",
                "#text": "they",
              },
              {
                "@begin": "1:31.851",
                "@end": "1:32.001",
                "#text": "gon'",
              },
              {
                "@begin": "1:32.001",
                "@end": "1:32.109",
                "#text": "get",
              },
              {
                "@begin": "1:32.109",
                "@end": "1:32.307",
                "#text": "swept",
              },
              {
                "@begin": "1:32.307",
                "@end": "1:32.644",
                "#text": "under",
              },
              {
                "@begin": "1:32.644",
                "@end": "1:32.779",
                "#text": "the",
              },
              {
                "@begin": "1:32.779",
                "@end": "1:33.134",
                "#text": "rug",
              },
              {
                "@begin": "1:33.134",
                "@end": "1:33.426",
                "#text": "every",
              },
              {
                "@begin": "1:33.426",
                "@end": "1:33.956",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "1:34.041",
            "@end": "1:36.423",
            "@itunes:key": "L31",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:34.041",
                "@end": "1:34.289",
                "#text": "Always",
              },
              {
                "@begin": "1:34.289",
                "@end": "1:34.604",
                "#text": "flying,",
              },
              {
                "@begin": "1:34.604",
                "@end": "1:34.738",
                "#text": "so",
              },
              {
                "@begin": "1:34.738",
                "@end": "1:34.911",
                "#text": "you",
              },
              {
                "@begin": "1:34.911",
                "@end": "1:35.135",
                "#text": "know",
              },
              {
                "@begin": "1:35.135",
                "@end": "1:35.276",
                "#text": "I'm",
              },
              {
                "@begin": "1:35.276",
                "@end": "1:35.481",
                "#text": "on",
              },
              {
                "@begin": "1:35.481",
                "@end": "1:35.641",
                "#text": "that",
              },
              {
                "@begin": "1:35.641",
                "@end": "1:35.899",
                "#text": "heli-",
              },
              {
                "@begin": "1:35.899",
                "@end": "1:36.423",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "1:36.561",
            "@end": "1:38.977",
            "@itunes:key": "L32",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:36.561",
                "@end": "1:36.770",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:36.770",
                "@end": "1:36.870",
                "#text": "we",
              },
              {
                "@begin": "1:36.870",
                "@end": "1:37.165",
                "#text": "crushing",
              },
              {
                "@begin": "1:37.165",
                "@end": "1:37.325",
                "#text": "they",
              },
              {
                "@begin": "1:37.325",
                "@end": "1:37.658",
                "#text": "dreams",
              },
              {
                "@begin": "1:37.658",
                "@end": "1:37.818",
                "#text": "like",
              },
              {
                "@begin": "1:37.818",
                "@end": "1:37.954",
                "#text": "we",
              },
              {
                "@begin": "1:37.954",
                "@end": "1:38.097",
                "#text": "gon'",
              },
              {
                "@begin": "1:38.097",
                "@end": "1:38.279",
                "#text": "snort",
              },
              {
                "@begin": "1:38.279",
                "@end": "1:38.379",
                "#text": "a",
              },
              {
                "@begin": "1:38.379",
                "@end": "1:38.977",
                "#text": "line",
              },
            ],
          },
          {
            "@begin": "1:39.072",
            "@end": "1:41.420",
            "@itunes:key": "L33",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:39.072",
                "@end": "1:39.172",
                "#text": "I",
              },
              {
                "@begin": "1:39.172",
                "@end": "1:39.369",
                "#text": "don't",
              },
              {
                "@begin": "1:39.369",
                "@end": "1:39.582",
                "#text": "meet",
              },
              {
                "@begin": "1:39.582",
                "@end": "1:39.701",
                "#text": "in",
              },
              {
                "@begin": "1:39.701",
                "@end": "1:39.829",
                "#text": "the",
              },
              {
                "@begin": "1:39.829",
                "@end": "1:40.125",
                "#text": "middle,",
              },
              {
                "@begin": "1:40.125",
                "@end": "1:40.335",
                "#text": "don't",
              },
              {
                "@begin": "1:40.335",
                "@end": "1:40.489",
                "#text": "do",
              },
              {
                "@begin": "1:40.489",
                "@end": "1:40.608",
                "#text": "no",
              },
              {
                "@begin": "1:40.608",
                "@end": "1:41.420",
                "#text": "borderline",
              },
            ],
          },
          {
            "@begin": "1:41.542",
            "@end": "1:43.942",
            "@itunes:key": "L34",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:41.542",
                "@end": "1:41.719",
                "#text": "I'm",
              },
              {
                "@begin": "1:41.719",
                "@end": "1:41.819",
                "#text": "a",
              },
              {
                "@begin": "1:41.819",
                "@end": "1:42.323",
                "#text": "geekstar,",
              },
              {
                "@begin": "1:42.323",
                "@end": "1:42.654",
                "#text": "baby,",
              },
              {
                "@begin": "1:42.654",
                "@end": "1:42.754",
                "#text": "I",
              },
              {
                "@begin": "1:42.754",
                "@end": "1:42.888",
                "#text": "do",
              },
              {
                "@begin": "1:42.888",
                "@end": "1:43.110",
                "#text": "this",
              },
              {
                "@begin": "1:43.110",
                "@end": "1:43.270",
                "#text": "all",
              },
              {
                "@begin": "1:43.270",
                "@end": "1:43.424",
                "#text": "the",
              },
              {
                "@begin": "1:43.424",
                "@end": "1:43.942",
                "#text": "time",
              },
            ],
          },
        ],
      },
      {
        "@begin": "1:44.046",
        "@end": "1:57.935",
        "@itunes:songPart": "Outro",
        p: [
          {
            "@begin": "1:44.046",
            "@end": "1:48.347",
            "@itunes:key": "L35",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:44.046",
                "@end": "1:44.183",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:44.183",
                "@end": "1:44.315",
                "#text": "we",
              },
              {
                "@begin": "1:44.315",
                "@end": "1:44.641",
                "#text": "gon'",
              },
              {
                "@begin": "1:44.641",
                "@end": "1:44.874",
                "#text": "do",
              },
              {
                "@begin": "1:44.874",
                "@end": "1:45.012",
                "#text": "it",
              },
              {
                "@begin": "1:45.012",
                "@end": "1:45.279",
                "#text": "all",
              },
              {
                "@begin": "1:45.279",
                "@end": "1:45.584",
                "#text": "the",
              },
              {
                "@begin": "1:45.584",
                "@end": "1:46.371",
                "#text": "time,",
              },
              {
                "@begin": "1:46.888",
                "@end": "1:47.125",
                "#text": "all",
              },
              {
                "@begin": "1:47.125",
                "@end": "1:47.513",
                "#text": "the",
              },
              {
                "@begin": "1:47.513",
                "@end": "1:48.347",
                "#text": "time",
              },
            ],
          },
          {
            "@begin": "1:48.365",
            "@end": "1:49.954",
            "@itunes:key": "L36",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:48.365",
                "@end": "1:48.641",
                "#text": "Really",
              },
              {
                "@begin": "1:48.641",
                "@end": "1:49.039",
                "#text": "praying",
              },
              {
                "@begin": "1:49.039",
                "@end": "1:49.199",
                "#text": "that",
              },
              {
                "@begin": "1:49.199",
                "@end": "1:49.355",
                "#text": "you",
              },
              {
                "@begin": "1:49.355",
                "@end": "1:49.506",
                "#text": "fall",
              },
              {
                "@begin": "1:49.506",
                "@end": "1:49.647",
                "#text": "in",
              },
              {
                "@begin": "1:49.647",
                "@end": "1:49.954",
                "#text": "line",
              },
            ],
          },
          {
            "@begin": "1:49.954",
            "@end": "1:51.386",
            "@itunes:key": "L37",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:49.954",
                "@end": "1:50.095",
                "#text": "Pick",
              },
              {
                "@begin": "1:50.095",
                "@end": "1:50.365",
                "#text": "apart",
              },
              {
                "@begin": "1:50.365",
                "@end": "1:50.534",
                "#text": "this",
              },
              {
                "@begin": "1:50.534",
                "@end": "1:50.722",
                "#text": "shit",
              },
              {
                "@begin": "1:50.722",
                "@end": "1:50.835",
                "#text": "for",
              },
              {
                "@begin": "1:50.835",
                "@end": "1:51.386",
                "#text": "real",
              },
            ],
          },
          {
            "@begin": "1:51.554",
            "@end": "1:53.970",
            "@itunes:key": "L38",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:51.554",
                "@end": "1:51.857",
                "#text": "Yeah,",
              },
              {
                "@begin": "1:51.857",
                "@end": "1:52.025",
                "#text": "tell",
              },
              {
                "@begin": "1:52.025",
                "@end": "1:52.200",
                "#text": "'em",
              },
              {
                "@begin": "1:52.200",
                "@end": "1:52.495",
                "#text": "lift",
              },
              {
                "@begin": "1:52.495",
                "@end": "1:52.748",
                "#text": "off,",
              },
              {
                "@begin": "1:52.748",
                "@end": "1:52.962",
                "#text": "yeah,",
              },
              {
                "@begin": "1:52.962",
                "@end": "1:53.107",
                "#text": "we",
              },
              {
                "@begin": "1:53.107",
                "@end": "1:53.231",
                "#text": "up",
              },
              {
                "@begin": "1:53.231",
                "@end": "1:53.440",
                "#text": "from",
              },
              {
                "@begin": "1:53.440",
                "@end": "1:53.970",
                "#text": "here",
              },
            ],
          },
          {
            "@begin": "1:54.370",
            "@end": "1:57.935",
            "@itunes:key": "L39",
            "@ttm:agent": "v1",
            span: [
              {
                "@begin": "1:54.370",
                "@end": "1:54.649",
                "#text": "Way",
              },
              {
                "@begin": "1:54.649",
                "@end": "1:54.931",
                "#text": "too",
              },
              {
                "@begin": "1:54.931",
                "@end": "1:56.544",
                "#text": "real",
              },
              {
                "@begin": "1:56.544",
                "@end": "1:56.851",
                "#text": "for",
              },
              {
                "@begin": "1:56.851",
                "@end": "1:57.935",
                "#text": "them",
              },
            ],
          },
        ],
      },
    ],
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\lrc-line.tsx
import Syllable from "./lrc-syllable";
import cn from "classnames";
import { useState, useEffect } from "react";
import { parseMills } from "./utils/lyricUtils";

interface Props {
  currentTime: number;
  begin: string;
  end: string;
  span: {
    "@begin": string;
    "@end": string;
    "#text": string;
  }[];
}

const LrcLine = ({ currentTime, begin, end, span }: Props) => {
  const [hasBeenCurrent, setHasBeenCurrent] = useState(false);
  const beginMills = parseMills(begin);
  const endMills = parseMills(end);
  const alreadyShown = currentTime > Number(endMills);
  const isCurrent =
    currentTime >= Number(beginMills) && currentTime <= Number(endMills);

  useEffect(() => {
    if (isCurrent && !hasBeenCurrent) {
      // Once line is current at least once, set hasBeenCurrent
      setHasBeenCurrent(true);
    }
  }, [isCurrent, hasBeenCurrent]);

  return (
    <button
      begin={begin}
      end={end}
      className={cn(
        "block !mb-14 text-left",
        hasBeenCurrent && "current", // keep "current" once line has ever been active
        isCurrent && "active" // "active" only while currently active
      )}
    >
      {span.map((span, j) => (
        <Syllable
          key={j}
          currentTime={currentTime}
          begin={span["@begin"]}
          end={span["@end"]}
          text={span["#text"]}
        />
      ))}
    </button>
  );
};

export default LrcLine;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\lrc-syllable.tsx
import { getGradientPercentage, parseMills } from "./utils/lyricUtils";
import { motion } from "framer-motion";

interface Props {
  currentTime: number;
  begin: string;
  end: string;
  text: string;
}

const Syllable = ({ currentTime, begin, end, text }: Props) => {
  const beginMills = parseMills(begin || "");
  const endMills = parseMills(end || "");
  const style: Record<string, string> = {};
  const startTime = Number(beginMills);
  const endTime = Number(endMills);
  const duration = endTime - startTime;
  const isActive = currentTime >= startTime && currentTime <= endTime;
  const isGone = currentTime > endTime;
  const longLasting = duration > 0.5;

  if (isActive) {
    style["--gradient-progress"] = getGradientPercentage(
      currentTime,
      +beginMills,
      +endMills
    );
  } else if (isGone) {
    style["--gradient-progress"] = "100%";
  } else {
    style["--gradient-progress"] = "0%";
  }

  let baseScale = 1;
  if (isActive && longLasting) {
    const growthRate = 0.18;
    baseScale = 1.05 + (duration - 0.5) * growthRate;
    baseScale = Math.min(baseScale, 1.15);
  } else if (isGone) {
    baseScale = 1;
  }

  // If active and longLasting, scale: [1, baseScale, 1]
  // Otherwise just baseScale.
  const animateScale = isActive && longLasting ? [1, baseScale, 1] : baseScale;

  // Make the total animation duration depend on the duration of the syllable.
  const extraTime = duration > 0.5 ? (duration - 0.5) * 1 : 0;
  const animationDuration = 0.5 + extraTime;

  const glow = [
    "0px 0px 10px rgba(255, 255, 255, 0)",
    "0px 0px 5px rgba(255, 255, 255, 0.3)",
    "0px 0px 3px rgba(255, 255, 255, 0.6)",
    "0px 0px 1px rgba(255, 255, 255, 1)",
    "0px 0px 20px rgba(255, 255, 255, 0.6)",
    "0px 0px 5px rgba(255, 255, 255, 0.3)",
    "0px 0px 10px rgba(255, 255, 255, 0)",
  ].join(", ");

  const glowOff = [
    "0px 0px 10px rgba(255, 255, 255, 0)",
    "0px 0px 5px rgba(255, 255, 255, 0)",
    "0px 0px 3px rgba(255, 255, 255, 0)",
    "0px 0px 1px rgba(255, 255, 255, 0)",
    "0px 0px 20px rgba(255, 255, 255, 0)",
    "0px 0px 5px rgba(255, 255, 255, 0)",
    "0px 0px 10px rgba(255, 255, 255, 0)",
  ].join(", ");

  return (
    <motion.span
      className="syllable inline-block"
      begin={begin}
      end={end}
      style={style}
      initial={{ y: 0 }}
      animate={{
        y: isActive || isGone ? -2 : 0,
        scale: animateScale,
        textShadow:
          isActive && longLasting
            ? [glowOff, glow, glowOff]
            : "0px 0px 0px rgba(255, 255, 255, 0)",
      }}
      transition={{
        duration: isActive && longLasting ? animationDuration : 0.33,
        ease: "easeOut",
        times: isActive && longLasting ? [0, 0.5, 1] : undefined,
      }}
    >
      {text}
    </motion.span>
  );
};

export default Syllable;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\lrc-view.tsx
"use client";
import { Fragment, RefObject, useEffect, useRef, useState } from "react";
import LrcLine from "./lrc-line";
import ReactPlayer from "react-player";
import { AppleKit } from "@/lib/audio/fetchers";
import { parseTTML } from "./utils/TTMLparser";

interface Props {
  audioRef: RefObject<HTMLAudioElement> | React.RefObject<ReactPlayer> | null;
  currentTime: number;
  title: string;
  artist: string;
}

const LrcView = ({ currentTime, title, artist }: Props) => {
  const [parsedJson, setParsedJson] = useState<any>(null);

  // Create a ref for the scrollable container
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const fetchLyrics = async () => {
      const lyrics = await AppleKit.getLyrics(title, artist);
      const parsedJson = parseTTML(lyrics);
      setParsedJson(parsedJson);
    };
    fetchLyrics();
  }, [title]);

  useEffect(() => {
    // On each time update, scroll the current line into view
    if (!containerRef.current) return;

    // Find the current line
    const currentLine = containerRef.current.querySelector(".active");
    if (currentLine) {
      currentLine.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  }, [currentTime]);

  if (!parsedJson?.body.div) {
    return (
      <div className="primary-vocals translate-y-1/2 max-w-4xl mx-auto flex-1">
        <p className="text-center">No lyrics found</p>
      </div>
    );
  }

  return (
    // Make sure this container is scrollable if content exceeds its size
    <div
      ref={containerRef}
      className="primary-vocals my-16 max-w-4xl mx-auto flex-1 overflow-auto"
      style={{ maxHeight: "80vh" }} // Adjust as needed
    >
      {parsedJson.body.div.map((div: any, i: any) => (
        <Fragment key={i}>
          {div.p.map((p: any, idx: any) => (
            <LrcLine
              key={idx}
              currentTime={currentTime}
              begin={p["@begin"]}
              end={p["@end"]}
              span={p.span as any}
            />
          ))}
        </Fragment>
      ))}
    </div>
  );
};

export default LrcView;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\utils\lyricUtils.ts
export const parseTtml = (ttml: string): any => {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(ttml, "text/xml");

  const result = parseNode(xmlDoc);
  console.log("Result", result);
  return result;
};

function parseNode(node: Document) {
  // if (node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE) {
  //     result.text = node.childNodes[0].nodeValue.trim();
  // } else if (node.childNodes.length > 0) {
  //     for (let i = 0; i < node.childNodes.length; i++) {
  //         const child = node.childNodes[i];
  //         if (child.nodeType === Node.ELEMENT_NODE) {
  //             result[child.nodeName] = result[child.nodeName] || [];
  //             result[child.nodeName].push(parseNode(child));
  //         }
  //     }
  // }
  const result = {};
  // console.log("Primary document", node);

  const body = node.querySelector("body");

  // console.log(body);

  return result;
}

export const parseMills = (time: string) => {
  const parts = time.split(":");
  let minutes: string;
  let seconds: string;
  let mills: string;

  if (parts.length == 2) {
    minutes = parts[0];
    const secPart = parts[1];
    seconds = secPart.split(".")[0];
    mills = secPart.split(".")[1];
  } else {
    minutes = "0";
    const secPart = parts[0];
    seconds = secPart.split(".")[0];
    mills = secPart.split(".")[1];
  }

  const totalMilliseconds =
    Number(minutes) * 60 * 1000 + Number(seconds) * 1000 + Number(mills);
  return totalMilliseconds / 1000;
};

export const getGradientPercentage = (
  currentTime: number,
  begin: number,
  end: number
) => {
  if (currentTime < begin || currentTime > end) {
    return "0%";
  }

  const range = end - begin;
  const passedValue = currentTime - begin;
  const percentage = (passedValue / range) * 100;

  return `${percentage.toFixed()}%`;
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\lrc\utils\TTMLparser.ts
interface TTMLMetadata {
  key: string;
  value: string[];
}

interface TTMLLyric {
  metadata: TTMLMetadata[];
  lyricLines: LyricLine[];
}

interface LyricWord {
  startTime: number;
  endTime: number;
  word: string;
  emptyBeat?: number;
}

export interface LyricLine {
  words: LyricWord[];
  translatedLyric: string;
  romanLyric: string;
  isBG: boolean;
  isDuet: boolean;
  startTime: number;
  endTime: number;
}

const timeRegexp =
  /^(((?<hour>[0-9]+):)?(?<min>[0-9]+):)?(?<sec>[0-9]+([.:]([0-9]+))?)/;

function parseTimespan(timeSpan: string): number {
  const matches = timeRegexp.exec(timeSpan);
  if (matches) {
    const hour = Number(matches.groups?.hour || "0");
    const min = Number(matches.groups?.min || "0");
    const sec = Number(matches.groups?.sec.replace(/:/, ".") || "0");
    return Math.floor((hour * 3600 + min * 60 + sec) * 1000);
  }
  throw new TypeError(`Failed to parse timestamp string: ${timeSpan}`);
}

export function parseTTML(ttmlText: string): TTMLLyric {
  const domParser = new DOMParser();
  const ttmlDoc: XMLDocument = domParser.parseFromString(
    ttmlText,
    "application/xml"
  );

  let mainAgentId = "v1";

  const metadata: TTMLMetadata[] = [];
  for (const meta of ttmlDoc.querySelectorAll("meta")) {
    if (meta.tagName === "amll:meta") {
      const key = meta.getAttribute("key");
      if (key) {
        const value = meta.getAttribute("value");
        if (value) {
          const existing = metadata.find((m) => m.key === key);
          if (existing) {
            existing.value.push(value);
          } else {
            metadata.push({
              key,
              value: [value],
            });
          }
        }
      }
    }
  }

  for (const agent of ttmlDoc.querySelectorAll("ttm\\:agent")) {
    if (agent.getAttribute("type") === "person") {
      const id = agent.getAttribute("xml:id");
      if (id) {
        mainAgentId = id;
      }
    }
  }

  const lyricLines: LyricLine[] = [];

  function parseParseLine(lineEl: Element, isBG = false, isDuet = false) {
    const line: LyricLine = {
      words: [],
      translatedLyric: "",
      romanLyric: "",
      isBG,
      isDuet:
        !!lineEl.getAttribute("ttm:agent") &&
        lineEl.getAttribute("ttm:agent") !== mainAgentId,
      startTime: 0,
      endTime: 0,
    };
    if (isBG) line.isDuet = isDuet;
    let haveBg = false;

    for (const wordNode of lineEl.childNodes) {
      if (wordNode.nodeType === Node.TEXT_NODE) {
        line.words?.push({
          word: wordNode.textContent ?? "",
          startTime: 0,
          endTime: 0,
        });
      } else if (wordNode.nodeType === Node.ELEMENT_NODE) {
        const wordEl = wordNode as Element;
        const role = wordEl.getAttribute("ttm:role");

        if (wordEl.nodeName === "span" && role) {
          if (role === "x-bg") {
            parseParseLine(wordEl, true, line.isDuet);
            haveBg = true;
          } else if (role === "x-translation") {
            line.translatedLyric = wordEl.innerHTML;
          } else if (role === "x-roman") {
            line.romanLyric = wordEl.innerHTML;
          }
        } else if (wordEl.hasAttribute("begin") && wordEl.hasAttribute("end")) {
          const word: LyricWord = {
            word: wordNode.textContent ?? "",
            startTime: parseTimespan(wordEl.getAttribute("begin") ?? ""),
            endTime: parseTimespan(wordEl.getAttribute("end") ?? ""),
          };
          const emptyBeat = wordEl.getAttribute("amll:empty-beat");
          if (emptyBeat) {
            word.emptyBeat = Number(emptyBeat);
          }
          line.words.push(word);
        }
      }
    }

    if (line.isBG) {
      const firstWord = line.words?.[0];
      if (firstWord?.word.startsWith("(")) {
        firstWord.word = firstWord.word.substring(1);
        if (firstWord.word.length === 0) {
          line.words.shift();
        }
      }

      const lastWord = line.words?.[line.words.length - 1];
      if (lastWord?.word.endsWith(")")) {
        lastWord.word = lastWord.word.substring(0, lastWord.word.length - 1);
        if (lastWord.word.length === 0) {
          line.words.pop();
        }
      }
    }

    const startTime = lineEl.getAttribute("begin");
    const endTime = lineEl.getAttribute("end");
    if (startTime && endTime) {
      line.startTime = parseTimespan(startTime);
      line.endTime = parseTimespan(endTime);
    } else {
      line.startTime = line.words
        .filter((v) => v.word.trim().length > 0)
        .reduce((pv, cv) => Math.min(pv, cv.startTime), Infinity);
      line.endTime = line.words
        .filter((v) => v.word.trim().length > 0)
        .reduce((pv, cv) => Math.max(pv, cv.endTime), 0);
    }

    if (haveBg) {
      const bgLine = lyricLines.pop();
      lyricLines.push(line);
      if (bgLine) lyricLines.push(bgLine);
    } else {
      lyricLines.push(line);
    }
  }

  for (const lineEl of ttmlDoc.querySelectorAll("body p[begin][end]")) {
    parseParseLine(lineEl);
  }

  return {
    metadata,
    lyricLines: lyricLines,
  };
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\player\new\lyrics\QueueView.tsx
import React from "react";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import Image from "next/image";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";

export const QueueView = () => {
  const { queue, currentIndex } = useAudioStoreNew();
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();

  // Filter queue to show only upcoming songs (after current song)
  const upcomingSongs = queue.slice(currentIndex + 1);

  if (!upcomingSongs.length) {
    return (
      <div className="h-screen w-full flex items-center justify-center">
        <p className="opacity-50 select-none">No upcoming songs in queue</p>
      </div>
    );
  }

  return (
    <div className="h-screen w-full flex flex-col">
      <div className="flex-1 overflow-y-auto">
        <h3 className="text-center text-lg font-semibold mb-4 opacity-75 mt-4">
          Up Next
        </h3>
        {upcomingSongs.map((song, index) => (
          <div
            key={`${song.id}-${index}`}
            className="flex items-center p-3 border-b border-white/10 hover:bg-white/5 transition"
          >
            <div className="w-10 h-10 relative mr-3">
              <Image
                src={song.artwork?.url || PLACEHOLDER_IMAGE}
                alt={song.name || "Song cover"}
                fill
                className="object-cover rounded-md"
              />
            </div>
            <div className="flex-1 overflow-hidden">
              <p className="font-medium text-sm truncate">{song.name}</p>
              <p className="text-xs opacity-70 truncate">{song.artist.name}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\PlaylistPlayer.tsx
"use client";
import React, { useState, useEffect } from 'react';
import ReactPlayer from 'react-player';

const fetchAudioSegments = async (links: string[]) => {
  const audioSegments = await Promise.all(
    links.map(async (link) => {
      const response = await fetch(link);
      const arrayBuffer = await response.arrayBuffer();
      return arrayBuffer;
    })
  );
  return audioSegments;
};

const combineAudioSegments = (audioSegments: ArrayBuffer[]) => {
  const combinedArrayBuffer = new Uint8Array(
    audioSegments.reduce((acc, segment) => acc + segment.byteLength, 0)
  );

  let offset = 0;
  audioSegments.forEach((segment) => {
    combinedArrayBuffer.set(new Uint8Array(segment), offset);
    offset += segment.byteLength;
  });

  return combinedArrayBuffer.buffer;
};

export const PlaylistPlayer = ({ links }: { links: string[] }) => {
  const [audioUrl, setAudioUrl] = useState<string | null>(null);

  useEffect(() => {
    const loadAndCombineAudio = async () => {
      const audioSegments = await fetchAudioSegments(links);
      const combinedAudioBuffer = combineAudioSegments(audioSegments);
      const audioBlob = new Blob([combinedAudioBuffer], { type: 'audio/mp3' });
      const audioUrl = URL.createObjectURL(audioBlob);
      setAudioUrl(audioUrl);
    };

    loadAndCombineAudio();
  }, [links]);

  return (
    <div>
      {audioUrl ? (
        <ReactPlayer
          url={audioUrl}
          playing
          controls
          width="1000px"
          height="50px"
        />
      ) : (
        <p>Loading...</p>
      )}
    </div>
  );
};

\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\skeletons\PlaylistSkeleton.tsx
import { Skeleton } from "@/components/skeletons/skeleton";
import { BackButton, SafeView } from "../mobile/SafeView";

export const PlaylistSkeleton = () => {
  return (
    <SafeView backButton className="z-10 relative">
      <div className="flex flex-col items-center justify-center gap-1 bg-blend-overlay pt-4">
        <div className="album-container album-shadow">
          {/* Album Cover Skeleton */}
          <Skeleton className="w-[235px] h-[235px] rounded-2xl" />
          <div className="album-border" />
        </div>

        <div className="flex flex-col items-center justify-center mt-2 gap-1">
          {/* Playlist Title Skeleton */}
          <Skeleton className="w-[150px] h-[20px] rounded-md" />

          {/* Artist Link Skeleton */}
          <Skeleton className="w-[100px] h-[20px] rounded-md" />

          {/* Genre, Year, Lossless Skeleton */}
          <div className="flex text-xs spacer items-center justify-center">
            <Skeleton className="w-[200px] h-[18px] rounded-md" />
          </div>
        </div>

        <div className="flex w-full justify-between items-start gap-5 pb-5 pt-2">
          {/* Play Button Skeleton */}
          <Skeleton className="flex-1 h-[3rem] rounded-2xl" />
          {/* Shuffle Button Skeleton */}
          <Skeleton className="flex-1 h-[3rem] rounded-2xl" />
        </div>
      </div>

      <ul className="music-cards">
        {/* List of Track Skeletons */}
        {Array(5)
          .fill("")
          .map((_, index) => (
            <li key={index} className="cursor-pointer flex items-center mb-2">
              {/* Track Number Skeleton */}
              <Skeleton className="w-[20px] h-[20px] rounded-full mr-4" />
              {/* Track Title Skeleton */}
              <Skeleton className="w-[200px] h-[20px] rounded-md" />
            </li>
          ))}
      </ul>
    </SafeView>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\skeletons\skeleton.tsx
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\components\theme-provider.tsx
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { type ThemeProviderProps } from "next-themes/dist/types";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\context\AudioContext.tsx
"use client";
import { create } from "zustand";
import { fetchPlaylistM3U8 } from "@/lib/utils";

interface AudioState {
  currentTrack: any | null;
  playlistUrl: string | null;
  isPlaying: boolean;
  cover: string | null;
  HDCover: string | null;
  playlist: any[];
  setCurrentTrack: (track: any | null) => void;
  setPlaylistUrl: (url: string | null) => void;
  setIsPlaying: (isPlaying: boolean) => void;
  setHDCover: (cover: string) => void;
  setGlobalPlaylist: (tracks: any[]) => void;
  playNextTrack: () => Promise<void>;
  playPreviousTrack: () => Promise<void>;
}

const useAudioStore = create<AudioState>((set, get) => ({
  currentTrack: null,
  playlistUrl: null,
  isPlaying: false,
  cover: null,
  HDCover: null,
  playlist: [],
  setCurrentTrack: (track) => set({ currentTrack: track }),
  setPlaylistUrl: (url) => set({ playlistUrl: url }),
  setIsPlaying: (isPlaying) => set({ isPlaying }),
  setHDCover: (cover) => set({ HDCover: cover }),
  setGlobalPlaylist: (tracks) => set({ playlist: tracks }),
  playNextTrack: async () => {
    const {
      playlist,
      setCurrentTrack,
      setPlaylistUrl,
      setHDCover,
      setGlobalPlaylist,
    } = get();
    if (playlist.length > 1) {
      const nextTrack = playlist[1];
      setCurrentTrack(nextTrack);
      const response = await fetch(`/api/track/info/${nextTrack.id}`);
      const nextTrackData = await response.json();
      setPlaylistUrl(await fetchPlaylistM3U8(nextTrackData.permalink_url));
      // await fetchCover(nextTrackData.permalink_url);
      setGlobalPlaylist(playlist.slice(1));
    } else {
      console.log("No more tracks in the playlist");
    }
  },

  playPreviousTrack: async () => {
    const {
      playlist,
      currentTrack,
      setCurrentTrack,
      setPlaylistUrl,
      setHDCover,
    } = get();
    if (currentTrack && playlist.length > 0) {
      const currentIndex = playlist.findIndex(
        (track) => track.id === currentTrack.id
      );
      if (currentIndex > 0) {
        const previousTrack = playlist[currentIndex - 1];
        setCurrentTrack(previousTrack);

        const response = await fetch(`/api/track/info/${previousTrack.id}`);
        const previousTrackData = await response.json();
        setPlaylistUrl(
          await fetchPlaylistM3U8(previousTrackData.permalink_url)
        );

        const fetchCover = async (query: string) => {
          const url = encodeURIComponent(query);
          const response = await fetch(`/api/extra/cover/${url}`);
          const data = await response.json();
          setHDCover(data.imageUrl);
        };
        await fetchCover(previousTrackData.permalink_url);
      } else {
        console.log("Reached the beginning of the playlist");
      }
    } else {
      console.log("No current track or empty playlist");
    }
  },
}));

export default useAudioStore;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\context\AudioContextNew.tsx
import { create } from "zustand";
import { Song } from "@/lib/audio/types";
import { fetchM3U8ForSong, fetchSongData } from "@/lib/audio/fetchers";
import React from "react";
import ReactPlayer from "react-player";

interface AudioStateNew {
  currentSong: Song | null;
  currentIndex: number;
  queue: Song[];
  isPlaying: boolean;
  playerRef: React.RefObject<ReactPlayer> | null;

  currentTime: number;
  duration: number;
  volume: number;

  fineProgress: number;
  rafId: number | null;

  setQueue: (songs: Song[]) => Promise<void>;
  addToQueue: (songs: Song[]) => void;
  playSongAtIndex: (index: number) => Promise<void>;
  nextSong: () => Promise<void>;
  previousSong: () => Promise<void>;
  setIsPlaying: (playing: boolean) => void;
  prefetchNextN: (n: number) => Promise<void>;
  setPlayerRef: (ref: React.RefObject<ReactPlayer>) => void;
  setAnimatedURL: (url: string) => void;

  setDuration: (duration: number) => void;
  setCurrentTime: (time: number) => void;
  seek: (time: number) => void;
  setVolume: (volume: number) => void;

  startFineProgressUpdates: () => void;
  stopFineProgressUpdates: () => void;

  isFullscreen: boolean;
  setFullscreen: (fullscreen: boolean) => void;
}

const PREFETCH_COUNT = 2;

export const useAudioStoreNew = create<AudioStateNew>((set, get) => ({
  currentSong: null,
  currentIndex: -1,
  queue: [],
  isPlaying: false,
  playerRef: null,

  currentTime: 0,
  duration: 0,
  volume: 0.15,
  fineProgress: 0,
  rafId: null,

  setIsPlaying: (playing) => {
    set({ isPlaying: playing });
    if (playing) {
      get().startFineProgressUpdates();
    } else {
      get().stopFineProgressUpdates();
    }
  },

  setPlayerRef: (ref) => set({ playerRef: ref }),

  setQueue: async (songs: Song[]) => {
    set({ queue: songs, currentIndex: 0 });
    await get().playSongAtIndex(0);
  },

  addToQueue: (songs: Song[]) => {
    const { queue } = get();
    set({ queue: [...queue, ...songs] });
  },

  playSongAtIndex: async (index: number) => {
    const { queue } = get();
    if (index < 0 || index >= queue.length) {
      console.warn("Invalid index for playSongAtIndex");
      return;
    }

    let selectedSong = queue[index];

    // Use the new consolidated function
    const { HDCover, M3U8url } = await fetchSongData(selectedSong);

    // Update song with fetched data
    selectedSong = {
      ...selectedSong,
      artwork: { ...selectedSong.artwork, hdUrl: HDCover },
      src: M3U8url,
    };

    const newQueue = [...queue];
    newQueue[index] = selectedSong;
    set({
      currentSong: selectedSong,
      currentIndex: index,
      queue: newQueue,
      isPlaying: true,
    });

    await get().prefetchNextN(PREFETCH_COUNT);
    get().startFineProgressUpdates();
  },

  nextSong: async () => {
    const { currentIndex, queue, playSongAtIndex, setIsPlaying } = get();
    const nextIndex = currentIndex + 1;
    if (nextIndex >= queue.length) {
      console.log("No more songs in the queue.");
      setIsPlaying(false);
      return;
    }
    await playSongAtIndex(nextIndex);
  },

  previousSong: async () => {
    const { currentIndex, playSongAtIndex, playerRef } = get();
    if (!playerRef || !playerRef.current) {
      console.warn("No playerRef is set. Cannot determine current time.");
      return;
    }

    const currentTime = playerRef.current.getCurrentTime();
    if (currentTime > 3) {
      playerRef.current.seekTo(0);
      set({ currentTime: 0, fineProgress: 0 });
    } else {
      const prevIndex = currentIndex - 1;
      if (prevIndex < 0) {
        console.log("Already at the start of the queue.");
        return;
      }
      await playSongAtIndex(prevIndex);
    }
  },

  prefetchNextN: async (n: number) => {
    const { queue, currentIndex } = get();
    const end = Math.min(currentIndex + n + 1, queue.length);
    const fetchPromises = [];
    for (let i = currentIndex + 1; i < end; i++) {
      const song = queue[i];
      if (!song.src) {
        const promise = fetchM3U8ForSong(song)
          .then((M3U8url) => {
            const newQueue = [...get().queue];
            newQueue[i] = { ...song, src: M3U8url };
            set({ queue: newQueue });
          })
          .catch((err) => {
            console.error(`Failed to prefetch M3U8 for ${song.name}:`, err);
          });
        fetchPromises.push(promise);
      }
    }
    await Promise.all(fetchPromises);
  },

  setDuration: (duration: number) => set({ duration }),
  setCurrentTime: (time: number) =>
    set({ currentTime: time, fineProgress: time }),
  seek: (time: number) => {
    const { playerRef } = get();
    if (playerRef && playerRef.current) {
      playerRef.current.seekTo(time);
      set({ currentTime: time, fineProgress: time });
    }
  },

  setVolume: (volume: number) => {
    set({ volume });
  },

  setAnimatedURL: (url: string) => {
    const { currentSong } = get();
    if (currentSong) {
      set({
        currentSong: {
          ...currentSong,
          artwork: {
            ...currentSong.artwork,
            animatedURL: url,
          },
        },
      });
    }
  },

  startFineProgressUpdates: () => {
    const { rafId, playerRef, isPlaying } = get();
    if (isPlaying && playerRef && playerRef.current && rafId === null) {
      const update = () => {
        const { playerRef, isPlaying } = get();
        if (!isPlaying || !playerRef?.current) {
          get().stopFineProgressUpdates();
          return;
        }
        const currentTime = playerRef.current.getCurrentTime();
        set({ currentTime: currentTime, fineProgress: currentTime });
        const newRafId = requestAnimationFrame(update);
        set({ rafId: newRafId });
      };
      const newRafId = requestAnimationFrame(update);
      set({ rafId: newRafId });
    }
  },

  stopFineProgressUpdates: () => {
    const { rafId } = get();
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      set({ rafId: null });
    }
  },

  isFullscreen: false,
  setFullscreen: (fullscreen: boolean) => set({ isFullscreen: fullscreen }),
}));


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useIsPWA.ts
"use client";
import { useEffect, useState } from "react";

export const useIsPWA = () => {
  const [isPWA, setIsPWA] = useState(false);

  useEffect(() => {
    if (typeof window !== "undefined") {
      const isStandalone =
        window.matchMedia("(display-mode: standalone)").matches ||
        (window.navigator as any).standalone === true;

      setIsPWA(isStandalone);
    }
  }, []);

  return isPWA;
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useLibrary.ts
import { useState, useEffect } from "react";
import { generateLibraryKey } from "../lib/utils/libraryKey";

interface Song {
  id: string;
  title: string;
  artist: string;
  addedAt: string;
}

interface LibraryData {
  key: string;
  name?: string;
  songs: Song[];
}

export function useLibrary() {
  const [library, setLibrary] = useState<LibraryData | null>(null);
  const [globalLibraryKey, setGlobalLibraryKey] = useState<string | null>(null);

  useEffect(() => {
    const storedKey = localStorage.getItem("GAKU_libraryKey");
    if (storedKey) {
      setGlobalLibraryKey(storedKey);
      fetchLibrary(storedKey);
    }
  }, []);

  const fetchLibrary = async (key: string) => {
    try {
      const response = await fetch(`/api/library/sync?key=${key}`);
      if (response.ok) {
        const data = await response.json();
        setLibrary(data);
      }
    } catch (error) {
      console.error("Error fetching library:", error);
    }
  };

  const createLibrary = () => {
    const newKey = generateLibraryKey();
    localStorage.setItem("GAKU_libraryKey", newKey);
    setGlobalLibraryKey(newKey);
    const newLibrary: LibraryData = {
      key: newKey,
      songs: [],
    };
    syncLibraryWithDatabase(newLibrary);
    setLibrary(newLibrary);
  };

  const updateLibraryName = (key: string, name: string) => {
    if (library && library.key === key) {
      const updatedLibrary = { ...library, name };
      setLibrary(updatedLibrary);
      syncLibraryWithDatabase(updatedLibrary);
    } else {
      console.error("Library not found for the given key.");
    }
  };

  const addSong = (song: Omit<Song, "addedAt">) => {
    if (library) {
      const updatedLibrary = {
        ...library,
        songs: [
          { ...song, addedAt: new Date().toISOString() },
          ...library.songs,
        ],
      };
      setLibrary(updatedLibrary);
      syncLibraryWithDatabase(updatedLibrary);
    } else {
      console.error("Failed to add song: Library not found.");
    }
  };

  const removeSong = (songId: string) => {
    if (library) {
      const updatedLibrary = {
        ...library,
        songs: library.songs.filter((song) => song.id !== songId),
      };
      setLibrary(updatedLibrary);
      syncLibraryWithDatabase(updatedLibrary);
    } else {
      console.error("Failed to remove song: Library not found.");
    }
  };

  const handleLikeToggle = (title: any, artist: any) => {
    const songId = `${title}-${artist}`;
    if (isSongInLibrary(songId)) {
      removeSong(songId);
    } else {
      addSong({
        id: songId,
        title: title,
        artist: artist,
      });
    }
  };

  const isSongInLibrary = (songId: string): boolean => {
    return library?.songs.some((song) => song.id === songId) || false;
  };

  const importLibrary = async (key: string) => {
    try {
      const response = await fetch(`/api/library/sync?key=${key}`);
      if (response.ok) {
        const data = await response.json();
        setLibrary(data);
        localStorage.setItem("GAKU_libraryKey", key);
        setGlobalLibraryKey(key);
        return data;
      } else if (response.status === 404) {
        return { error: "Library not found" };
      } else {
        throw new Error("Failed to import library");
      }
    } catch (error) {
      console.error("Error importing library:", error);
      return { error: "Error importing library" };
    }
  };

  const syncLibraryWithDatabase = async (library: LibraryData) => {
    try {
      const response = await fetch("/api/library/sync", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(library),
      });
      if (!response.ok) {
        throw new Error("Failed to sync library with database");
      }
    } catch (error) {
      console.error("Error syncing library with database:", error);
    }
  };

  return {
    library,
    setLibrary,
    createLibrary,
    updateLibraryName,
    addSong,
    removeSong,
    importLibrary,
    isSongInLibrary,
    handleLikeToggle,
    globalLibraryKey,
  };
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useMediaQuery.ts
import { useState, useEffect } from "react";

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    media.addListener(listener);
    return () => media.removeListener(listener);
  }, [matches, query]);

  return matches;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useSearch.ts
import { useState, useEffect } from "react";
import { SoundCloudSearchResult } from "@/lib/types/soundcloud";

type SoundCloudCollection = SoundCloudSearchResult;

function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default function useSearch(defaultValue: string) {
  const [query, setQuery] = useState(defaultValue);
  const [results, setResults] = useState<SoundCloudCollection>();
  const [showDropdown, setShowDropdown] = useState(false);

  // Debounce the raw `query`
  const debouncedQuery = useDebounce(query, 10);

  const handleInputChange = (newQuery: string) => {
    setQuery(newQuery);
    setShowDropdown(true);
  };

  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults(undefined);
      return;
    }

    const fetchResults = async () => {
      try {
        const res = await fetch(
          `/api/soundcloud/search?q=${encodeURIComponent(debouncedQuery)}`
        );
        if (!res.ok) {
          throw new Error(`Request failed with status ${res.status}`);
        }
        const data: SoundCloudSearchResult = await res.json();
        setResults(data);
      } catch (error) {
        console.error("Search request error:", error);
        setResults(undefined);
      }
    };

    fetchResults();
  }, [debouncedQuery]);

  return {
    query,
    results,
    showDropdown,
    handleInputChange,
    setShowDropdown,
  };
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useSongData.ts
import { QueryClient, useQuery } from "@tanstack/react-query";
import { SoundCloudKit } from "@/lib/audio/fetchers";

export function useSongData(songId: string) {
  return useQuery({
    queryKey: ["songData", songId],
    queryFn: () => SoundCloudKit.getData(songId, "songs"),
    enabled: !!songId,
    staleTime: 60 * 60 * 1000,
  });
}

const queryClient = new QueryClient();

export async function prefetchSongData(songId: string) {
  await queryClient.prefetchQuery({
    queryKey: ["songData", songId],
    queryFn: () => SoundCloudKit.getData(songId, "songs"),
  });
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useStreamUrl.ts
import { useQuery } from "@tanstack/react-query";

export function useStreamUrl(trackId: number) {
  return useQuery({
    queryKey: ["streamUrl", trackId],
    queryFn: async () => {
      const response = await fetch(`/api/streams/${trackId}`);
      if (!response.ok) throw new Error("Failed to fetch streaming URL");
      const data = await response.json();
      return data.url as string;
    },
    staleTime: 4 * 60 * 1000, // Consider the URL stale after 4 minutes
    refetchInterval: 4 * 60 * 1000, // Automatically refetch every 4 minutes
    enabled: !!trackId,
  });
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useToast.ts
import { toast } from "react-hot-toast";

// 1. Overload signatures:
export function showToast(type: "success" | "error", message: string): void;
export function showToast(
  type: "warning",
  message: string,
  warningIcon?: string
): void;
export function showToast(type: "loading" | "info", message: string): void;

// 2. Single implementation that covers both:
export function showToast(
  type: "success" | "error" | "warning" | "loading" | "info",
  message: string,
  warningIcon?: string
): void {
  const duration = 3500;
  switch (type) {
    case "success":
      toast.success(message, { duration });
      break;
    case "error":
      toast.error(message, { duration });
      break;
    case "loading":
      toast.loading(message, { duration });
      break;
    case "info":
      toast(message, { duration });
      break;
    case "warning":
      toast(message, { icon: warningIcon || "⚠️", duration });
      break;
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\hooks\useUser.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import { showToast } from "./useToast";

// Define the type for a song
interface Song {
  id: string;
  createdAt: string;
  updatedAt: string;
}

interface UserSettings {
  createdAt: Date;
  highlightedQueries: boolean;
  id: string;
  showSidebarIcons: boolean;
  themeColor: string;
  updatedAt: Date;
  userId: string;
  soundcloudUserId: string;
}

// Define the type for the library songs
type LibrarySongs = Song[];

export const useUser = () => {
  const queryClient = useQueryClient();

  // Fetch the user's library songs
  const { data, isLoading, error } = useQuery<LibrarySongs>({
    queryKey: ["librarySongs"],
    queryFn: async () => {
      const response = await axios.get("/api/user/songs");
      return response.data;
    },
  });

  // Add a song to the user's library
  const { mutate: addSong } = useMutation({
    mutationFn: async (soundcloudId: string) => {
      const response = await axios.post("/api/user/songs", { soundcloudId });
      return response.data;
    },
    onSuccess: () => {
      // Invalidate the librarySongs query to refetch the updated list
      queryClient.invalidateQueries({ queryKey: ["librarySongs"] });
    },
    onError: () => {
      showToast("error", `Failed to add song`);
    },
  });

  // Remove a song from the user's library
  const { mutate: removeSong } = useMutation({
    mutationFn: async (soundcloudId: string) => {
      const response = await axios.delete("/api/user/songs", {
        data: { soundcloudId },
      });
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["librarySongs"] });
    },
    onError: () => {
      showToast("error", `Failed to remove song`);
    },
  });

  const settings = useQuery<UserSettings>({
    queryKey: ["userSettings"],
    queryFn: async () => {
      const response = await axios.get("/api/user/settings");
      return response.data;
    },
  });

  return {
    settings: settings.data,
    librarySongs: data, // Array of songs or undefined if not loaded
    isLoading, // Boolean indicating loading state
    error, // Any error from fetching songs
    addSongToLibrary: addSong, // Function to add a song
    removeSongFromLibrary: removeSong, // Function to remove a song
  };
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\artist.ts
export const artistMappings: Record<string, string> = {
  "octobersveryown": "Drake",
  "Ken Car$on": "Ken Carson",
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\audio\fetchers.ts
import { artistMappings } from "../artist";
import { Song } from "./types";
import { fetchPlaylistM3U8, dev } from "@/lib/utils";
import { EditorialVideo } from "../types/apple";
import { showToast } from "@/hooks/useToast";
import toast from "react-hot-toast";
import { get } from "http";

/**
 * Fetch additional metadata (like HD cover) for a given song, without fetching M3U8.
 */
export async function fetchSongMedia(song: Song): Promise<{ HDCover: string }> {
  try {
    dev.log("fetchSongMedia", song);
    const trackInfoResponse = await fetch(`/api/track/info/${song.id}`);
    if (!trackInfoResponse.ok) {
      console.error(`Failed to fetch track info for song ID ${song.id}`);
      return { HDCover: song.artwork.url ?? "" };
    }

    const trackInfo = await trackInfoResponse.json();
    const HDCover = await getHDCover(trackInfo.permalink_url);

    return { HDCover: HDCover ?? song.artwork.url };
  } catch (error) {
    console.error("Error fetching song media:", error);
    return { HDCover: song.artwork.url ?? "" };
  }
}

/**
 * Fetch just the M3U8 URL for a given song.
 * This is separated so we can control when to fetch M3U8.
 */
export async function fetchM3U8ForSong(song: Song): Promise<string> {
  try {
    dev.log(`fetchM3U8ForSong | ${song.name} |`, song);
    const trackInfoResponse = await fetch(`/api/track/info/${song.id}`);
    if (!trackInfoResponse.ok) {
      console.error(
        `Failed to fetch track info for M3U8 on song ID ${song.id}`
      );
      return "";
    }

    const trackInfo = await trackInfoResponse.json();
    return await fetchPlaylistM3U8(trackInfo.permalink_url);
  } catch (error) {
    console.error("Error fetching M3U8 URL:", error);
    return "";
  }
}

/**
 * Given a SoundCloud URL, returns either a single Song or a set of initial Songs plus
 * a function to load the remaining playlist tracks.
 * If the URL is a playlist (contains "/sets/"), it loads incrementally.
 * Otherwise, it returns a single song.
 */
export async function mapSCDataToSongOrPlaylist(
  url: string,
  initialCount = 3,
  isID?: boolean
): Promise<{ initialSongs: Song[]; loadRemaining: () => Promise<Song[]> }> {
  try {
    dev.log("mapSCDataToSongOrPlaylist | url:", url, "isID:", isID);
    if (!isID && url.includes("/sets/")) {
      return await mapPlaylistUrlToSongsIncrementally(url, initialCount);
    } else {
      const track = await mapTrackUrlToSong(url, isID ? true : false);
      return { initialSongs: [track], loadRemaining: async () => [] };
    }
  } catch (error) {
    console.error("Error mapping URL to Song or Playlist:", error);
    // Return empty data on error
    return { initialSongs: [], loadRemaining: async () => [] };
  }
}

/**
 * Converts a single track URL to a Song object without fetching M3U8.
 */
async function mapTrackUrlToSong(url: string, isID: boolean): Promise<Song> {
  try {
    dev.log("mapTrackUrlToSong | url:", url, "isID:", isID);
    const trackId = Number(url);
    const response = await fetch(`/api/track/info/${trackId}`);
    if (!response.ok) {
      console.error(
        `mapTrackUrlToSong | Failed to fetch track info for ID ${trackId}`
      );
      return createEmptySong(trackId);
    }
    const data = await response.json();
    console.log("mapTrackUrlToSong data", data);
    const HDCover = await getHDCover(data.permalink_url);

    if (window.location.pathname.includes("/album/")) {
      const albumID = window.location.pathname.includes("/album/")
        ? window.location.pathname.split("/").pop()
        : data.publisher_metadata?.album_id || 222;
      const fetchedAlbumName = await SoundCloudKit.getData(albumID, "albums");
      const albumName =
        data.publisher_metadata?.album_title || fetchedAlbumName.title;
      const appleKitCover = await AppleKit.getMediaData(
        albumName,
        data.publisher_metadata.artist || data.user?.username,
        "albums"
      );
      dev.log("appleKitCover", appleKitCover);
      const animatedURL = (
        appleKitCover?.data[0]?.attributes?.editorialVideo as EditorialVideo
      )?.motionSquareVideo1x1?.video;
      return {
        albumName: albumName,
        artist: {
          id: data.user?.id || -1,
          name: data.user?.username || "",
          url: `/artist/${data.user?.permalink}/${data.user?.id}`,
          soundcloudURL: data.user?.permalink_url || "",
          permalink: data.user?.permalink || "",
          verified: false,
          followers: 0,
          city: "",
          avatar: data.user?.avatar_url || "",
        },
        artwork: {
          hdUrl: HDCover,
          url: data.artwork_url,
          animatedURL: animatedURL,
        },
        id: data.id,
        songHref: data.permalink_url,
        name: data.title,
        explicit: data.publisher_metadata?.explicit || false,
        src: "",
      };
    }

    return {
      albumName: data.publisher_metadata?.album_title || "",
      artist: {
        id: data.user?.id || -1,
        name: data.user?.username || "",
        url: `/artist/${data.user?.permalink}/${data.user?.id}`,
        soundcloudURL: data.user?.permalink_url || "",
        permalink: data.user?.permalink || "",
        verified: false,
        followers: 0,
        city: "",
        avatar: data.user?.avatar_url || "",
      },
      artwork: {
        hdUrl: HDCover,
        url: data.artwork_url,
      },
      id: data.id,
      songHref: data.permalink_url,
      name: data.title,
      explicit: data.publisher_metadata?.explicit || false,
      src: "",
    };
  } catch (error) {
    console.error(
      "mapTrackUrlToSong | Error mapping track URL to song:",
      error
    );
    return createEmptySong(-1); // Use a default number for unknown ID
  }
}

/**
 * Load a playlist incrementally:
 * - initialSongs: First `initialCount` songs
 * - loadRemaining: A function to load remaining songs later
 */
async function mapPlaylistUrlToSongsIncrementally(
  url: string,
  initialCount: number
): Promise<{ initialSongs: Song[]; loadRemaining: () => Promise<Song[]> }> {
  try {
    dev.log("mapPlaylistUrlToSongsIncrementally", url);
    const playlistId = await getIDFromURL(url);
    const response = await fetch(`/api/playlist/${playlistId}`);
    if (!response.ok) {
      console.error(`Failed to fetch playlist with ID ${playlistId}`);
      return { initialSongs: [], loadRemaining: async () => [] };
    }

    const playlistData = await response.json();
    const tracks = playlistData.tracks || [];
    const initialTracks = tracks.slice(0, initialCount);
    const initialSongs = await mapTracksToSongs(initialTracks);

    const loadRemaining = async (): Promise<Song[]> => {
      const remainingTracks = tracks.slice(initialCount);
      return await mapTracksToSongs(remainingTracks);
    };

    return { initialSongs, loadRemaining };
  } catch (error) {
    console.error("Error mapping playlist URL to songs incrementally:", error);
    return { initialSongs: [], loadRemaining: async () => [] };
  }
}

/**
 * Maps an array of track objects to Song objects without fetching M3U8.
 */
async function mapTracksToSongs(tracks: any[]): Promise<Song[]> {
  dev.log("mapTracksToSongs", tracks);
  const songs: Song[] = [];
  for (const track of tracks) {
    try {
      // const HDCover = await getHDCover(track.permalink_url);
      const HDCover = await getHDCover(track.permalink_url, true); // Using local method to get HD cover
      const song: Song = {
        albumName: track.publisher_metadata?.album_title || "",
        artist: {
          id: track.user.id,
          name: track.user.username,
          url: `/artist/${track.user.permalink}/${track.user.id}`,
          soundcloudURL: track.user.permalink_url,
          permalink: track.user.permalink,
          verified: false,
          followers: 0,
          city: "",
          avatar: track.user.avatar_url,
        },
        artwork: {
          hdUrl: HDCover,
          url: track.artwork_url,
          animatedURL: "",
        },
        id: track.id,
        songHref: track.permalink_url,
        name: track.title,
        explicit: track.publisher_metadata.explicit || false,
        src: "", // M3U8 fetched later in the store
      };
      songs.push(song);
    } catch (error) {
      console.error("Error mapping track to song:", error);
      // Insert a fallback empty song or skip
      // Skipping might be better so you don't end up with a broken track
    }
  }
  return songs;
}

/**
 * Fetches the HD cover image given a track/playlist permalink URL.
 */
export async function getHDCover(url: string, local: boolean): Promise<string> {
  if (local) {
    return url.replace("large", "t500x500");
  }
  dev.log("getHDCover", url);
  try {
    const response = await fetch(`/api/extra/cover/${encodeURIComponent(url)}`);
    if (!response.ok) {
      console.warn(`Failed to fetch HD cover for ${url}`);
      return "";
    }

    const data = await response.json();
    return data.imageUrl || "";
  } catch (error) {
    console.error("Error fetching HD cover:", error);
    return "";
  }
}

/**
 * Given a SoundCloud track or playlist URL, returns its ID.
 * Ensure the `/api/soundcloud/getid/[url]` endpoint can handle both single tracks and playlists.
 */
export async function getIDFromURL(url: string): Promise<number> {
  try {
    dev.log("getIDFromURL", url);
    const response = await fetch(
      `/api/soundcloud/getid/${encodeURIComponent(url)}`
    );
    if (!response.ok) {
      console.warn(`Failed to get ID from URL: ${url}`);
      return -1;
    }
    const data = await response.json();
    return data.trackId;
  } catch (error) {
    console.error("Error getting ID from URL:", error);
    return -1;
  }
}

export async function getURLFromID(id: string) {
  dev.log("getURLFromID", id);
  try {
    const response = await fetch(`/api/track/info/${id}`);
    if (!response.ok) {
      console.error(`Failed to get URL from ID: ${id}`);
      return "";
    }
    const data = await response.json();
    console.log("getURLFromID data", data);
    return data.permalink_url;
  } catch (error) {
    console.error("Error getting URL from ID:", error);
    return "";
  }
}

/**
 * Creates a minimal Song object with default values, useful for error fallback.
 */
function createEmptySong(id: number): Song {
  dev.log("createEmptySong", id);
  return {
    albumName: "",
    artist: {
      id: -1,
      name: "Unknown Artist",
      url: "",
      soundcloudURL: "",
      permalink: "",
      verified: false,
      followers: 0,
      city: "",
      avatar: "",
    },
    artwork: {
      hdUrl: "",
      url: "",
      animatedURL: "",
    },
    id,
    songHref: "",
    name: "Unknown Track",
    explicit: false,
    src: "",
  };
}

export async function fetchSongData(
  song: Song
): Promise<{ HDCover: string; M3U8url: string }> {
  try {
    dev.log("fetchSongData", song);
    const trackInfoResponse = await fetch(`/api/track/info/${song.id}`);
    if (!trackInfoResponse.ok) throw new Error("Failed to fetch track info");

    const trackInfo = await trackInfoResponse.json();

    const HDCover = await getHDCover(trackInfo.permalink_url);
    const M3U8url = await fetchPlaylistM3U8(trackInfo.permalink_url);

    return { HDCover: HDCover ?? song.artwork.url, M3U8url };
  } catch (error) {
    console.error("Error fetching song data:", error);
    return { HDCover: song.artwork.url ?? "", M3U8url: "" };
  }
}

export const AppleKit = {
  /**
   * Fetch Apple Lyrics for a song.
   */
  async getLyrics(
    title: string,
    artist: string,
    file: boolean = false
  ): Promise<string> {
    try {
      const cleanedTitle = title.split("(")[0].trim();
      let cleanedArtist = artist;
      cleanedArtist = artistMappings[cleanedArtist] || cleanedArtist;
      cleanedArtist = cleanedArtist
        .replace(/&|feat\.|featuring/gi, "")
        .split(/[(),]/)
        .map((s) => s.trim())
        .filter(Boolean)
        .join("+");

      const query = `${cleanedTitle.replace(/ /g, "+")}+${cleanedArtist}`;
      const response = await fetch(`/api/apple/lyrics/${query}`);

      if (!response.ok) {
        console.error(`Failed to get ID from URL: ${query}`);
        return "";
      }

      const data = await response.json();
      const formatTTMLResponse = (data: any) => {
        if (typeof data === "string") {
          return data.replace(/\\/g, "");
        }
        return data;
      };

      if (file) {
        return formatTTMLResponse(data.data[0].attributes.ttml);
      }

      return data;
    } catch (error) {
      console.error("Error getting Apple lyrics:", error);
      return "";
    }
  },

  /**
   * Fetch Apple Data.
   */
  async getMediaData(
    title: string,
    artist: string,
    type: "albums" | "songs"
  ): Promise<any> {
    try {
      const cleanedTitle = title;
      let cleanedArtist = artist;
      if (cleanedArtist.toLowerCase() === "octobersveryown") {
        cleanedArtist = "Drake";
      } else {
        cleanedArtist = cleanedArtist
          .replace(/&|feat\.|featuring/gi, "")
          .split(/[(),]/)
          .map((s) => s.trim())
          .filter(Boolean)
          .join("+");
      }
      const query = `${cleanedTitle.replace(/ /g, "+")}+${cleanedArtist}`;
      const response = await fetch(`/api/apple/song/${query}?type=${type}`);
      dev.log(`AppleKit | ${title} | Response: `, response);
      if (!response.ok) {
        console.error(
          `Response not OK | Failed to get data from AppleKit: ${query}`
        );
        return "";
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error getting Apple data:", error);
      return "";
    }
  },

  /**
   * Fetch Artist Data.
   */
  async getArtistData(artist: string): Promise<any> {
    try {
      const query = artist.replace(/ /g, "+");
      const response = await fetch(`/api/apple/artist/${query}`);
      dev.log("AppleKit | Artist | Query: ", query);
      if (!response.ok) {
        dev.error(`Failed to get data for artist ${query} from AppleKit`);
        showToast(
          "error",
          "Failed to get data for artist ${query} from AppleKit"
        );
        return "";
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error getting Apple data:", error);
      return "";
    }
  },
};

/**
 * Interact with Gaku's SoundCloud API.
 */
export const SoundCloudKit = {
  /**
   * Fetch SoundCloud Data for a song or album.
   */
  async getData(
    id: string | number,
    type: "albums" | "songs" | "playlists" | "artist",
    options?: {
      include?: string | string[]; // updated to allow multiple includes
    }
  ): Promise<any> {
    try {
      // Build query
      const queryParams = new URLSearchParams();
      queryParams.set("type", type);

      if (options?.include) {
        // If it's an array, join with commas; otherwise use as-is
        const includeValue = Array.isArray(options.include)
          ? options.include.join(",")
          : options.include;
        queryParams.set("include", includeValue);
      }

      // Now we have something like ?type=artist&include=spotlight,latest
      const response = await fetch(`/api/soundcloud/${id}?${queryParams}`);
      if (!response.ok) {
        console.error(
          `SoundCloudKit | getData | Response not OK | Failed to get data from SoundCloudKit: ${id}`
        );
        return "";
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("SoundCloudKit | getData | Error fetching data:", error);
      return "";
    }
  },
  async findUserByPermalink(permalink: string) {
    try {
      // You may need to create your own Next API route that calls SoundCloud "resolve" or "search" endpoints
      const response = await fetch(
        `/api/soundcloud/resolve?permalink=${permalink}`
      );
      if (!response.ok) {
        return null;
      }
      const userData = await response.json();
      return userData; // expected to contain .id
    } catch (err) {
      console.error("findUserByPermalink error", err);
      return null;
    }
  },
  /**
   * Fetch SoundCloud home page sections.
   */
  async getHomeSections() {
    const response = await fetch(`/api/soundcloud/home/section`);
    if (!response.ok) {
      throw new Error(`Failed to fetch home page | ${response.status}`);
    }
    return response.json();
  },
  async getUserData(userId: string) {
    try {
      const response = await fetch(
        `/api/soundcloud/user?profileUrl=${userId}&type=id`
      );
      if (!response.ok) {
        return null;
      }
      const userData = await response.json();
      return userData;
    } catch (err) {
      toast.error("Error fetching user data");
      console.error("getUserData error", err);
      return null;
    }
  },
  /**
   * Get HD version of the current image.
   */
  getHD(url: string) {
    return url.replace("large", "t500x500");
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\audio\play.ts
import { useCallback } from "react";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { getURLFromID, mapSCDataToSongOrPlaylist } from "./fetchers";
import { dev } from "../utils";

const shuffleArray = <T>(array: T[]): T[] => {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

export const usePlaylistFetcher = () => {
  const { setQueue, addToQueue } = useAudioStoreNew();
  const handleFetchPlaylist = useCallback(
    async (url: any, isID?: boolean) => {
      if (!url) return;
      const { initialSongs, loadRemaining } = await mapSCDataToSongOrPlaylist(
        url,
        3,
        isID ? true : false
      );
      await setQueue(initialSongs);
      const remainingSongs = await loadRemaining();
      addToQueue(remainingSongs);
    },
    [setQueue, addToQueue]
  );
  const shufflePlaylist = useCallback(
    async (url: any, id?: boolean) => {
      if (!url) return;
      let allSongs = [];
      if (id) {
        dev.log("shufflePlaylist | Fetching URL from ID " + url + id);
        const resolvedUrl = await getURLFromID(url);
        url = resolvedUrl;
      }
      const { initialSongs, loadRemaining } = await mapSCDataToSongOrPlaylist(
        url
      );
      allSongs = [...initialSongs];
      const remainingSongs = await loadRemaining();
      allSongs = [...allSongs, ...remainingSongs];
      if (allSongs.length === 0) {
        dev.warn("shufflePlaylist | No songs found in the playlist.");
        return;
      }
      // Shuffle all songs
      const shuffledSongs = shuffleArray(allSongs);
      // Set the shuffled playlist in the queue
      await setQueue(shuffledSongs);
    },
    [setQueue]
  );
  return { handleFetchPlaylist, shufflePlaylist };
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\audio\types.ts
export interface Song {
  albumName: string;
  // artistId: number;
  // artistName: string;
  // artistUrl: string;
  artist: {
    id: number;
    name: string;
    url: string;
    soundcloudURL: string;
    permalink: string;
    verified: boolean;
    followers: number;
    city: string;
    avatar: string;
  };
  artwork: Artwork;
  contentRating?: string;
  discNumber?: number;
  id: number;
  songHref: string;
  name: string;
  color?: string[];
  explicit?: boolean;
  releaseDate?: string;
  src: string;
}

export interface Album {
  artistName: string;
  artwork: Artwork;
  releaseDate?: string;
  genre?: string;
  name: string;
  kind: "album";
  trackCount: number;
  id: number | string;
  relationships?: {
    tracks: Tracks[];
  };
}

export interface Artwork {
  animatedURL?: string;
  hdUrl: string | undefined;
  url: string | undefined;
  width?: number;
  height?: number;
}

export interface Tracks {
  data: Song[];
  href: string;
  total: number;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\config.ts
export interface Config {
  APP_NAME: string;
  SOUNDCLOUD: {
    CLIENT_ID: string;
    API_KEY: string;
  };
  APPLE: {
    MUSIC: {
      AUTH: string;
      USER_TOKEN: string;
    };
  };
  DISCOGS: {
    APIKEY: string;
  };
}

export function conf(): Config {
  return {
    APP_NAME: "Gaku",
    APPLE: {
      MUSIC: {
        AUTH: process.env.APPLE_AUTH || "",
        USER_TOKEN: process.env.APPLE_MEDIA_USER_TOKEN || "",
      },
    },
    SOUNDCLOUD: {
      CLIENT_ID: process.env.SOUNDCLOUD_CLIENT_ID || "",
      API_KEY: process.env.SOUNDCLOUD_API_KEY || "",
    },
    DISCOGS: {
      APIKEY: process.env.DISCOGS_APIKEY || "",
    },
  };
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\constants.ts
export const SEARCH_PAGE = {
  SMALL: {
    LIMIT: 3,
    OFFSET: 0,
  },
  LARGE: {
    LIMIT: 3,
    OFFSET: 0,
  },
  FULL: {
    LIMIT: 20,
    OFFSET: 0,
  },
};

export const SEARCH_PAGE_QUERY_OFFSET = 0;

export const PLACEHOLDER_IMAGE = {
  dark: {
    url: "/assets/placeholders/missing_song_dark.png",
  },
  light: {
    url: "/assets/placeholders/missing_song_light.png",
  },
  alt: "Missing song artwork",
};

export const USER = {
  name: "nite",
  settings: {
    theme: "dark",
    search: {
      highlightedQueries: false,
    },
    sidebar: {
      showIcons: false,
    },
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\prisma.ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default prisma;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\supabase.ts
import { auth } from "@clerk/nextjs/server";
import { createClient } from "@supabase/supabase-js";

const supabase = async () => {
  const { getToken } = await auth();
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!key || !url) {
    throw new Error("No Supabase Key or URL found");
  }
  return createClient(url, key, {
    global: {
      fetch: async (url, options) => {
        const token = await getToken({ template: "supabase" });
        const headers = new Headers(options?.headers);
        headers.set("Authorization", `Bearer ${token}`);
        return fetch(url, { ...options, headers });
      },
    },
  });
};

export default supabase;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\types\apple.ts
export interface EditorialVideoFrame {
  width: number;
  height: number;
  url: string;
  textColor1?: string;
  textColor2: string;
  textColor3: string;
  textColor4?: string;
  bgColor?: string;
  hasP3?: boolean;
}

export interface EditorialVideoSection {
  previewFrame: EditorialVideoFrame;
  video: string;
}

export interface EditorialVideo {
  motionDetailSquare: EditorialVideoSection;
  motionDetailTall: EditorialVideoSection;
  motionSquareVideo1x1: EditorialVideoSection;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\types\soundcloud.ts
export interface SoundCloudArtist {
  avatar_url: string;
  city: string;
  comments_count: number;
  country_code: string | null;
  created_at: string;
  creator_subscriptions: {
    product: {
      id: string;
    };
  }[];
  creator_subscription: {
    product: {
      id: string;
    };
  };
  description: string;
  followers_count: number;
  followings_count: number;
  first_name: string;
  full_name: string;
  groups_count: number;
  id: number;
  kind: string;
  last_modified: string;
  last_name: string;
  likes_count: number;
  playlist_likes_count: number;
  permalink: string;
  permalink_url: string;
  playlist_count: number;
  reposts_count: number | null;
  track_count: number;
  uri: string;
  urn: string;
  username: string;
  verified: boolean;
  visuals: {
    urn: string;
    enabled: boolean;
    visuals: {
      urn: string;
      entry_time: number;
      visual_url: string;
    }[];
    tracking: null;
  };
  badges: {
    pro: boolean;
    creator_mid_tier: boolean;
    pro_unlimited: boolean;
    verified: boolean;
  };
  station_urn: string;
  station_permalink: string;
  spotlight: any[];
  latest: any[];
}

export interface SoundCloudTrack {
  artwork_url: string;
  artwork_url_hd: string | null;
  caption: string | null;
  comment_count: number;
  commentable: boolean;
  created_at: string;
  description: string;
  display_date: string;
  download_count: number;
  downloadable: boolean;
  duration: number;
  embeddable_by: string;
  full_duration: number;
  genre: string;
  has_downloads_left: boolean;
  id: number;
  kind: string;
  label_name: string;
  last_modified: string;
  license: string;
  likes_count: number;
  media: {
    transcodings: Array<{
      duration: number;
      format: {
        mime_type: string;
        protocol: string;
      };
      preset: string;
      quality: string;
      snipped: boolean;
      url: string;
    }>;
  };
  monetization_model: string;
  permalink: string;
  permalink_url: string;
  playback_count: number;
  policy: string;
  public: boolean;
  publisher_metadata: {
    artist: string;
    contains_music: boolean;
    explicit: boolean;
    album_title: string;
    id: number;
    isrc: string;
    urn: string;
  };
  purchase_title: string | null;
  purchase_url: string | null;
  release_date: string;
  reposts_count: number;
  secret_token: string | null;
  sharing: string;
  state: string;
  station_permalink: string;
  station_urn: string;
  streamable: boolean;
  tag_list: string;
  title: string;
  track_authorization: string;
  uri: string;
  urn: string;
  user: SoundCloudArtist;
  user_id: number;
  visuals: any | null;
  waveform_url: string;
}

export interface SoundCloudAlbum {
  artwork_url: string;
  created_at: string;
  description: string | null;
  display_date: string;
  duration: number;
  embeddable_by: string;
  genre: string;
  id: number;
  is_album: boolean;
  kind: string;
  label_name: string | null;
  last_modified: string;
  license: string;
  likes_count: number;
  managed_by_feeds: boolean;
  permalink: string;
  permalink_url: string;
  public: boolean;
  published_at: string;
  purchase_title: string | null;
  purchase_url: string | null;
  release_date: string;
  reposts_count: number;
  secret_token: string | null;
  set_type: string;
  sharing: string;
  tag_list: string;
  title: string;
  track_count: number;
  tracks: SoundCloudTrack[];
  uri: string;
  user: SoundCloudArtist;
  user_id: number;
}

export interface SoundCloudSearchResult {
  large: {
    collection: SoundCloudTrack[];
  };
  small: {
    collection: Array<{
      output: string;
      query: string;
    }>;
    next_href: string | null;
    query_urn: string;
  };
}

// Sections

export interface SoundCloudSections {
  collection: {
    urn: string;
    query_urn?: string;
    title: string;
    description?: string | null;
    tracking_feature_name: string;
    last_updated?: string | null;
    style?: string | null;
    social_proof?: string | null;
    social_proof_users?: string | null;
    items: {
      collection: {
        artwork_url?: string | null;
        artwork_url_hd?: string | null;
        created_at: string;
        duration: number;
        id: number;
        kind: "user" | "playlist";
        last_modified: string;
        likes_count: number;
        managed_by_feeds: boolean;
        permalink: string;
        permalink_url: string;
        public: boolean;
        reposts_count: number;
        secret_token?: string | null;
        sharing: string;
        title: string;
        track_count: number;
        uri: string;
        user_id: number;
        set_type: string;
        is_album: boolean;
        published_at?: string | null;
        release_date?: string | null;
        display_date: string;
        // User ------------------------------------------------
        avatar_url_hd?: string | null;
        avatar_url?: string | null;
        first_name: string;
        followers_count: number;
        full_name: string;
        last_name: string;
        urn: string;
        username: string;
        verified: boolean;
        city: string | null;
        country_code: string;
        badges: {
          pro: false;
          creator_mid_tier: false;
          pro_unlimited: true;
          verified: true;
        };
        // User - End ------------------------------------------
        user: {
          avatar_url: string;
          first_name: string;
          followers_count: number;
          full_name: string;
          id: number;
          kind: string;
          last_modified: string;
          last_name: string;
          permalink: string;
          permalink_url: string;
          uri: string;
          urn: string;
          username: string;
          verified: boolean;
          city?: string | null;
          country_code?: string | null;
          badges: {
            pro: boolean;
            creator_mid_tier: boolean;
            pro_unlimited: boolean;
            verified: boolean;
          };
        };
      }[];
      next_href?: string | null;
      query_urn?: string | null;
    };
    kind: string;
    id: string;
  }[];
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\types.ts
// Lyrics
export interface Verse {
  c: string; // content of the verse
  o: number; // offset time of the verse
}

export interface Lyric {
  ts: number; // start time
  te: number; // end time
  l: Verse[]; // list of verses
  x: string; // full lyric line
  translation?: string; // optional translation
}



\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\utils\libraryKey.ts
export function generateLibraryKey(): string {
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < 32; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\utils\storage.ts
interface Song {
  name?: string;
  artist?: string;
  lyrics?: any[];
  expiresAt?: number;
}

interface User {
  key?: number;
  name?: string;
  config?: Record<string, any>;
}

interface GakuData {
  songs: Song[];
  user?: User;
  [key: string]: any;
}

const STORAGE_KEY = "gakuData";

export const GakuStorage = {
  getData(): GakuData {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : { songs: [] };
  },

  setData(data: GakuData): void {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  },

  updateData(updater: (data: GakuData) => GakuData): void {
    const currentData = this.getData();
    const newData = updater(currentData);
    this.setData(newData);
  },

  addSong(song: Song): void {
    this.updateData((data) => ({
      ...data,
      songs: [...(data.songs || []), song],
    }));
  },

  updateSong(songIndex: number, updates: Partial<Song>): void {
    this.updateData((data) => {
      const songs = [...data.songs];
      songs[songIndex] = { ...songs[songIndex], ...updates };
      return { ...data, songs };
    });
  },

  updateUser(userUpdate: Partial<User>): void {
    this.updateData((data) => ({
      ...data,
      user: { ...(data.user || {}), ...userUpdate },
    }));
  },

  updateUserConfig(config: Record<string, any>): void {
    this.updateData((data) => ({
      ...data,
      user: {
        ...(data.user || {}),
        config: { ...(data.user?.config || {}), ...config },
      },
    }));
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\utils\themedPlaceholder.ts
"use client";
import { useState, useEffect } from "react";
import { PLACEHOLDER_IMAGE } from "@/lib/constants";

/**
 * Hook that returns the correct "themed" default image
 * based on <html style="color-scheme: dark/light;">.
 * It also sets a default to dark, if we can't detect anything yet.
 */
export function useThemedPlaceholder() {
  // 1) Decide initial default if we can't read style, prefer "dark"
  let isDarkPreferred = true;

  if (typeof document !== "undefined") {
    const scheme = document.documentElement.style.colorScheme;
    if (scheme && scheme.toLowerCase() === "light") {
      isDarkPreferred = false;
    }
  }

  // 2) Create our initial state
  const [defaultImage, setDefaultImage] = useState<string>(
    isDarkPreferred ? PLACEHOLDER_IMAGE.dark.url : PLACEHOLDER_IMAGE.light.url
  );

  useEffect(() => {
    // onMount check again in case we can read style now
    const scheme = document.documentElement.style.colorScheme;
    if (scheme.toLowerCase() === "light") {
      setDefaultImage(PLACEHOLDER_IMAGE.light.url);
    } else {
      setDefaultImage(PLACEHOLDER_IMAGE.dark.url);
    }

    // 3) Observe changes to the 'style' attribute on <html>
    const observer = new MutationObserver(() => {
      const schemeNow = document.documentElement.style.colorScheme;
      const isDark = schemeNow.toLowerCase() === "dark";
      setDefaultImage(
        isDark ? PLACEHOLDER_IMAGE.dark.url : PLACEHOLDER_IMAGE.light.url
      );
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["style"], // watch for style changes
    });

    return () => {
      observer.disconnect();
    };
  }, []);

  return defaultImage;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\lib\utils.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export async function FetchHipHopEvents() {
  try {
    const response = await fetch(`/api/soundcloud/events/top50hiphop`);
    console.log("FetchHipHopEvents | response:", response);
    if (!response.ok)
      throw new Error("FetchHipHopEvents | Failed to fetch data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.log("Error | FetchHipHopEvents:", error);
  }
}

export async function FetchNewHotEvents() {
  try {
    const response = await fetch(`/api/soundcloud/events/new&hot`);
    console.log("FetchNewHotEvents | response:", response);
    if (!response.ok)
      throw new Error("FetchNewHotEvents | Failed to fetch data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.log("Error | FetchNewHotEvents:", error);
  }
}

export async function FetchSearch(query: string) {
  try {
    const response = await fetch(`/api/soundcloud?q=${query}`);
    if (!response.ok) throw new Error("FetchSearch | Failed to fetch data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.log("Error | FetchSearch:", error);
  }
}

export async function fetchPlaylistM3U8(trackUrl: string) {
  try {
    const response = await fetch(
      `/api/soundcloud/music?trackUrl=${encodeURIComponent(trackUrl)}`
    );
    if (!response.ok) throw new Error("Failed to fetch playlist URL");
    const data = await response.json();
    return data.playlistUrl;
  } catch (error) {
    console.error("Error fetching playlist URL | fetchPlaylistM3U8:", error);
  }
}

export async function fetchUserData(profileUrl: string) {
  try {
    const response = await fetch(
      `/api/soundcloud/user/userData?profileUrl=${profileUrl}`
    );
    if (!response.ok) throw new Error("Failed to fetch users data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error fetching users data | fetchUserData:", error);
  }
}

export async function fetchLyrics(title: string, artist: string) {
  try {
    // Replace "octobersveryown" with "Drake"
    if (artist.toLowerCase() === "octobersveryown") {
      artist = "Drake";
    }
    console.log(`fetchLyrics | artist and title:", ${artist} - ${title})`);
    const response = await fetch(
      `https://lyrix.vercel.app/getLyricsByName/${artist}/${title}/?remix=false`
    );
    console.log("fetchLyrics | response:", response);
    if (!response.ok) throw new Error("Failed to fetch lyrics");
    const data = await response.json();
    console.log("API fetchLyrics | data:", data);
    return data;
  } catch (error) {
    console.error("Error fetching lyrics | fetchLyrics:", error);
  }
}

export async function fetchRichSyncLyrics(title: string, artist: string) {
  try {
    // Replace "octobersveryown" with "Drake"
    if (artist.toLowerCase() === "octobersveryown") {
      artist = "Drake";
    }

    const response = await fetch(
      `/api/lyrics/get?artist=${artist}&track=${title}`
    );
    console.log("fetchRichSyncLyrics | response:", response);
    if (!response.ok) throw new Error("Failed to fetch lyrics");
    const data = await response.json();
    console.log("API fetchRichSyncLyrics | data:", data);
    return data;
  } catch (error) {
    console.error(
      "Error fetching rich sync lyrics | fetchRichSyncLyrics:",
      error
    );
  }
}

export const dev = {
  log: (message?: any, ...optionalParams: unknown[]) => {
    if (process.env.NODE_ENV === "development") {
      console.log(
        `%c[LOG]`,
        "color: #9ae517; font-weight: bold",
        message,
        ...optionalParams
      );
    }
  },
  info: (message?: any, ...optionalParams: unknown[]) => {
    if (process.env.NODE_ENV === "development") {
      console.info(
        `%c[INFO]`,
        "color: blue; font-weight: bold",
        message,
        ...optionalParams
      );
    }
  },
  warn: (message?: any, ...optionalParams: unknown[]) => {
    if (process.env.NODE_ENV === "development") {
      console.warn(
        `%c[WARN]`,
        "color: orange; font-weight: bold",
        message,
        ...optionalParams
      );
    }
  },
  error: (message?: any, ...optionalParams: unknown[]) => {
    if (process.env.NODE_ENV === "development") {
      console.error(
        `%c[ERROR]`,
        "color: red; font-weight: bold",
        message,
        ...optionalParams
      );
    }
  },
  debug: (message?: any, ...optionalParams: unknown[]) => {
    if (process.env.NODE_ENV === "development") {
      console.debug(
        `%c[DEBUG]`,
        "color: purple; font-weight: bold",
        message,
        ...optionalParams
      );
    }
  },
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\middleware.ts
// import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

// const isPublicRoute = createRouteMatcher(["/sign-in(.*)", "/(.*)"]);

// // Public Routes
// export default clerkMiddleware(async (auth, request) => {
//   if (!isPublicRoute(request)) {
//     await auth.protect();
//   }
// });

// export const config = {
//   matcher: [
//     // Skip Next.js internals and all static files, unless found in search params
//     "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
//     // Always run for API routes
//     "/(api|trpc)(.*)",
//   ],
// };

import { clerkMiddleware } from "@clerk/nextjs/server";

export default clerkMiddleware({ clockSkewInMs: 60000 });

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\apple\artist\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const APPLE_AUTH = process.env.APPLE_AUTH;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query } = req.query;

  if (req.method === "GET") {
    try {
      console.log(`AppleKit API | Query: ${query}`);
      const searchResponse = await axios.get(
        `https://api.music.apple.com/v1/catalog/us/search?limit=5&term=${query}&types=artists`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
          },
        }
      );

      const artistID = searchResponse.data.results.artists.data[0].id;
      const response = await axios.get(
        `https://amp-api.music.apple.com/v1/catalog/us/artists/${artistID}?art%5Burl%5D=c%2Cf&extend=artistBio%2CbornOrFormed%2CeditorialArtwork%2CeditorialVideo%2CextendedAssetUrls%2Chero%2CisGroup%2Corigin%2CplainEditorialNotes%2CseoDescription%2CseoTitle&extend%5Bplaylists%5D=trackCount&format%5Bresources%5D=map&include=record-labels%2Cartists&include%5Bmusic-videos%5D=artists&include%5Bsongs%5D=artists%2Calbums&l=en-US&limit%5Bartists%3Atop-songs%5D=20&meta%5Balbums%3Atracks%5D=popularity&platform=web&views=appears-on-albums%2Ccompilation-albums%2Cfeatured-albums%2Cfeatured-on-albums%2Cfeatured-release%2Cfull-albums%2Clatest-release%2Clive-albums%2Cmore-to-hear%2Cmore-to-see%2Cmusic-videos%2Cplaylists%2Cradio-shows%2Csimilar-artists%2Csingles%2Ctop-songs`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
          },
        }
      );
      res.status(200).json(response.data);
    } catch (error) {
      res.status(500).json({
        error: "An error occurred while fetching the song info | MusicKit",
      });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\apple\lyrics\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { conf } from "@/lib/config";

const APPLE_AUTH = conf().APPLE.MUSIC.AUTH;
const USER_TOKEN = conf().APPLE.MUSIC.USER_TOKEN;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query } = req.query;
  if (req.method === "GET") {
    try {
      // First request to search for the song
      console.log("Apple | Lyrics | Starting search for:", query);
      const searchResponse = await axios.get(
        `https://api.music.apple.com/v1/catalog/us/search?types=songs&term=${
          query as string
        }&limit=10`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
          },
        }
      );

      const songID = searchResponse.data.results.songs.data[0].id;

      console.log("Apple | Lyrics | Found song ID:", songID);

      const songResponse = await axios.get(
        `https://amp-api.music.apple.com/v1/catalog/us/songs/${songID}/syllable-lyrics`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
            "media-user-token": USER_TOKEN,
          },
        }
      );

      if (songResponse.data.data[0].attributes) {
        console.log("Apple | Lyrics | Success");
      } else {
        console.log("Apple | Lyrics | Failed");
      }

      res.status(200).json(songResponse.data);

      const lyrics = songResponse.data;
      const artwork =
        searchResponse.data.results.songs.data[0].attributes.artwork;

      res.status(200).json({ lyrics, artwork });
    } catch (error) {
      res.status(500).json({
        error: "An error occurred while fetching the song info | MusicKit",
        message: error,
      });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\apple\song\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const APPLE_AUTH = process.env.APPLE_AUTH;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query, type } = req.query;

  if (req.method === "GET") {
    try {
      // Determine the type of search (albums or songs)
      const searchType = type === "albums" ? "albums" : "songs";

      console.log(`AppleKit API | Query: ${query} | Type: ${searchType}`);

      // First request to search for the song or album
      // Usage: /api/apple/song/[query]?type=albums or /api/apple/song/[query]?type=songs

      // https://api.music.apple.com/v1/catalog/us/search?types=albums&term=LYFESTYLE
      const searchResponse = await axios.get(
        `https://api.music.apple.com/v1/catalog/us/search?limit=5&term=${query}&types=${searchType}`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
          },
        }
      );

      const albumId = searchResponse.data.results.albums.data[0].id;

      // Finds ID by name
      // const album = searchResponse.data.results.albums.data.find(
      //   (album: any) => album.attributes.name.toLowerCase() === (query as string).toLowerCase()
      // );

      // if (!album) {
      //   return res.status(404).json({ error: "Album not found" });
      // }
      // const albumId = album.id;

      // Second request to get detailed album information
      const albumResponse = await axios.get(
        `https://amp-api.music.apple.com/v1/catalog/us/albums/${albumId}?l=en-US&extend=editorialArtwork%2CeditorialVideo%2CextendedAssetUrls%2Coffers%2CtrackCount%2Ctags`,
        {
          headers: {
            Origin: "https://music.apple.com",
            Authorization: `Bearer ${APPLE_AUTH}`,
          },
        }
      );

      res.status(200).json(albumResponse.data);
    } catch (error) {
      res.status(500).json({
        error: "An error occurred while fetching the song info | MusicKit",
      });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\artist\info\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/users/${id}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );

      res.status(200).json(response.data);
    } catch (error) {
      res
        .status(500)
        .json({ error: "An error occurred while fetching the artist's data" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\artist\recent\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const clientID = process.env.SOUNDCLOUD_CLIENT_ID;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/users/${id}/tracks?representation=&client_id=${clientID}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );

      const tracks = response.data.collection;

      // Modify artwork_url to get the HD version
      const updatedTracks = tracks.map((track: any) => {
        const artwork_url_hd = track.artwork_url
          ? track.artwork_url.replace("large", "t500x500")
          : null;
        return {
          ...track,
          artwork_url_hd,
        };
      });

      res.status(200).json({ ...response.data, collection: updatedTracks });
    } catch (error) {
      res
        .status(500)
        .json({ error: "An error occurred while fetching the artist's data" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\artist\spotlight\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/users/${id}/spotlight`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );

      const tracks = response.data.collection;

      // Modify artwork_url to get the HD version
      const updatedTracks = tracks.map((track: any) => {
        const artwork_url_hd = track.artwork_url
          ? track.artwork_url.replace("large", "t500x500")
          : null;
        return {
          ...track,
          artwork_url_hd,
        };
      });

      res.status(200).json({ ...response.data, collection: updatedTracks });
    } catch (error) {
      res.status(500).json({
        error: "An error occurred while fetching the artist's spotlight tracks",
      });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\extra\cover\old\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { JSDOM } from "jsdom";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  // Ensure that query is a string and not undefined or an array
  const queryString = Array.isArray(query) ? query[0] : query;

  if (!queryString) {
    return res.status(400).json({ error: "Query parameter is required" });
  }

  try {
    // console.log("Scraping started");

    // Fetch the HTML from the SoundCloud page
    const response = await axios.get(queryString);
    // console.log("Response received!");

    // Parse the HTML using JSDOM
    const dom = new JSDOM(response.data);
    const document = dom.window.document;

    // console.log("Document Initialized!");

    // Find the meta tag with property `og:image`
    const metaTag = document.querySelector('meta[property="og:image"]');

    if (metaTag) {
      // console.log("Meta tag found!", metaTag);

      // Extract the content attribute which contains the image URL
      const imageUrl = metaTag.getAttribute("content");

      if (imageUrl) {
        // console.log("Image URL extracted!", imageUrl);
        // Return the image URL as JSON
        return res.status(200).json({ imageUrl });
      } else {
        // console.log("Image URL not found in the meta tag content!");
      }
    } else {
      // console.log("Meta tag with og:image not found!");
    }

    // If the meta tag or URL is not found, return a 404 error
    return res.status(404).json({ error: "Artwork not found" });
  } catch (error) {
    console.error("Failed to fetch track data:", error);
    return res.status(500).json({ error: "Failed to fetch track data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\extra\cover\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { JSDOM } from "jsdom";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  // Ensure that query is a string and not undefined or an array
  const queryString = Array.isArray(query) ? query[0] : query;

  if (!queryString) {
    return res.status(400).json({ error: "Query parameter is required" });
  }

  try {
    // Check if the query is a direct artwork URL
    if (queryString.includes("sndcdn.com/artworks")) {
      const hdImageUrl = queryString.replace("large", "t500x500");
      return res.status(200).json({ imageUrl: hdImageUrl });
    }

    // Fetch the HTML from the SoundCloud page
    const response = await axios.get(queryString);

    // Parse the HTML using JSDOM
    const dom = new JSDOM(response.data);
    const document = dom.window.document;

    // Find the meta tag with property `og:image`
    const metaTag = document.querySelector('meta[property="og:image"]');

    if (metaTag) {
      // Extract the content attribute which contains the image URL
      const imageUrl = metaTag.getAttribute("content");

      if (imageUrl) {
        // Modify the image URL to get the HD version
        const hdImageUrl = imageUrl.replace("large", "t500x500");
        return res.status(200).json({ imageUrl: hdImageUrl });
      }
    }

    // If the meta tag or URL is not found, return a 404 error
    return res.status(404).json({ error: "Artwork not found" });
  } catch (error) {
    console.error("Failed to fetch track data:", error);
    return res.status(500).json({ error: "Failed to fetch track data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\fetchPlaylist.ts
import type { NextApiRequest, NextApiResponse } from "next";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const playlistUrl =
    "https://cf-hls-media.sndcdn.com/playlist/ladE0RdPLsfF.128.mp3/playlist.m3u8?Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiKjovL2NmLWhscy1tZWRpYS5zbmRjZG4uY29tL3BsYXlsaXN0L2xhZEUwUmRQTHNmRi4xMjgubXAzL3BsYXlsaXN0Lm0zdTgqIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNzIyMjYyMjM2fX19XX0_&Signature=W5n2X6xOOGQbabQzs9YwdlErYwVJKVs3laUYgYSQyCD8-Zw5X3qf1iPkwZrUpLZEFrs7LbzWWeuSuUUftFfJUvd3Wt~yewq~ZixtHVTFeC8T16U9MYOeniQkPWirFrPo3koRwmyv8gTsei2teX9yBUbZhlFadFsyoCwYQB0~tuLDYrIJYvTB~vSp8bgnUgjR~sua1HzyRtEx9dfBnoFMBb68ksrRfFJJycGAB6LueucnA2~MfgzGRCufr7avxe-FEyQIqzzlpMnBHjgOUWw7tldq91l3DWhVm2ouvlIhRqZZIPK1MTnvLVrGI-xwW5w90I9n3VUau8gUq0sjbxKQ6A__&Key-Pair-Id=APKAI6TU7MMXM5DG6EPQ";

  try {
    const response = await fetch(playlistUrl, {
      headers: {
        "Content-Type": "application/x-mpegURL",
      },
    });
    // console.log("fetchPlaylist | response:", response);
    if (!response.ok) {
      console.error(`HTTP error! status: ${response.status}`);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    // console.log("fetchPlaylist | data:", data);
    res.status(200).json({ playlist: data });
  } catch (error: unknown) {
    console.error(
      "Fetch error:",
      error instanceof Error ? error.message : String(error)
    );
    res
      .status(500)
      .json({ error: error instanceof Error ? error.message : String(error) });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\genius\song\info\[query].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const GENIUS_ACCESS_TOKEN = process.env.GENIUS_ACCESS_TOKEN;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { query } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  try {
    const response = await axios.get(
      `https://api.genius.com/search?q=${query}&access_token=${GENIUS_ACCESS_TOKEN}`
    );

    res.status(200).json(response.data);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch track data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\lyrics\get.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
const { wrapper } = require("axios-cookiejar-support");
const tough = require("tough-cookie");

// Enable cookie jar support in axios
wrapper(axios);

// Create a cookie jar instance to store cookies
const cookieJar = new tough.CookieJar();

// Function to generate a random ID
function generateRandomId() {
  return Math.random()
    .toString(36)
    .replace(/[^a-z]+/g, "")
    .slice(2, 10);
}

// Function to get the Musixmatch token
async function getMXMToken() {
  const tokenUrl = `https://apic-desktop.musixmatch.com/ws/1.1/token.get?app_id=web-desktop-app-v1.0&t=${generateRandomId()}`;

  try {
    const response = await axios.get(tokenUrl, {
      headers: {
        Cookie:
          "11601B1EF8BC274C33F9043CA947F99DCFF8378C231564BC3E68894E08BD389E37D51060B3D21B0B0C9BD2CD4B7FB43BF686CF57330A3F26A0D86825F74794F3C94; mxm-encrypted-token=; x-mxm-token-guid=undefined; x-mxm-user-id=undefined",
        "User-Agent": "PostmanRuntime/7.41.2",
        Accept: "*/*",
        Connection: "keep-alive",
        "X-Requested-With": "XMLHttpRequest",
        "Accept-Encoding": "gzip, deflate, br",
      },
      // httpsAgent: new (axios.create().defaults.httpsAgent.constructor)({
      //   jar: cookieJar,
      // }),
      // withCredentials: true,
      // maxRedirects: 5,
    });
    console.log("getMXMToken | response:", response.data);
    if (
      response.data.message &&
      response.data.message.header.status_code === 200
    ) {
      return response.data.message.body.user_token;
    } else {
      throw new Error("Failed to retrieve user token");
    }
  } catch (error: any) {
    console.error("Error fetching token:", error.message);
    throw new Error(`Error fetching token: ${error.message}`);
  }
}

// Function to get rich sync subtitles
async function getRichSync(track: string, artist: string, token: string) {
  const url = `https://apic-desktop.musixmatch.com/ws/1.1/macro.subtitles.get?format=json&namespace=lyrics_richsynched&optional_calls=track.richsync&q_artist=${encodeURIComponent(
    artist
  )}&q_track=${encodeURIComponent(
    track
  )}&usertoken=240907c8a5257abdda0a975ac3ec819a5bb759721255daec124ddc&app_id=web-desktop-app-v1.0&t=${token}`;

  try {
    const response = await axios.get(url, {
      headers: {
        Cookie:
          "11601B1EF8BC274C33F9043CA947F99DCFF8378C231564BC3E68894E08BD389E37D51060B3D21B0B0C9BD2CD4B7FB43BF686CF57330A3F26A0D86825F74794F3C94; mxm-encrypted-token=; x-mxm-token-guid=undefined; x-mxm-user-id=undefined",
        "User-Agent": "PostmanRuntime/7.41.2",
        Accept: "*/*",
        Connection: "keep-alive",
        "X-Requested-With": "XMLHttpRequest",
        "Accept-Encoding": "gzip, deflate, br",
      },
    });

    // console.log("getRichSync | response:", response.data);
    console.log(
      "getRichSync | response.data.message.body:",
      response.data.message.body
    );
    // console.log(
    //   "getRichSync | response.data.message.body.macro_calls:",
    //   response.data.message.body.macro_calls["track.richsync.get"].message.body
    // );

    if (
      response.status === 200 &&
      response.data.message.header.status_code === 200 &&
      response.data.message.body.macro_calls["track.richsync.get"]
    ) {
      return response.data.message.body.macro_calls["track.richsync.get"];
    } else {
      throw new Error("Failed to retrieve rich sync subtitles");
    }
  } catch (error: any) {
    console.error("Error fetching rich sync:", error.message);
    throw new Error(`Error fetching rich sync: ${error.message}`);
  }
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    const { artist, track } = req.query;

    // const artist = "TheWeeknd";
    // const track = "Starboy";

    if (!artist || !track) {
      return res
        .status(400)
        .json({ error: "Missing artist or track query parameter" });
    }

    try {
      // Step 1: Get Musixmatch token
      const userToken = await getMXMToken();

      // Step 2: Fetch rich sync lyrics
      const lyrics = await getRichSync(
        artist as string,
        track as string,
        userToken
      );

      // Step 3: Send response with rich sync lyrics
      res.status(200).json({ lyrics });
    } catch (error: any) {
      console.error("Error fetching lyrics:", error.message);
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\musix\album\info\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const MUSIX_API_KEY = process.env.MUSIX_API_KEY;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  try {
    const response = await axios.get(
      `http://api.musixmatch.com/ws/1.1/album.get?album_id=${id}&format=json&apikey=${MUSIX_API_KEY}`
    );

    res.status(200).json(response.data);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch album data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\musix\song\info\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

const MUSIX_API_KEY = process.env.MUSIX_API_KEY;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { isrc } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  try {
    const response = await axios.get(
      `http://api.musixmatch.com/ws/1.1/track.get?track_isrc=${isrc}&format=json&apikey=${MUSIX_API_KEY}`
    );

    res.status(200).json(response.data);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch track data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\playlist\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method === "GET") {
    try {
      const playlistResponse = await axios.get(
        `https://api-v2.soundcloud.com/playlists/${id}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );
      const playlist = playlistResponse.data;
      const trackIdsToFetch = playlist.tracks
        .slice(5)
        .map((track: { id: any }) => track.id);
      if (trackIdsToFetch.length > 0) {
        // Fetch details for the remaining tracks
        const tracksResponse = await axios.get(
          `https://api-v2.soundcloud.com/tracks?ids=${trackIdsToFetch.join(
            ","
          )}`,
          {
            headers: {
              Host: "api-v2.soundcloud.com",
              Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
            },
          }
        );
        // Create a map of the fetched tracks by ID
        const fetchedTracksMap = new Map(
          tracksResponse.data.map((track: any) => [track.id, track])
        );

        // Reorder the fetched tracks according to the original playlist order
        const reorderedTracks = trackIdsToFetch.map((id: any) =>
          fetchedTracksMap.get(id)
        );

        // Replace the simplified track objects with full track details in the correct order
        playlist.tracks.splice(
          5,
          playlist.tracks.length - 5,
          ...reorderedTracks
        );
      }

      res.status(200).json(playlist);
    } catch (error) {
      res
        .status(500)
        .json({ error: "An error occurred while fetching the playlist" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\(old)\events\new&hot.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/playlists/1712717571?representation=full&client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`,
        {
          headers: {
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );
      res.status(200).json(response.data);
    } catch (error) {
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\(old)\events\top50hiphop.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/playlists/1714689219?representation=full&client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`,
        {
          headers: {
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );
      res.status(200).json(response.data);
    } catch (error) {
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\getid\[url].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  const { url } = req.query;
  const decodedUrl = Array.isArray(url) ? url[0] : url;

  if (!decodedUrl) {
    return res.status(400).json({ error: "URL parameter is required" });
  }

  try {
    const response = await axios.get(decodedUrl);
    const html = response.data;

    // Use a regex to find the meta tag content quickly
    const metaMatch = html.match(
      /<meta property=["']al:ios:url["'] content=["']([^"']+)["']/
    );
    if (metaMatch && metaMatch[1]) {
      const content = metaMatch[1];
      const trackId = content.replace(/soundcloud:\/\/(sounds|playlists):/, "");
      return res.status(200).json({ trackId });
    }

    return res.status(404).json({ error: "Track ID not found" });
  } catch (error) {
    console.error("Failed to fetch track ID:", error);
    return res.status(500).json({ error: "Failed to fetch track ID" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\home\section.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { conf } from "@/lib/config";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    const KEY = conf().SOUNDCLOUD.CLIENT_ID;
    const APIKEY = conf().SOUNDCLOUD.API_KEY;

    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/mixed-selections?client_id=${KEY}`,
        {
          headers: {
            Authorization: `OAuth ${APIKEY}`,
          },
        }
      );

      // List of tracking_feature_name values to include
      const includedFeatureNames = [
        "curated-charts-top-50",
        "curated-trending-music-on-soundcloud",
        "curated-fresh-pressed",
        "curated-scenes-corners-of-soundcloud",
        "curated-hip-hop",
        "curated-pop",
        "curated-electronic",
        "curated-chill",
        "curated-introducing-buzzing",
        "curated-get-up",
        "curated-rb",
        "curated-holiday",
        "curated-country",
      ];

      // Filter the main collection by tracking_feature_name
      const filteredCollection = response.data.collection.filter((item: any) =>
        includedFeatureNames.includes(item.tracking_feature_name)
      );

      // Add artwork_url_hd and remove items with avatar_url
      const enhancedCollection = filteredCollection.map((item: any) => ({
        ...item,
        items: {
          ...item.items,
          collection: item.items.collection.map((nestedItem: any) => {
            // Add artwork_url_hd and avatar_url_hd at the top of the item
            const updatedItem = {
              avatar_url_hd: nestedItem.avatar_url
                ? nestedItem.avatar_url.replace("large", "t500x500")
                : null,
              avatar_url: nestedItem.avatar_url || null,
              artwork_url_hd: nestedItem.artwork_url
                ? nestedItem.artwork_url.replace("large", "t500x500")
                : null,
              artwork_url: nestedItem.artwork_url || null,
              ...nestedItem, // Spread the rest of the properties after the specific ones
            };

            return updatedItem;
          }),
        },
      }));

      // Return the filtered and enhanced collection
      res.status(200).json({
        ...response.data,
        collection: enhancedCollection,
      });
    } catch (error) {
      console.error("Error fetching SoundCloud data:", error);
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\music.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    const { trackUrl } = req.query;
    try {
      // Step 1: Extract the track ID
      const trackApiUrl = `https://api-v2.soundcloud.com/resolve?url=${trackUrl}&client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`;
      const trackResponse = await axios.get(trackApiUrl);
      const trackId = trackResponse.data.id;

      // Step 2: Fetch track details
      const trackDetailsUrl = `https://api-v2.soundcloud.com/tracks/${trackId}?client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`;
      const trackDetailsResponse = await axios.get(trackDetailsUrl);
      const transcodings = trackDetailsResponse.data.media.transcodings;

      // Step 3: Find HLS transcoding
      const hlsTranscoding = transcodings.find(
        (transcoding: { format: { protocol: string } }) =>
          transcoding.format.protocol === "hls"
      );
      if (!hlsTranscoding) {
        throw new Error("HLS transcoding not found");
      }

      // Step 4: Get HLS playlist URL 
      const hlsUrl = `${hlsTranscoding.url}?client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`;
      const hlsResponse = await axios.get(hlsUrl);
      const playlistUrl = hlsResponse.data.url;

      // Step 5: Get Lyrics
      // console.log("Track Artist:", trackDetailsResponse.data.publisher_metadata.artist);
      // console.log("Track Name:", trackDetailsResponse.data.publisher_metadata.release_title);
      // const trackArtist = trackDetailsResponse.data.publisher_metadata.artist
      // const trackName = trackDetailsResponse.data.publisher_metadata.release_title
      // const LyricsAPI = `https://lyrix.vercel.app/getLyricsByName/${trackArtist}/${trackName}/?remix=false`;
      // const lyricsResponse = await axios.get(LyricsAPI);
      // const lyrics = lyricsResponse
      // console.log("Lyrics:", lyrics);

      res.status(200).json({ playlistUrl });
    } catch (error) {
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\resolve.ts
import type { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

/**
 * /api/soundcloud/resolve?permalink=<string>
 *
 * Example: /api/soundcloud/resolve?permalink=yeat
 * This calls SoundCloud's /resolve.json to get the user's ID, kind, etc.
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  const { permalink } = req.query;

  // 1) Ensure we have a valid 'permalink' param
  if (!permalink || typeof permalink !== "string") {
    return res
      .status(400)
      .json({ error: 'You must provide a "permalink" query param.' });
  }

  try {
    // 2) Use SoundCloud's /resolve endpoint (v1) to resolve
    //    e.g. GET https://api.soundcloud.com/resolve.json
    //         ?url=https://soundcloud.com/<permalink>
    //         &client_id=<YOUR_CLIENT_ID>
    const clientId = process.env.SOUNDCLOUD_CLIENT_ID;
    if (!clientId) {
      return res.status(500).json({
        error:
          "Missing SOUNDCLOUD_CLIENT_ID in environment. Please set it in .env",
      });
    }

    // 3) Build the full URL with query params
    //    https://api.soundcloud.com/resolve.json?url=https://soundcloud.com/<permalink>&client_id=<clientId>
    const resolveUrl = "https://api.soundcloud.com/resolve.json";
    const response = await axios.get(resolveUrl, {
      params: {
        url: `https://soundcloud.com/${permalink}`,
        client_id: clientId,
      },
    });

    // 4) The response might look like:
    // {
    //   "kind": "user",
    //   "id": 295329678,
    //   "permalink": "lilyeat",
    //   ... more fields
    // }
    const resolvedData = response.data;

    // 5) Return the resolved data (it includes the user/track/playlist ID)
    return res.status(200).json(resolvedData);
  } catch (error) {
    console.error("Error resolving SoundCloud permalink:", error);
    return res.status(500).json({
      error: "Failed to resolve SoundCloud permalink. See server logs.",
    });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\search.ts
import { SEARCH_PAGE } from "@/lib/constants";
import { conf } from "@/lib/config";
import { NextApiRequest, NextApiResponse } from "next";

/**
 * Usage:
 *   /api/soundcloud?q=someArtist         => default to mini search
 *   /api/soundcloud?q=someArtist&type=mini => explicitly mini
 *   /api/soundcloud?q=someArtist&type=full => full search
 */
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { q, type } = req.query;
  const query = q as string;
  // default to "mini" if type is not provided
  const searchType = (type as string) || "mini";

  const key = conf().SOUNDCLOUD.CLIENT_ID;

  if (!query) {
    return res.status(400).json({ error: 'Query parameter "q" is required.' });
  }

  if (!key) {
    return res
      .status(500)
      .json({ error: "SoundCloud Client ID is not configured." });
  }

  try {
    // --------------------------------------
    // 1) FULL SEARCH
    // --------------------------------------
    if (searchType === "full") {
      const fullUrl = `https://api-v2.soundcloud.com/search?q=${encodeURIComponent(
        query
      )}&client_id=${key}&limit=20&offset=0`;

      const fullResponse = await fetch(fullUrl);
      if (!fullResponse.ok) {
        throw new Error("Failed to fetch from SoundCloud full search.");
      }
      const fullData = await fullResponse.json();
      return res.status(200).json({ full: fullData });
    }

    // --------------------------------------
    // 2) MINI SEARCH (the existing approach)
    // --------------------------------------
    // fetch from 'search/queries' (small) and normal 'search' (large)
    const SCSearchResponseSmall = await fetch(
      `https://api-v2.soundcloud.com/search/queries?q=${encodeURIComponent(
        query
      )}&client_id=${key}&limit=${SEARCH_PAGE.SMALL.LIMIT}&offset=${
        SEARCH_PAGE.SMALL.OFFSET
      }&linked_partitioning=1&app_version=1737027715&app_locale=en`
    );
    if (!SCSearchResponseSmall.ok) {
      throw new Error("Failed to fetch mini (small) SoundCloud search.");
    }

    const SCSearchResponseLarge = await fetch(
      `https://api-v2.soundcloud.com/search?q=${encodeURIComponent(
        query
      )}&variant_ids=&query_urn=soundcloud%3Asearch-autocomplete%3Adeb7f341d9164082a21433260720aa9e&facet=model&user_id=681620-889553-566128-420969&client_id=${key}&limit=${
        SEARCH_PAGE.LARGE.LIMIT
      }&offset=${
        SEARCH_PAGE.LARGE.OFFSET
      }&linked_partitioning=1&app_version=1737027715&app_locale=en`
    );
    if (!SCSearchResponseLarge.ok) {
      throw new Error("Failed to fetch mini (large) SoundCloud search.");
    }

    const small = await SCSearchResponseSmall.json();
    const large = await SCSearchResponseLarge.json();

    return res.status(200).json({
      small,
      large,
    });
  } catch (error: unknown) {
    console.error(error);
    return res
      .status(500)
      .json({ error: "An error occurred while searching data." });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\user.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { JSDOM } from "jsdom";

const clientID = process.env.SOUNDCLOUD_CLIENT_ID;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { profileUrl, type } = req.query;

  console.log("profileUrl:", profileUrl);

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  // Ensure profileUrl is a string and not undefined or an array
  const profileUrlString = Array.isArray(profileUrl)
    ? profileUrl[0]
    : profileUrl;

  if (!profileUrlString) {
    return res
      .status(400)
      .json({ error: "Profile URL (or user ID) is required" });
  }

  let userId: string | null = null;

  try {
    if (type === "id") {
      // When type is 'id', profileUrlString is actually the SoundCloud user ID
      userId = profileUrlString;
    } else {
      // Step 1: Fetch the HTML from the SoundCloud profile page
      const response = await axios.get(profileUrlString);

      // Step 2: Parse the HTML using JSDOM
      const dom = new JSDOM(response.data);
      const document = dom.window.document;

      // Step 3: Find the meta tag with property `twitter:app:url:googleplay`
      const metaTag = document.querySelector(
        'meta[property="twitter:app:url:googleplay"]'
      );

      if (!metaTag) {
        return res.status(404).json({ error: "User ID not found in meta tag" });
      }

      // Step 4: Extract the content attribute which contains the user ID
      const content = metaTag.getAttribute("content");
      const userIdMatch = content ? content.match(/users:(\d+)/) : null;
      userId = userIdMatch ? userIdMatch[1] : null;

      if (!userId) {
        return res
          .status(404)
          .json({ error: "User ID not found in the content" });
      }
    }

    // Step 5: Fetch user data from SoundCloud API
    const userDataResponse = await axios.get(
      `https://api-v2.soundcloud.com/users/${userId}`,
      {
        headers: {
          Host: "api-v2.soundcloud.com",
          Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
        },
      }
    );
    const userLikesResponse = await axios.get(
      `https://api-v2.soundcloud.com/users/${userId}/likes?client_id=${clientID}&limit=500&offset=0`,
      {
        headers: {
          Host: "api-v2.soundcloud.com",
          Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
        },
      }
    );

    // Step 6: Combine the data
    const data = {
      userData: userDataResponse.data,
      userLikes: userLikesResponse.data,
    };

    // Step 7: Return the combined data
    return res.status(200).json(data);
  } catch (error) {
    console.error("Error fetching user data:", error);
    return res.status(500).json({ error: "Failed to fetch user data" });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

// Artist IDs: Yeat-295329678, SZA-312938480, Osamason-222077223
// Album IDs: SZA SOS-1928518223

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id, type, include } = req.query;

  if (req.method !== "GET") {
    res.setHeader("Allow", ["GET"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  try {
    // Determine the type of search (albums, songs, playlists, or artist)
    const searchType =
      type === "albums"
        ? "albums"
        : type === "songs"
        ? "songs"
        : type === "playlists"
        ? "playlists"
        : type === "artist"
        ? "artist"
        : "songs";

    console.log(
      `SoundCloudKit API | ID: ${id} | Type: ${searchType} | Include: ${include}`
    );

    //
    // 1) ALBUMS → Extended track fetching
    //
    if (searchType === "albums") {
      const playlistResponse = await axios.get(
        `https://api-v2.soundcloud.com/playlists/${id}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );

      const playlist = playlistResponse.data;
      const trackIdsToFetch = playlist.tracks
        .slice(5)
        .map((track: { id: number }) => track.id);

      if (trackIdsToFetch.length > 0) {
        const tracksResponse = await axios.get(
          `https://api-v2.soundcloud.com/tracks?ids=${trackIdsToFetch.join(
            ","
          )}`,
          {
            headers: {
              Host: "api-v2.soundcloud.com",
              Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
            },
          }
        );

        // Create a map of the newly fetched tracks
        const fetchedTracksMap = new Map(
          tracksResponse.data.map((track: any) => [track.id, track])
        );
        // Reorder them to match the playlist’s original order
        const reorderedTracks = trackIdsToFetch.map((tid: number) =>
          fetchedTracksMap.get(tid)
        );
        // Replace the short track items with the full items
        playlist.tracks.splice(
          5,
          playlist.tracks.length - 5,
          ...reorderedTracks
        );
      }

      return res.status(200).json(playlist);
    }

    //
    // 2) ARTIST → Possibly fetch spotlight, latest, etc.
    //
    if (searchType === "artist") {
      // 1. Basic artist info
      const artistResponse = await axios.get(
        `https://api-v2.soundcloud.com/users/${id}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
          },
        }
      );
      const artist = artistResponse.data;

      // 2. Parse `include` for multiple includes (comma-separated)
      const includes = (include ?? "").toString().split(",");

      // 3. If "spotlight" included → fetch the user’s spotlight
      if (includes.includes("spotlight")) {
        const spotlightResponse = await axios.get(
          `https://api-v2.soundcloud.com/users/${id}/spotlight`,
          {
            headers: {
              Host: "api-v2.soundcloud.com",
              Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
            },
          }
        );

        // Example: attach processed spotlight data to artist
        const tracks = spotlightResponse.data.collection || [];
        artist.spotlight = tracks.map((track: any) => ({
          ...track,
          artwork_url_hd: track.artwork_url
            ? track.artwork_url.replace("large", "t500x500")
            : null,
        }));
      }

      // 4. If "latest" included → fetch user’s “latest” from /stream/users/{id}
      if (includes.includes("latest")) {
        const latestResponse = await axios.get(
          `https://api-v2.soundcloud.com/stream/users/${id}`,
          {
            headers: {
              Host: "api-v2.soundcloud.com",
              Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
            },
          }
        );

        // Example: attach processed “latest” data to artist
        const tracks = latestResponse.data.collection || [];
        artist.latest = tracks.map((track: any) => {
          const trackData = track.track || track;
          return {
            ...track,
            track: {
              ...trackData,
              artwork_url_hd: trackData.artwork_url
                ? trackData.artwork_url.replace("large", "t500x500")
                : null,
            },
          };
        });
      }

      return res.status(200).json(artist);
    }

    //
    // 3) SONGS or PLAYLISTS → direct fetch
    //
    const urlDetails =
      {
        songs: `/tracks/${id}`,
        playlists: `/playlists/${id}`,
      }[searchType] || `/tracks/${id}`;

    const response = await axios.get(
      `https://api-v2.soundcloud.com${urlDetails}`,
      {
        headers: {
          Host: "api-v2.soundcloud.com",
          Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
        },
      }
    );

    return res.status(200).json(response.data);
  } catch (error) {
    console.error("SoundCloudKit API | Error:", error);
    return res.status(500).json({
      error: "An error occurred while fetching SoundCloud data | SoundCloudKit",
    });
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\soundcloud.ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";
import { SEARCH_PAGE } from "@/lib/constants";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method === "GET") {
    try {
      const response = await axios.get("https://api-v2.soundcloud.com/search", {
        params: {
          ...req.query,
          facet: "model",
          limit: SEARCH_PAGE.FULL.LIMIT,
          offset: SEARCH_PAGE.FULL.OFFSET,
        },
        headers: {
          Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`,
        },
      });
      res.status(200).json(response.data);
    } catch (error) {
      res.status(500).json({ error: "An error occurred" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\pages\api\track\info\[id].ts
import { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { id } = req.query;

  if (req.method === "GET") {
    try {
      const response = await axios.get(
        `https://api-v2.soundcloud.com/tracks/${id}?client_id=${process.env.SOUNDCLOUD_CLIENT_ID}`,
        {
          headers: {
            Host: "api-v2.soundcloud.com",
            Authorization: `OAuth ${process.env.SOUNDCLOUD_API_KEY}`, // Ensure the client ID is set in your .env file
          },
        }
      );

      res.status(200).json(response.data);
    } catch (error) {
      // console.error("Error fetching track data:", error);
      res
        .status(500)
        .json({ error: "An error occurred while fetching the track data" });
    }
  } else {
    res.setHeader("Allow", ["GET"]);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\providers\QueryWrapper.tsx
"use client";

import React, { useState } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

type ReactQueryWrapperProps = {
  children: React.ReactNode;
};

export default function ReactQueryWrapper({
  children,
}: ReactQueryWrapperProps) {
  // Create one client instance for the entire app
  const [queryClient] = useState(() => new QueryClient());

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\providers\ThemeProvider.tsx
"use client";
import { useUser as GakuUser } from "@/hooks/useUser";
import { useEffect } from "react";
import { useUser } from "@clerk/nextjs";

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const { isLoaded, isSignedIn } = useUser();
  const { settings } = GakuUser();
  const userThemeColor = settings?.themeColor;

  // Fetch user settings and apply theme when component mounts
  useEffect(() => {
    if (isLoaded && isSignedIn) {
      fetchAndApplyUserTheme();
    } else if (isLoaded && !isSignedIn) {
      // For non-signed in users, we use default theme
      document.documentElement.style.setProperty("--keyColor", "#5891fa");
    }
  }, [isLoaded, isSignedIn]);

  const fetchAndApplyUserTheme = async () => {
    if (userThemeColor) {
      document.documentElement.style.setProperty("--keyColor", userThemeColor);
    }
  };

  return <>{children}</>;
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\artwork\Artwork.tsx
import React from 'react'

export const Artwork = () => {
  return (
    <div>Artwork</div>
  )
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\contextmenus\ContextMenu.tsx
"use client";
import { dev } from "@/lib/utils";
import { useContextMenu } from "react-contexify";

type ContextMenuProps = {
  type: "song" | "album" | "artist";
  itemId: string;
  children: React.ReactNode;
  ref?: React.Ref<any>;
  as?: React.ElementType;
  className?: string;
  title?: string;
};

export const handleContextMenu = (
  e: React.MouseEvent,
  type: "song" | "album" | "artist",
  itemId: string,
  show: (props: { event: React.MouseEvent; props: { itemId: string } }) => void
) => {
  e.preventDefault();
  dev.log("Context menu |", "type:", type, "id:", itemId);
  show({ event: e, props: { itemId } });
};

const ContextMenu = ({
  type,
  itemId,
  children,
  ref,
  as: Element = "div",
  className = "",
  title = "",
}: ContextMenuProps) => {
  let menuId: string;
  switch (type) {
    case "song":
      menuId = "songMenu";
      break;
    case "album":
      menuId = "albumMenu";
      break;
    case "artist":
      menuId = "artistMenu";
      break;
    default:
      throw new Error("Invalid menu type");
  }

  const { show } = useContextMenu({ id: menuId });

  return (
    <Element
      ref={ref}
      {...(title ? { title } : {})} // dont add title if it's empty
      onContextMenu={(e: React.MouseEvent<HTMLElement>) => {
      e.preventDefault();
      // Pass itemId to the menu
      dev.log("Context menu |", "type:", type, "id:", itemId);
      show({ event: e, props: { itemId } });
      }}
      className={className}
    >
      {children}
    </Element>
  );
};

export default ContextMenu;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\contextmenus\contextMenus.tsx
"use client";
import { Menu, Item, ItemParams, PredicateParams } from "react-contexify";
import { useUser } from "@/hooks/useUser";
import { showToast } from "@/hooks/useToast";
import { useCallback } from "react";

export const SONG_MENU_ID = "songMenu";

// Define the shape of props passed to the menu
interface SongMenuProps {
  itemId: string;
}

export function SongMenu() {
  const { addSongToLibrary, removeSongFromLibrary, librarySongs } = useUser();

  const isInLibrary = useCallback(
    (songId: string) => {
      return librarySongs?.some((song) => song.id === songId) || false;
    },
    [librarySongs]
  );

  // Handle adding a song, expecting ItemParams with SongMenuProps
  const handleAddToLibrary = ({ props }: ItemParams<SongMenuProps>) => {
    const itemId = props?.itemId;
    if (itemId) {
      addSongToLibrary(itemId);
      showToast("success", `Song added to library`);
    }
  };

  // Handle removing a song, expecting ItemParams with SongMenuProps
  const handleRemoveFromLibrary = ({ props }: ItemParams<SongMenuProps>) => {
    const itemId = props?.itemId;
    if (itemId) {
      removeSongFromLibrary(itemId);
      showToast("success", `Song removed from library`);
    }
  };

  return (
    <Menu id={SONG_MENU_ID} animation="fade">
      {/* Show "Add to Library" only if song is not in library */}
      <Item
        hidden={({ props }: PredicateParams<SongMenuProps>) => {
          const songId = props?.itemId;
          return !songId || isInLibrary(songId);
        }}
        onClick={handleAddToLibrary}
      >
        Add to Library
      </Item>
      {/* Show "Remove from Library" only if song is in library */}
      <Item
        hidden={({ props }: PredicateParams<SongMenuProps>) => {
          const songId = props?.itemId;
          return !songId || !isInLibrary(songId);
        }}
        onClick={handleRemoveFromLibrary}
      >
        Remove from Library
      </Item>
    </Menu>
  );
}

export const contextMenus = (
  <>
    <SongMenu />
    {/* <AlbumMenu /> */}
    {/* <ArtistMenu /> */}
  </>
);


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\controls\Switch.tsx
import * as SwitchR from "@radix-ui/react-switch";
import { ComponentPropsWithoutRef } from "react";

// Extend the Root component props
type SwitchProps = ComponentPropsWithoutRef<typeof SwitchR.Root>;

export const Switch = (props: SwitchProps) => {
  const {
    className = "relative h-6 w-11 cursor-pointer rounded-full bg-[--labelDivider] outline-none data-[state=checked]:bg-[--keyColor]",
    ...otherProps
  } = props;

  return (
    <SwitchR.Root className={className} {...otherProps}>
      <SwitchR.Thumb className="block size-5 rounded-full bg-white transition-transform duration-200 will-change-transform translate-x-[0.1rem] data-[state=checked]:translate-x-[1.4rem]" />
    </SwitchR.Root>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\extra\MiniSpinner.tsx
import React from "react";
import "./mini-spinner.css";

interface MiniSpinnerProps {
  size?: "xs" | "sm" | "md" | "lg";
  color?: string;
  className?: string;
}

export const MiniSpinner: React.FC<MiniSpinnerProps> = ({ 
  size = "md", 
  color,
  className = ""
}) => {
  const sizeClass = size ? `mini-spinner--${size}` : "";
  const style = color ? { "--spinner-color": color } as React.CSSProperties : {};
  
  return (
    <div className={`mini-spinner ${sizeClass} ${className}`} style={style}>
      <div className="mini-pulse-spinner">
        <div className="mini-pulse-spinner-container">
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--1"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--2"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--3"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--4"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--5"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--6"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--7"></div>
          <div className="mini-pulse-spinner__nib mini-pulse-spinner__nib--8"></div>
        </div>
      </div>
    </div>
  );
};

\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\extra\Spinner.tsx
import "./spinner.css";

export const Spinner = () => {
  return (
    <div className="loading-spinner" style={{ animationDelay: "1000ms" }}>
      <div className="pulse-spinner">
        <div className="pulse-spinner-container">
          <div className="pulse-spinner__nib pulse-spinner__nib--1"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--2"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--3"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--4"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--5"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--6"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--7"></div>{" "}
          <div className="pulse-spinner__nib pulse-spinner__nib--8"></div>
        </div>
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\extra\TryAgain.tsx
interface TryAgainProps {
  errorName: string;
  errorMessage: string;
  onTryAgain: () => void;
}

export const TryAgain = ({
  errorMessage,
  errorName,
  onTryAgain,
}: TryAgainProps) => {
  return (
    <div className="w-fit h-[95vh] flex flex-col items-center justify-center text-center m-auto">
      <p style={{ textAlign: "center", fontWeight: 600 }}>{errorName}</p>
      <p style={{ color: "var(--systemSecondary)", maxWidth: "10rem" }}>
        {errorMessage}
      </p>
      <button id="TryAgainSearchButton" onClick={onTryAgain}>
        Try again
      </button>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\album\Album.tsx
import { PLACEHOLDER_IMAGE } from "@/lib/constants";
import { SoundCloudAlbum } from "@/lib/types/soundcloud";
import { usePlaylistFetcher } from "@/lib/audio/play";
import style from "./Album.module.css";
import Image from "next/image";
import React from "react";
import Link from "next/link";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { IoPlay } from "react-icons/io5";
import { PiShuffleBold } from "react-icons/pi";
import { Spinner } from "../../extra/Spinner";
import { Song } from "@/lib/audio/types";
import ContextMenu from "../../contextmenus/ContextMenu";
import { PrefetchLink } from "../../navigation/PrefetchLink";

export const Album = ({ data }: { data: SoundCloudAlbum }) => {
  if (!data) return <Spinner />;
  return (
    <div className="pb-20 p-4">
      <AlbumHeader data={data} />
      <SongList data={data.tracks} />
    </div>
  );
};

const AlbumHeader = ({ data }: { data: SoundCloudAlbum }) => {
  const HD_ARTWORK = data.artwork_url
    ? data.artwork_url.replace("-large.jpg", "-t500x500.jpg")
    : PLACEHOLDER_IMAGE.dark.url;
  return (
    <div className={style.AlbumHeader}>
      <div className={style.AlbumArtwork}>
        <Image
          src={HD_ARTWORK}
          alt={data.title || "Album artwork"}
          fill
          draggable={false}
          layout="fill"
        />
      </div>
      <AlbumInfoNControls data={data} />
    </div>
  );
};

const AlbumInfoNControls = ({ data }: { data: SoundCloudAlbum }) => {
  const { handleFetchPlaylist, shufflePlaylist } = usePlaylistFetcher();
  return (
    <div className={style.AlbumInfoNControls}>
      <div className={style.AlbumInfo}>
        <h1 className={style.AlbumTitle}>{data.title}</h1>
        <PrefetchLink
          href={`/artist/${data.user.permalink}/${data.user.id}`}
          className={style.AlbumArtist}
        >
          {data.user.username}
        </PrefetchLink>

        <span className={style.AlbumGenreNYear}>
          <p>{data.genre}</p>
          {" · "}
          <time dateTime={data.created_at} title={formatDate(data.created_at)}>
            {formatDate(data.created_at, "year")}
          </time>
        </span>
      </div>
      <div className={style.Controls}>
        <button onClick={() => handleFetchPlaylist(data.permalink_url)}>
          <IoPlay />
          Play
        </button>
        <button onClick={() => shufflePlaylist(data.permalink_url)}>
          <PiShuffleBold />
          Shuffle
        </button>
      </div>
    </div>
  );
};

// Convert SoundCloud track to Song format
const convertTrackToSong = (track: any): Song => {
  return {
    albumName: track.publisher_metadata
      ? (track.publisher_metadata as any).album_title || ""
      : "",
    artist: {
      id: track.user.id,
      name: track.user.username,
      url: `/artist/${track.user.permalink}/${track.user.id}`,
      soundcloudURL: track.user.permalink_url,
      permalink: track.user.permalink,
      verified: false,
      followers: 0,
      city: "",
      avatar: track.user.avatar_url,
    },
    artwork: {
      hdUrl: track.artwork_url
        ? track.artwork_url.replace("-large", "-t500x500")
        : "",
      url: track.artwork_url || "",
    },
    id: track.id,
    songHref: track.permalink_url,
    name: track.title,
    explicit: track.publisher_metadata
      ? track.publisher_metadata.explicit || false
      : false,
    src: "", // M3U8 will be fetched by the player
  };
};

const SongList = ({ data }: { data: SoundCloudAlbum["tracks"] }) => {
  const { setQueue } = useAudioStoreNew();
  const { currentSong } = useAudioStoreNew();

  const handlePlayFromIndex = async (index: number) => {
    try {
      // Create a queue starting from the clicked song
      const tracksFromIndex = data.slice(index);
      const songsToPlay = tracksFromIndex.map((track) =>
        convertTrackToSong(track)
      );

      // Set the queue with these songs
      await setQueue(songsToPlay);
    } catch (error) {
      console.error("Failed to play song from album:", error);
    }
  };

  return (
    <div className={style.SongList}>
      {data.map((track, index) => (
        <ContextMenu
          title={track.title}
          className={style.Song}
          as={"div"}
          type="song"
          itemId={String(track.id)}
          key={track.id}
        >
          <div
            onClick={() => handlePlayFromIndex(index)}
            className={style.SongIndex}
            style={{
              color:
                currentSong?.id === track.id
                  ? "var(--keyColor)"
                  : "var(--systemSecondary)",
            }}
          >
            {index + 1}
          </div>
          <div className={style.SongInfo}>
            <h3 className={style.SongTitle}>{track.title}</h3>
          </div>
        </ContextMenu>
      ))}
    </div>
  );
};

function formatDate(dateString: string | number | Date, format = "full") {
  const date = new Date(dateString);
  if (format === "year") {
    return date.getFullYear().toString();
  }
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "long",
    day: "numeric",
  };
  return date.toLocaleDateString("en-US", options);
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\artist\banner\Banner.tsx
"use client";

import React from "react";
import Image from "next/image";
import ReactPlayer from "react-player";
import style from "./Banner.module.css";
import { useQuery } from "@tanstack/react-query";
import { AppleKit } from "@/lib/audio/fetchers";
import { dev } from "@/lib/utils";
import { SoundCloudArtist } from "@/lib/types/soundcloud";
import { artistMappings } from "@/lib/artist";

type EditorialResult = {
  url?: string;
  bgColor?: string;
  animated?: string; // The editorial video URL
};

// 1) Helper function to parse editorial data:
function getFirstEditorialArtwork(appleData: any): EditorialResult {
  if (!appleData?.data?.length || !appleData?.resources) return {};

  for (const item of appleData.data) {
    if (item.type !== "artists") continue;
    const resource = appleData.resources.artists?.[item.id];
    if (!resource) continue;

    const { editorialVideo, editorialArtwork } = resource.attributes ?? {};

    // Check editorialVideo first
    if (editorialVideo) {
      // We loop in a preferred order
      for (const key of [
        "motionArtistWide16x9",
        "motionArtistFullscreen16x9",
        "motionArtistSquare1x1",
      ]) {
        const videoBlock = editorialVideo[key];
        if (videoBlock?.previewFrame?.url && videoBlock?.video) {
          return {
            url: videoBlock.previewFrame.url,
            bgColor: videoBlock.previewFrame.bgColor,
            animated: videoBlock.video,
          };
        }
      }
    }

    // Then editorialArtwork fallback
    const ed = editorialArtwork?.centeredFullscreenBackground;
    if (ed?.url) {
      return { url: ed.url, bgColor: ed.bgColor };
    }
  }

  return {};
}

// 2) Our React Query fetcher:
async function fetchAppleData(artist: SoundCloudArtist) {
  const rawUsername = artist.username ?? "";
  const mappedName = artistMappings[rawUsername] ?? rawUsername;
  const data = await AppleKit.getArtistData(mappedName);
  dev.log("fetchAppleData | Banner | AppleKit.getArtistData", data);
  return data;
}

export const Banner = ({ artist }: { artist: SoundCloudArtist | null }) => {
  const { data: apple } = useQuery({
    queryKey: ["appleData", artist?.id],
    queryFn: () => fetchAppleData(artist!),
    enabled: !!artist?.id, // Only fetch if we have a valid artist ID
    staleTime: 1000 * 60 * 60, // 1 hour in milliseconds
  });

  if (!artist) {
    return null;
  }

  // 3) Once loaded, parse editorial data:
  const {
    url: editorialUrl,
    bgColor,
    animated: editorialVideo,
  } = getFirstEditorialArtwork(apple);

  // Decide which display name to show if we have a video
  const scUsername = artist.username || "";
  const mappedName = artistMappings[scUsername] ?? scUsername;
  const displayName = editorialVideo ? mappedName : scUsername;

  // If there's a static editorialUrl, transform it
  const bannerWidth = "2000";
  const bannerHeight = "1000";
  const bannerCon = "ea-60";
  const bannerFormat = "jpg";

  const appleBannerUrl = editorialUrl
    ? editorialUrl.replace(
        /\/\{\w+\}x\{\w+\}\{\w*\}\.\{?\w+\}?/,
        `/${bannerWidth}x${bannerHeight}${bannerCon}.${bannerFormat}`
      )
    : undefined;

  // fallback from SoundCloud or local placeholder
  const scBanner = artist.visuals?.visuals?.[0]?.visual_url;
  const fallbackSrc = "/assets/placeholders/banner-placeholder.svg";
  const bannerSrc = appleBannerUrl || scBanner || fallbackSrc;

  // 4) Render
  return (
    <div
      className={style.Banner}
      style={{
        position: "relative",
        aspectRatio: editorialVideo ? "1478/600" : "1240/260",
        backgroundColor: bgColor ? `#${bgColor}` : undefined,
      }}
    >
      <div className={style.BannerOverlay}>
        <h1>{displayName}</h1>
      </div>

      {editorialVideo ? (
        <ReactPlayer
          url={editorialVideo}
          playing
          className={style.BannerVideo}
          loop
          muted
          playsinline
          width="100%"
          height="100%"
          style={{
            position: "absolute",
            top: 0,
            left: 0,
            overflow: "hidden",
            objectFit: "cover",
          }}
        />
      ) : (
        <Image
          fill
          priority
          style={{ objectFit: "cover" }}
          src={bannerSrc}
          alt={`${artist.username}'s Banner`}
        />
      )}
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\artist\Latest.tsx
import { SoundCloudArtist, SoundCloudTrack } from "@/lib/types/soundcloud";
import style from "./Artist.module.css";
import Image from "next/image";
import { PLACEHOLDER_IMAGE } from "@/lib/constants";
import Link from "next/link";

export const Latest = ({ artist }: { artist: SoundCloudArtist | null }) => {
  const latestTracks = artist?.latest || [];
  const latest = latestTracks.find((item) => item.type === "track");
  const track = latest.track as SoundCloudTrack;
  const HD_ARTWORK = track.artwork_url
    ? track.artwork_url.replace("-large.jpg", "-t500x500.jpg")
    : PLACEHOLDER_IMAGE.dark.url;
  return (
    <div className={style.Shelf} style={{ width: "fit-content" }}>
      <div className={style.ShelfHeader}>
        <button>
          <h1>Latest</h1>
        </button>
      </div>
      <div style={{ display: "flex", flexDirection: "column", width: "15rem" }}>
        <div className={style.Artwork}>
          <Image
            src={HD_ARTWORK}
            fill
            draggable={false}
            alt={track.title}
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        </div>
        <div className={style.LatestInfo}>
          <DateDisplay className={style.Date} date={track.display_date} />
          <Link
            passHref
            id="song-link"
            href={`/song/${track.permalink}/${track?.id}`}
            className="flex gap-1 items-center"
          >
            <button className="hover:underline text-left">{track.title}</button>
            {!track.publisher_metadata?.explicit && (
              <span className="text-[#aeaeae]">🅴</span>
            )}
          </Link>
          <Link
            id="artist-link"
            href={`/artist/${artist?.permalink}/${artist?.id}`}
            className="hover:underline"
          >
            {track.publisher_metadata?.artist}
          </Link>
        </div>
      </div>
    </div>
  );
};

const DateDisplay = ({
  date,
  className,
}: {
  date: string;
  className?: string;
}) => {
  const dateObj = new Date(date);
  return (
    <time dateTime={date}>
      <span
        className={className}
        title={dateObj.toLocaleDateString("en-US", {
          month: "long",
          day: "numeric",
          year: "numeric",
        })}
      >
        {dateObj
          .toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          })
          .toUpperCase()}
      </span>
    </time>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\artist\Spotlight.tsx
import Image from "next/image";
import style from "./Artist.module.css";
import { SoundCloudArtist } from "@/lib/types/soundcloud";
import { PLACEHOLDER_IMAGE } from "@/lib/constants";
import { usePlaylistFetcher } from "@/lib/audio/play";
import { useRouter } from "next/navigation";
import ContextMenu from "../../contextmenus/ContextMenu";

export const Spotlight = ({ artist }: { artist: SoundCloudArtist | null }) => {
  const songs = artist?.spotlight || [];
  const { handleFetchPlaylist } = usePlaylistFetcher();
  const router = useRouter();
  if (!songs.length) return null;
  return (
    <div className={style.Shelf}>
      <div className={style.ShelfHeader}>
        <button>
          <h1>Spotlight</h1>
        </button>
      </div>
      <section>
        <ul className={style.ShelfGrid}>
          {songs.map((song) => (
            <ShelfItem
              song={song}
              key={song.id}
              link={() =>
                router.push(
                  song.tracks
                    ? `/album/${song.permalink}/${song.id}`
                    : `/song/${song.permalink}/${song.id}`
                )
              }
              play={() =>
                handleFetchPlaylist(
                  song.tracks ? song.permalink_url : song.id,
                  !song.tracks
                )
              }
            />
          ))}
        </ul>
      </section>
    </div>
  );
};

export const ShelfItem: React.FC<{
  song: SoundCloudArtist["spotlight"][number];
  play?: () => void;
  link?: () => void;
}> = ({ song, play, link }) => {
  const isPlaylist = song.kind === "playlist";
  const year = getYear(song);
  let subtitle = "";
  if (song.tracks && song.tracks.length > 0) {
    subtitle = `Album · ${year}`;
  } else {
    if (isPlaylist) {
      if (song.set_type === "album") {
        subtitle = `Album · ${year}`;
      } else if (song.set_type === "ep") {
        subtitle = `EP · ${year}`;
      } else {
        subtitle = `${song.title} · ${year}`;
      }
    } else if (song.kind === "track") {
      subtitle = `${song.title} - Single · ${year}`;
    }
  }

  // console.log("ShelfItem", song);

  return (
    <ContextMenu
      title={song.title}
      className={style.ShelfItem}
      as={"button"}
      type="song"
      itemId={song.id}
      key={song.id}
    >
      <div>
        <div
          data-type={song.set_type}
          onClick={play}
          className={style.ShelfItemArtwork}
        >
          <Image
            style={{ aspectRatio: "1/1" }}
            src={
              song.tracks
                ? song.tracks[0].artwork_url
                : song.artwork_url_hd || PLACEHOLDER_IMAGE.dark.url
            }
            alt={song.title}
            fill
            draggable={false}
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        </div>
        <ul onClick={link}>
          <li>{song.title}</li>
          <li>
            <span>{subtitle}</span>
          </li>
        </ul>
      </div>
    </ContextMenu>
  );
};

export function getYear(item: any) {
  // For playlists, 'release_date' is typically the album/EP’s release
  // For tracks, fallback to 'display_date' if there's no 'release_date'
  const dateStr = item.release_date || item.display_date;
  if (!dateStr) return ""; // or "Unknown Year"
  return new Date(dateStr).getFullYear();
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\Content.tsx
"use client";
import React, { ReactNode } from "react";
import { ScrollPage } from "./ScrollPage";
import { Sidebar } from "../navigation/Sidebar";
import style from "./Main.module.css";
import { PlayerBar } from "../player/PlayerBar";
import { useIsPWA } from "@/hooks/useIsPWA";
import { MobileView } from "../mobile/MobileView";
import { useAudioStoreNew } from "@/context/AudioContextNew";

interface ContentProps {
  children?: ReactNode;
}

export const Content = ({ children }: ContentProps) => {
  const isPWA = useIsPWA();
  // Get fullscreen state from audio store
  const isFullscreen = useAudioStoreNew((state) => state.isFullscreen);

  return (
    <div aria-label="Content">
      {isPWA ? (
        <>
          <MobileView />
        </>
      ) : (
        <div className={`${style.Content} ${isFullscreen ? "invisible" : ""}`}>
          <Sidebar />
          <PlayerBar />
          <ScrollPage>{children}</ScrollPage>
        </div>
      )}
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\DynamicPage.tsx
import React, { ReactNode } from "react";
import style from "./Main.module.css";

interface DynamicPageProps {
  children?: ReactNode;
}

export const DynamicPage = ({ children }: DynamicPageProps) => {
  return (
    <main className={style.DynamicPage}>
      {children}
    </main>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\Footer.tsx
import React from "react";

export const Footer = () => {
  return (
    <div className="w-full h-full py-10 px-4 bg-[rgba(235,235,235,0.03)] border-t border-t-[var(--labelDivider)]">
      Footer
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\home\Sections.tsx
"use client";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import { SoundCloudSections } from "@/lib/types/soundcloud";
import { useQuery } from "@tanstack/react-query";
import { Spinner } from "../../extra/Spinner";
import style from "./Sections.module.css";
import Link from "next/link";
import Image from "next/image";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";
import { TryAgain } from "../../extra/TryAgain";
import { PrefetchLink } from "../../navigation/PrefetchLink";

export const Sections = () => {
  const { data, isLoading, error, refetch } = useQuery<SoundCloudSections>({
    queryKey: ["homeSections"],
    queryFn: SoundCloudKit.getHomeSections,
    staleTime: 1000 * 60 * 60, // 1 hour in milliseconds
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });
  const sections = data?.collection;
  if (isLoading && !sections) return <Spinner />;
  if (error)
    return (
      <>
        <p>Error</p>
        <TryAgain
          errorMessage={(error as Error).message}
          errorName={(error as Error).name}
          onTryAgain={() => {
            refetch();
          }}
        />
      </>
    );

  return sections && <Section data={sections} />;
};

const Section = ({ data }: { data: SoundCloudSections["collection"] }) => {
  return (
    <div className={style.section}>
      {data.map((section) => (
        <div className="mb-10" key={section.id}>
          <SectionHeader url={section.tracking_feature_name}>
            {section.title}
          </SectionHeader>
          <SectionItems items={section.items.collection} />
        </div>
      ))}
    </div>
  );
};

const SectionHeader = ({
  children,
  url,
}: {
  children: React.ReactNode;
  url: string;
}) => {
  return (
    <div className={style.sectionHeader}>
      <Link href={`/rooms/${url}`}>
        <h1>{children}</h1> <Chevron />
      </Link>
    </div>
  );
};

const Chevron = () => {
  return (
    <svg
      className={style.sectionHeaderChevron}
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 64 64"
      aria-hidden="true"
    >
      <path d="M19.817 61.863c1.48 0 2.672-.515 3.702-1.546l24.243-23.63c1.352-1.385 1.996-2.737 2.028-4.443 0-1.674-.644-3.09-2.028-4.443L23.519 4.138c-1.03-.998-2.253-1.513-3.702-1.513-2.994 0-5.409 2.382-5.409 5.344 0 1.481.612 2.833 1.739 3.96l20.99 20.347-20.99 20.283c-1.127 1.126-1.739 2.478-1.739 3.96 0 2.93 2.415 5.344 5.409 5.344Z"></path>
    </svg>
  );
};

type SectionItem =
  SoundCloudSections["collection"][number]["items"]["collection"][number];

const SectionItems = ({ items }: { items: SectionItem[] }) => {
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();
  const formatter = new Intl.NumberFormat("en-US", {
    notation: "compact",
    compactDisplay: "short",
  });
  return (
    <div className={style.sectionItems}>
      {items.map((item) => (
        <div className={style.sectionItem} key={item.id}>
          <Link
            className={style.sectionItemImage}
            style={
              item.kind === "user"
                ? { borderRadius: "50%" }
                : item.set_type === "album"
                ? undefined
                : undefined
            }
            href={
              item.kind === "user"
                ? `/artist/${item.permalink}/${item.id}`
                : item.set_type === "album"
                ? `/album/${item.permalink}/${item.id}`
                : `/playlist/${item.id}`
            }
          >
            <Image
              fill
              alt={item.title || "Image"}
              src={
                item.kind === "user"
                  ? item.avatar_url_hd || PLACEHOLDER_IMAGE
                  : item.artwork_url_hd || PLACEHOLDER_IMAGE
              }
            />
          </Link>
          <div className={style.sectionItemSubtitle}>
            <span>
              <PrefetchLink
                className="hover:underline decoration-[--keyColor]"
                href={
                  item.set_type === "album"
                    ? `/album/${item.permalink}/${item.id}`
                    : `/playlist/${item.id}`
                }
              >
                {item.kind === "user" ? (
                  <h3 className="w-fit">{item.username}</h3>
                ) : (
                  <h3 className="w-fit">{item.title}</h3>
                )}
              </PrefetchLink>
            </span>
            {item.kind === "user" ? (
              <p className="w-fit">
                {formatter.format(item.followers_count) + " followers"}
              </p>
            ) : (
              <PrefetchLink
                className="hover:underline decoration-[--keyColor]"
                href={`/artist/${item.user?.permalink}/${item.user?.id}`}
              >
                <p className="w-fit">{item.user?.username}</p>
              </PrefetchLink>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\home\Welcome.tsx
import { currentUser } from "@clerk/nextjs/server";

const getGreeting = () => {
  const now = new Date();
  const hours = now.getHours();
  const month = now.getMonth() + 1; // Months are 0-indexed
  const day = now.getDate();

  // Define holidays
  const holidays = [
    { date: "1-1", greeting: "Happy New Year" },
    { date: "2-14", greeting: "Happy Valentine's Day" },
    { date: "3-17", greeting: "Happy St. Patrick's Day" },
    { date: "4-1", greeting: "Happy April Fools' Day" },
    { date: "4-9", greeting: "Happy Easter" }, // Example Easter date, update yearly
    { date: "10-31", greeting: "Happy Halloween" },
    { date: "12-25", greeting: "Merry Christmas" },
    { date: "12-31", greeting: "Happy New Year's Eve" },
    { date: "11-24", greeting: "Happy Thanksgiving" }, // Example Thanksgiving, update yearly
    { date: "7-4", greeting: "Happy Independence Day" },
  ];

  // Check for holidays
  const today = `${month}-${day}`;
  const holiday = holidays.find((h) => h.date === today);
  if (holiday) return holiday.greeting;

  // Time of day greetings
  if (hours < 12) return "Good morning";
  if (hours < 18) return "Good afternoon";
  if (hours < 22) return "Good evening";
  return "Goodnight";
};

export const Welcome = async () => {
  const greeting = getGreeting();
  const user = await currentUser();
  return (
    <div className="p-4">
      <h1 className="text-3xl font-[700]">Home</h1>
      <p className="text-lg font-[500] text-[--systemSecondary]">
        {greeting}
        {user && `, ${user?.username || user?.fullName || user?.firstName}`}
      </p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\albums\LibraryAlbums.tsx
import React from "react";

export const LibraryAlbums = () => {
  return (
    <div className="p-4">
      <h2 className="text-3xl font-bold mb-4">Albums</h2>
      <p>The albums page isn&apos;t finished yet</p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\artist\LibraryArtists.tsx
import React from "react";

export const LibraryArtists = () => {
  return (
    <div className="p-4">
      <h2 className="text-3xl font-bold mb-4">Artists</h2>
      <p>The artists page isn&apos;t finished yet</p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\LibraryItem.tsx
import { SoundCloudTrack } from "@/lib/types/soundcloud";
import style from "./Library.module.css";
import Image from "next/image";
import { PLACEHOLDER_IMAGE } from "@/lib/constants";
import Link from "next/link";
import ContextMenu from "../../contextmenus/ContextMenu";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { Song } from "@/lib/audio/types";

interface LibraryItem {
  scTrack: SoundCloudTrack | undefined;
  id: string;
  createdAt: string;
  updatedAt: string;
}

// Convert SoundCloud track to Song format
const convertTrackToSong = (track: SoundCloudTrack): Song => {
  return {
    albumName: track.publisher_metadata
      ? (track.publisher_metadata as any).album_title || ""
      : "",
    artist: {
      id: track.user.id,
      name: track.user.username,
      url: `/artist/${track.user.permalink}/${track.user.id}`,
      soundcloudURL: track.user.permalink_url,
      permalink: track.user.permalink,
      verified: false,
      followers: 0,
      city: "",
      avatar: track.user.avatar_url,
    },
    artwork: {
      hdUrl: track.artwork_url?.replace("-large", "-t500x500") || "",
      url: track.artwork_url || "",
    },
    id: track.id,
    songHref: track.permalink_url,
    name: track.title,
    explicit: track.publisher_metadata
      ? track.publisher_metadata.explicit || false
      : false,
    src: "", // M3U8 will be fetched by the player
  };
};

export const LibraryItem = ({
  item,
  allItems,
  ref,
  ...liProps
}: {
  item: LibraryItem;
  allItems: LibraryItem[];
  ref?: React.Ref<HTMLLIElement>;
} & React.HTMLAttributes<HTMLLIElement>) => {
  const { setQueue } = useAudioStoreNew();

  const handlePlay = async () => {
    if (!item.scTrack) return;
    try {
      const currentIndex = allItems.findIndex((i) => i.id === item.id);
      const relevantItems = allItems
        .slice(currentIndex)
        .filter((i) => i.scTrack);
      const songsToPlay = relevantItems.map((i) =>
        convertTrackToSong(i.scTrack!)
      );
      await setQueue(songsToPlay);
    } catch (error) {
      console.error("Failed to play song from library:", error);
    }
  };

  return (
    <ContextMenu
      as={"li"}
      ref={ref as React.Ref<any>}
      className={style.libraryItem}
      type="song"
      itemId={item.id}
      {...liProps}
    >
      <div
        className={style.image}
        onClick={handlePlay}
        role="button"
        aria-label={`Play ${item.scTrack?.title ?? "Unknown track"}`}
      >
        <Image
          src={item.scTrack?.artwork_url ?? PLACEHOLDER_IMAGE.dark.url}
          alt={item.scTrack?.title ?? "Track artwork"}
          fill
          draggable={false}
        />
      </div>
      <div className={style.details}>
        <h3>{item.scTrack?.title ?? "Unknown title"}</h3>
        <Link
          href={`/artist/${item.scTrack?.user.permalink}/${item.scTrack?.user.id}`}
        >
          {item.scTrack?.user.username ?? "Unknown artist"}
        </Link>
      </div>
    </ContextMenu>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\LibraryPage.tsx
"use client";
import { useEffect, useState } from "react";
import { useUser } from "@/hooks/useUser";
import { SoundCloudKit } from "@/lib/audio/fetchers";
import type { SoundCloudTrack } from "@/lib/types/soundcloud";
import { Spinner } from "@/rework/components/extra/Spinner";
import { LibraryItem } from "@/rework/components/main/library/LibraryItem";
import style from "../../../../rework/components/main/library/Library.module.css";
import { AnimatePresence, motion } from "framer-motion";

export default function LibrarySongs() {
  const { librarySongs, isLoading, error, addSongToLibrary } = useUser();
  const [scTracks, setSCTracks] = useState<SoundCloudTrack[]>([]);

  useEffect(() => {
    // If we have no librarySongs or still loading from DB, skip
    if (!librarySongs) return;
    if (librarySongs.length === 0) {
      // If the user has no songs in their library, no need to fetch SC data
      setSCTracks([]);
      return;
    }
    // Sort library songs by createdAt (descending: newest first)
    const sorted = [...librarySongs].sort(
      (a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
    // Build comma-separated ID list
    // Fetch each track individually
    const fetchTracks = async () => {
      try {
        const trackPromises = sorted.map((song) =>
          SoundCloudKit.getData(song.id, "songs")
        );
        const results = await Promise.all(trackPromises);
        setSCTracks(results);
      } catch (err) {
        console.error("Failed to fetch SoundCloud data:", err);
        setSCTracks([]);
      }
    };

    fetchTracks();
  }, [librarySongs]);

  // Merge DB songs + SC data
  const sortedLibrarySongs = [...(librarySongs ?? [])].sort(
    (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  );

  const merged = sortedLibrarySongs.map((dbSong) => {
    const scTrack = scTracks.find(
      (track) => track.id === parseInt(dbSong.id, 10)
    );
    return {
      ...dbSong,
      scTrack,
    };
  });

  if (isLoading) return <Spinner />;
  if (error) return <div>Error: {(error as Error).message}</div>;

  const handleAddSong = async () => {
    try {
      await addSongToLibrary("1996361439");
      console.log("Song added successfully");
    } catch (err) {
      console.error("Failed to add song:", err);
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-3xl font-bold mb-4">Library</h2>
      {merged.length === 0 ? (
        <EmptyLibrary />
      ) : (
        <ul className={style.libraryList}>
          {merged.map((item) => (
            <LibraryItem key={item.id} item={item} allItems={merged} />
          ))}
        </ul>
      )}
    </div>
  );
}

type Note = {
  id: number;
  x: number;
  y: number;
  pathIndex: number;
  scale: number;
  rotation: number;
  targetX: number;
  targetY: number;
  finalRotation: number;
  duration: number;
};

const EmptyLibrary = () => {
  const [notes, setNotes] = useState<Note[]>([]);

  // Music note SVG paths
  const notePaths = [
    "M8.38998 4.75975C8.97778 4.61491 9.14398 4.47874 9.14398 3.79061V1.48624C9.14398 1.01139 8.95998 0.807961 8.33048 0.962411L4.90528 1.81577C4.31208 1.96061 4.17688 2.09467 4.17688 2.79663V7.9362C4.17688 8.4371 4.13418 8.5257 3.56938 8.6717L2.49968 8.9605C1.39318 9.2426 0.523682 9.9029 0.523682 11.0429C0.523682 12.058 1.29478 12.7909 2.47718 12.7909C4.16558 12.7909 5.31708 11.585 5.31708 9.871V5.98741C5.31708 5.5728 5.40988 5.47038 5.65298 5.4235L8.38998 4.75975Z",
    "M13.9771 5.763C14.8112 5.57659 15.0498 5.39069 15.0699 4.42812L15.142 0.982802C15.1559 0.318572 14.9021 0.0289427 14.0088 0.227651L6.61763 1.87972C5.77592 2.06598 5.58112 2.24978 5.56058 3.2317L5.4102 10.421C5.39555 11.1217 5.33267 11.2445 4.53102 11.4331L3.01237 11.8076C1.44197 12.1718 0.195093 13.0715 0.161737 14.6661C0.132036 16.0861 1.19923 17.1325 2.86853 17.1651C5.2522 17.2116 6.91317 15.5564 6.96332 13.1589L7.07695 7.72642C7.08908 7.14646 7.22309 7.00575 7.56767 6.94687L13.9771 5.763Z M15.106 5.24877C15.1199 4.58255 15.121 4.53188 15.1411 3.56931L15.158 2.76417C15.1719 2.09994 15.1349 1.34185 15.1434 0.939705L14.6181 0.770083C13.7764 0.956349 13.5816 1.14015 13.561 2.12207L13.4106 9.31139C13.396 10.0121 13.3331 10.1348 12.5315 10.3235L11.0128 10.698C9.44241 11.0621 8.19553 11.9618 8.16218 13.5565C8.13247 14.9764 9.19966 16.0229 10.869 16.0554C13.2526 16.1019 14.9136 14.4468 14.9638 12.0492L15.0774 6.61679C15.0895 6.03682 15.0866 6.17459 15.0929 5.87425L15.106 5.24877Z",
  ];

  const particles = () => {
    // Create notes with pre-calculated animation values
    const newNotes = Array.from({ length: 4 }).map((_, i) => {
      const initialRotation = Math.random() * 20 - 10; // Small initial tilt between -10 and 10 degrees
      return {
        id: Date.now() + i,
        x: 0,
        y: 0,
        pathIndex: Math.floor(Math.random() * notePaths.length),
        scale: 0.5 + Math.random() * 0.5,
        rotation: initialRotation,
        targetX: (Math.random() - 0.5) * 150, // Less horizontal movement
        targetY: -60 - Math.random() * 40, // Less vertical movement
        finalRotation: initialRotation + (Math.random() * 40 - 20), // Gentle rotation between -20 and +20 degrees
        duration: 2.5 + Math.random(), // Slower duration between 2.5 and 3.5 seconds
      };
    });

    setNotes([...notes, ...newNotes]);

    // Clean up old notes
    setTimeout(() => {
      setNotes((prev) => prev.filter((note) => note.id !== newNotes[0].id));
    }, 3500); // Extended timeout to match the longer animation
  };

  return (
    <div className="text-center flex flex-col items-center justify-end h-[50vh] relative overflow-hidden">
      <div className="mb-4">
        <li className="flex h-10 w-[7.5rem] p-1 gap-0.5 bg-white/10 rounded-lg">
          <motion.div
            onClick={particles}
            className="h-full w-10 aspect-square rounded-[4px] transition-all bg-white/10 active:scale-50 cursor-pointer relative"
            whileHover={{ backgroundColor: "rgba(255, 255, 255, 0.15)" }}
            // whileTap={{ scale: 0.95 }}
          >
            <AnimatePresence>
              {notes.map((note) => (
                <motion.svg
                  key={note.id}
                  viewBox="0 0 24 24"
                  className="absolute h-6 w-6 text-[--systemSecondary] fill-current z-10"
                  style={{ bottom: 24, left: "50%", marginLeft: "-12px" }}
                  initial={{
                    y: 0,
                    x: 0,
                    opacity: 0,
                    scale: note.scale,
                    rotate: note.rotation,
                  }}
                  animate={{
                    y: note.targetY,
                    x: note.targetX,
                    opacity: [0, 1, 0.8, 0],
                    rotate: note.finalRotation,
                  }}
                  exit={{ opacity: 0 }}
                  transition={{
                    duration: note.duration,
                    ease: "easeOut",
                  }}
                >
                  <path d={notePaths[note.pathIndex]} />
                </motion.svg>
              ))}
            </AnimatePresence>
          </motion.div>
          <div className="grid w-full gap-0.5">
            <div className="size-full bg-white/10 rounded-[4px]" />
            <div className="h-3/4 w-1/2 bg-white/10 rounded-[4px]" />
          </div>
        </li>
      </div>
      <h2 className="text-lg opacity-75">Your library is empty</h2>
      <p className="text-[--systemSecondary] w-60">
        Add some songs to your library to see them here.
      </p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\me\UserLikesPage.tsx
"use client";
import { useRef, useState } from "react";
import { useUser } from "@/hooks/useUser";
import { Spinner } from "@/rework/components/extra/Spinner";
import { LibraryItem } from "@/rework/components/main/library/LibraryItem";
import style from "@/rework/components/main/library/Library.module.css";
import { useVirtualizer } from "@tanstack/react-virtual";
import type { SoundCloudTrack } from "@/lib/types/soundcloud";
import { dev } from "@/lib/utils";
import { AnimatePresence, motion } from "framer-motion";

export default function UserLikedSongs({ user }: { user: any }) {
  const { isLoading, error } = useUser();
  const parentRef = useRef<HTMLDivElement>(null);
  const [visibleCount, setVisibleCount] = useState(100); // Start with 100 items

  // Extract and transform liked tracks
  const likedTracks = user?.userLikes?.collection || [];
  const transformedTracks = likedTracks
    .filter((like: any) => like.track)
    .map((like: any) => ({
      id: like?.track.id.toString(),
      createdAt: like.created_at,
      updatedAt: like.created_at,
      scTrack: like.track as SoundCloudTrack,
    }));

  const rowVirtualizer = useVirtualizer({
    count: visibleCount,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 60, // Adjust item height estimation
    overscan: 10, // Load extra items for smooth scrolling
  });

  if (isLoading) return <Spinner />;
  if (error) return <div>Error: {(error as Error).message}</div>;

  dev.log("User", user);
  dev.log("Liked Tracks", likedTracks);
  dev.log("Transformed Tracks", transformedTracks);

  return (
    <div className="p-4 mb-14">
      <div className="mb-4">
        <h1 className="text-3xl font-bold">
          Liked Songs
          <code
            title="Amount liked"
            className="bg-white/15 opacity-50 text-sm border border-[--labelDivider] mx-2 px-1 rounded"
          >
            {transformedTracks.length}
          </code>
        </h1>
        <p className="text-[--systemSecondary]">
          Here&apos;s your collection of liked songs from SoundCloud.
        </p>
      </div>
      {transformedTracks.length === 0 ? (
        <EmptyLibrary />
      ) : (
        <>
          <div ref={parentRef}>
            <ul
              className={style.libraryList}
              style={{
                height: `${rowVirtualizer.getTotalSize()}px`,
                position: "relative",
              }}
            >
              {rowVirtualizer.getVirtualItems().map((virtualItem: any) => {
                const item = transformedTracks[virtualItem.index];
                return (
                  <LibraryItem
                    key={item.id}
                    ref={virtualItem.measureRef}
                    style={{
                      position: "absolute",
                      top: 0,
                      left: 0,
                      width: "100%",
                      transform: `translateY(${virtualItem.start}px)`,
                    }}
                    item={item}
                    allItems={transformedTracks}
                  />
                );
              })}
            </ul>
          </div>

          {/* Load More Button */}
          {visibleCount < transformedTracks.length && (
            <div className="mt-4 flex justify-center">
              <button
                className="bg-white/10 text-white py-2 px-4 rounded-md hover:bg-white/15 transition"
                onClick={() => setVisibleCount((prev) => prev + 100)}
              >
                Load More
              </button>
            </div>
          )}
        </>
      )}
    </div>
  );
}

type Note = {
  id: number;
  x: number;
  y: number;
  pathIndex: number;
  scale: number;
  rotation: number;
  targetX: number;
  targetY: number;
  finalRotation: number;
  duration: number;
};

const EmptyLibrary = () => {
  const [notes, setNotes] = useState<Note[]>([]);

  // Music note SVG paths
  const notePaths = [
    "M8.38998 4.75975C8.97778 4.61491 9.14398 4.47874 9.14398 3.79061V1.48624C9.14398 1.01139 8.95998 0.807961 8.33048 0.962411L4.90528 1.81577C4.31208 1.96061 4.17688 2.09467 4.17688 2.79663V7.9362C4.17688 8.4371 4.13418 8.5257 3.56938 8.6717L2.49968 8.9605C1.39318 9.2426 0.523682 9.9029 0.523682 11.0429C0.523682 12.058 1.29478 12.7909 2.47718 12.7909C4.16558 12.7909 5.31708 11.585 5.31708 9.871V5.98741C5.31708 5.5728 5.40988 5.47038 5.65298 5.4235L8.38998 4.75975Z",
    "M13.9771 5.763C14.8112 5.57659 15.0498 5.39069 15.0699 4.42812L15.142 0.982802C15.1559 0.318572 14.9021 0.0289427 14.0088 0.227651L6.61763 1.87972C5.77592 2.06598 5.58112 2.24978 5.56058 3.2317L5.4102 10.421C5.39555 11.1217 5.33267 11.2445 4.53102 11.4331L3.01237 11.8076C1.44197 12.1718 0.195093 13.0715 0.161737 14.6661C0.132036 16.0861 1.19923 17.1325 2.86853 17.1651C5.2522 17.2116 6.91317 15.5564 6.96332 13.1589L7.07695 7.72642C7.08908 7.14646 7.22309 7.00575 7.56767 6.94687L13.9771 5.763Z M15.106 5.24877C15.1199 4.58255 15.121 4.53188 15.1411 3.56931L15.158 2.76417C15.1719 2.09994 15.1349 1.34185 15.1434 0.939705L14.6181 0.770083C13.7764 0.956349 13.5816 1.14015 13.561 2.12207L13.4106 9.31139C13.396 10.0121 13.3331 10.1348 12.5315 10.3235L11.0128 10.698C9.44241 11.0621 8.19553 11.9618 8.16218 13.5565C8.13247 14.9764 9.19966 16.0229 10.869 16.0554C13.2526 16.1019 14.9136 14.4468 14.9638 12.0492L15.0774 6.61679C15.0895 6.03682 15.0866 6.17459 15.0929 5.87425L15.106 5.24877Z",
  ];

  const particles = () => {
    // Create notes with pre-calculated animation values
    const newNotes = Array.from({ length: 4 }).map((_, i) => {
      const initialRotation = Math.random() * 20 - 10; // Small initial tilt between -10 and 10 degrees
      return {
        id: Date.now() + i,
        x: 0,
        y: 0,
        pathIndex: Math.floor(Math.random() * notePaths.length),
        scale: 0.5 + Math.random() * 0.5,
        rotation: initialRotation,
        targetX: (Math.random() - 0.5) * 150, // Less horizontal movement
        targetY: -60 - Math.random() * 40, // Less vertical movement
        finalRotation: initialRotation + (Math.random() * 40 - 20), // Gentle rotation between -20 and +20 degrees
        duration: 2.5 + Math.random(), // Slower duration between 2.5 and 3.5 seconds
      };
    });

    setNotes([...notes, ...newNotes]);

    // Clean up old notes
    setTimeout(() => {
      setNotes((prev) => prev.filter((note) => note.id !== newNotes[0].id));
    }, 3500); // Extended timeout to match the longer animation
  };

  return (
    <div className="text-center flex flex-col items-center justify-end h-[50vh] relative overflow-hidden">
      <div className="mb-4">
        <li className="flex h-10 w-[7.5rem] p-1 gap-0.5 bg-white/10 rounded-lg">
          <motion.div
            onClick={particles}
            className="h-full w-10 aspect-square rounded-[4px] transition-all bg-white/10 active:scale-50 cursor-pointer relative"
            whileHover={{ backgroundColor: "rgba(255, 255, 255, 0.15)" }}
            // whileTap={{ scale: 0.95 }}
          >
            <AnimatePresence>
              {notes.map((note) => (
                <motion.svg
                  key={note.id}
                  viewBox="0 0 24 24"
                  className="absolute h-6 w-6 text-[--systemSecondary] fill-current z-10"
                  style={{ bottom: 24, left: "50%", marginLeft: "-12px" }}
                  initial={{
                    y: 0,
                    x: 0,
                    opacity: 0,
                    scale: note.scale,
                    rotate: note.rotation,
                  }}
                  animate={{
                    y: note.targetY,
                    x: note.targetX,
                    opacity: [0, 1, 0.8, 0],
                    rotate: note.finalRotation,
                  }}
                  exit={{ opacity: 0 }}
                  transition={{
                    duration: note.duration,
                    ease: "easeOut",
                  }}
                >
                  <path d={notePaths[note.pathIndex]} />
                </motion.svg>
              ))}
            </AnimatePresence>
          </motion.div>
          <div className="grid w-full gap-0.5">
            <div className="size-full bg-white/10 rounded-[4px]" />
            <div className="h-3/4 w-1/2 bg-white/10 rounded-[4px]" />
          </div>
        </li>
      </div>
      <h2 className="text-lg opacity-75">Your liked songs library is empty</h2>
      <p className="text-[--systemSecondary] w-60">
        Add your userID in settings or add some songs to your likes on
        SoundCloud to see them here.
      </p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\library\recently-added\RecentlyAdded.tsx
import React from "react";

export const RecentlyAdded = () => {
  return (
    <div className="p-4">
      <h2 className="text-3xl font-bold mb-4">Recently Added</h2>
      <p>The recently added page isn&apos;t finished yet</p>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\main\ScrollPage.tsx
import React, { ReactNode } from "react";
import { Footer } from "./Footer";
import style from "./Main.module.css";
import { DynamicPage } from "./DynamicPage";

interface ScrollPageProps {
  children?: ReactNode;
}

export const ScrollPage = ({ children }: ScrollPageProps) => {
  return (
    <div className={style.ScrollPage}>
      <DynamicPage key={1}>{children}</DynamicPage>
      {/* <Footer /> */}
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\mobile\MobileView.tsx
import React from "react";
import { NavigationBar } from "./navigation/NavigationBar";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import Link from "next/link";

export const MobileView = () => {
  const { currentSong } = useAudioStoreNew();
  return (
    <div>
      {/* MobileView */}
      <p>PWA View isn&apos;t complete yet</p>
      <Link href={"/album/2093/1776273075"}>Link to Yeat - 2093 | Album</Link>
      <NavigationBar song={currentSong} />
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\mobile\navigation\NavigationBar.tsx
import React from "react";
import style from "./Navigation.module.css";
import { Artwork } from "../../player/Artwork";
import { Song } from "@/lib/audio/types";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";

export const NavigationBar = ({ song }: { song: Song | any }) => {
  return (
    <div className={style.NavigationBar}>
      <div className={style.NavigationContent}>
        <TrackContent song={song} />
        <Controls />
      </div>
    </div>
  );
};

const Controls = () => {
  return (
    <div className={style.Controls}>
      <button className={style.Button}>Home</button>
      <button className={style.Button}>Search</button>
      <button className={style.Button}>Library</button>
    </div>
  );
};

const TrackContent = ({ song }: { song: Song | undefined }) => {
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();
  return (
    <div className={style.TrackContent}>
      <Artwork
        src={song?.artwork.hdUrl || song?.artwork.url || PLACEHOLDER_IMAGE}
      />
      <div className={style.TrackInfo}>
        <h3 className={style.TrackTitle}>
          {!song ? "Not Playing" : `${song.name}`}
        </h3>
      </div>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\PrefetchLink.tsx


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\search\page\Banner.tsx
import style from "./Banner.module.css";

export const Banner = ({ query }: { query: string }) => {
  return (
    <div className={style.Banner}>
      Showing results for “<mark>{query}</mark>”
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\search\page\SearchResults.tsx
"use client";
import React from "react";
import Image from "next/image";
import styles from "./SearchResults.module.css";
import { getYear } from "@/rework/components/main/artist/Spotlight";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";
import { usePlaylistFetcher } from "@/lib/audio/play";
import Link from "next/link";
import { useRouter } from "next/navigation";
import ContextMenu from "@/rework/components/contextmenus/ContextMenu";

type SoundCloudItem = {
  kind: string;
  id?: number | string;
  permalink?: string;
  permalink_url?: string;
  artwork_url?: string | null;
  avatar_url?: string | null;
  title?: string;
  username?: string;
  tracks?: Array<{ artwork_url: string }>;
  release_date?: string;
  display_date?: string;
  publisher_metadata: {
    id?: number;
    artist?: string;
    album_title?: string;
    // ...
    explicit?: boolean;
  };
  user?: {
    username: string;
  };
};

type FullData = {
  collection: SoundCloudItem[];
};

type SearchResultsProps = {
  data: {
    full: FullData;
  };
};

export default function SearchResults({ data }: SearchResultsProps) {
  const { handleFetchPlaylist } = usePlaylistFetcher();
  const router = useRouter();
  if (!data || !data.full || !data.full.collection) return null;

  let topArtist: SoundCloudItem | null = null;
  const topAlbums: SoundCloudItem[] = [];
  const songs: SoundCloudItem[] = [];
  const otherAlbums: SoundCloudItem[] = [];

  // Separate items into artist, albums, or tracks
  for (const item of data.full.collection) {
    if (item.kind === "user" && !topArtist) {
      topArtist = item;
    } else if (item.kind === "playlist") {
      if (topAlbums.length < 3) {
        topAlbums.push(item);
      } else {
        otherAlbums.push(item);
      }
    } else if (item.kind === "track") {
      songs.push(item);
    }
  }

  return (
    <div className={styles.searchResultsContainer}>
      {/* Top Results */}
      <h2 className={styles.sectionTitle}>Top Results</h2>
      <ul className={styles.topResultsWrapper}>
        {topArtist ? <ArtistCard item={topArtist} /> : null}
        {topAlbums.map((album, idx) => (
          <AlbumCard
            key={`top-album-${idx}`}
            item={album}
            onClick={() => router.push(`/album/${album.permalink}/${album.id}`)}
            // onPlay={() =>
            //   handleFetchPlaylist(album.permalink_url, false /* isID? */)
            // }
          />
        ))}
      </ul>

      {/* Songs */}
      {songs.length > 0 && (
        <>
          <h2 className={styles.sectionTitle}>Songs</h2>
          <div className={styles.cardsContainer}>
            {songs.map((song, idx) => (
              <SongCard
                key={`song-${idx}`}
                item={song}
                onPlay={() => handleFetchPlaylist(song.id, true /* isID */)}
              />
            ))}
          </div>
        </>
      )}

      {/* Additional Albums */}
      {otherAlbums.length > 0 && (
        <>
          <h2 className={styles.sectionTitle}>Albums</h2>
          <div className={styles.cardsContainer}>
            {otherAlbums.map((album, idx) => (
              <AlbumCard
                key={`album-${idx}`}
                item={album}
                // onClick={() => handleFetchPlaylist(album.permalink_url, false)}
              />
            ))}
          </div>
        </>
      )}
    </div>
  );
}

/** Artist Card */
function ArtistCard({ item }: { item: SoundCloudItem }) {
  const avatar = item.avatar_url || "/placeholder-user.jpg";
  return (
    <li>
      <Link
        href={`/artist/${item.permalink}/${item.id}`}
        className={styles.artistCard}
      >
        <div className={styles.avatarWrapper}>
          <Image src={avatar} alt={item.username || "Artist"} fill />
        </div>
        <div title={item.username} className={styles.artistInfo}>
          <h1>{item.username}</h1>
          <p>Artist</p>
        </div>
      </Link>
    </li>
  );
}

/** Playlist/Album Card */
function AlbumCard({
  item,
  onClick,
}: {
  item: SoundCloudItem;
  onClick?: () => void;
}) {
  const THEMED_DEFAULT_IMAGE = useThemedPlaceholder();
  const artwork =
    item.artwork_url || item.tracks?.[0]?.artwork_url || THEMED_DEFAULT_IMAGE;
  const isPlaylist = item.kind === "playlist" ? false : true;
  return (
    <Link
      href={
        isPlaylist
          ? `/playlist/${item.id}`
          : `/album/${item.permalink}/${item.id}`
      }
      className={styles.albumCard}
    >
      <div onClick={onClick} className={styles.albumArtworkWrapper}>
        <Image
          src={artwork}
          alt={item.title || isPlaylist ? "Playlist" : "Album"}
          fill
        />
        <div className={styles.artworkOverlay} />
      </div>
      <div title={item.title} className={styles.albumInfo}>
        <h1>{item.title}</h1>
        <p>
          {isPlaylist ? "Playlist" : "Album"} ·{" "}
          {item.release_date || item.display_date ? getYear(item) : null}
        </p>
      </div>
    </Link>
  );
}

/** Track Card */
function SongCard({
  item,
  onPlay,
}: {
  item: SoundCloudItem;
  onPlay: () => void;
}) {
  const THEMED_DEFAULT_IMAGE = useThemedPlaceholder();
  const artwork = item.artwork_url || THEMED_DEFAULT_IMAGE;
  const artist = item.publisher_metadata?.artist || item.user?.username;

  return (
    <ContextMenu
      className={styles.songCard}
      as={"li"}
      type="song"
      title={item.title}
      itemId={String(item.id)}
    >
      <button onClick={onPlay} className={styles.songArtworkWrapper}>
        <Image
          src={artwork}
          alt={item.title || "Track"}
          width={150}
          height={150}
        />
      </button>
      <div className={styles.songInfo}>
        <span
          title={item.title}
          aria-label={`Name of the track: ${item.title}`}
          className="flex gap-1"
        >
          <h1>{item.title}</h1>
          {item.publisher_metadata?.explicit && (
            <span className="text-[#aeaeae]">🅴</span>
          )}
        </span>
        {artist && <p title={artist}>{artist}</p>}
      </div>
    </ContextMenu>
  );
}


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\search\Search.tsx
"use client";
import { useRouter } from "next/navigation";
import useSearch from "@/hooks/useSearch";
import { SearchBar } from "./SearchBar";
import SearchDropdown from "./SearchDropdown";

const Search = () => {
  const router = useRouter();
  const { query, results, showDropdown, handleInputChange, setShowDropdown } =
    useSearch("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      router.push(`/search?q=${encodeURIComponent(query)}`);
      setShowDropdown(false);
    }
  };

  const handleBlur = () => {
    // Use setTimeout to allow click events on dropdown to fire first
    setTimeout(() => {
      setShowDropdown(false);
    }, 200);
  };

  return (
    <div className="relative">
      <SearchBar
        query={query}
        placeholder="Search"
        handleInputChange={(e) => handleInputChange(e.target.value)}
        onBlur={handleBlur}
        onSubmit={handleSubmit}
      />
      {showDropdown && results && (
        <SearchDropdown
          typedQuery={query}
          results={results}
          setShowDropdown={setShowDropdown}
        />
      )}
    </div>
  );
};

export default Search;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\search\SearchBar.tsx
"use client";
import { InputHTMLAttributes } from "react";
import style from "./SearchBar.module.css";

interface SearchBarProps extends InputHTMLAttributes<HTMLInputElement> {
  query: string;
  placeholder: string;
  handleInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur: () => void;
  onSubmit: (event: React.FormEvent) => void;
}

export const SearchBar: React.FC<SearchBarProps> = ({
  query,
  placeholder,
  handleInputChange,
  onBlur,
  onSubmit,
  ...props
}) => {
  return (
    <div className={style.SearchBarWrapper}>
      <div className={style.SearchBar}>
        <form role="search" onSubmit={onSubmit}>
          <SearchIcon />
          <input
            value={query}
            onChange={handleInputChange}
            onBlur={onBlur}
            placeholder={placeholder}
            className={style.SearchInput}
            type="search"
            aria-autocomplete="list"
            aria-multiline="false"
            aria-label="Search"
            aria-controls="search-suggestions"
            spellCheck="false"
            autoComplete="off"
            autoCorrect="off"
            {...props}
          />
        </form>
      </div>
    </div>
  );
};

export const SearchIcon = () => {
  return (
    <svg
      height="14"
      width="14"
      style={{
        fill: "var(--SearchIcon-fill)",
        position: "absolute",
        top: "20px",
        insetInlineStart: "10px",
      }}
      viewBox="0 0 16 16"
      className="search-svg"
      aria-hidden="true"
    >
      <path d="M11.87 10.835c.018.015.035.03.051.047l3.864 3.863a.735.735 0 1 1-1.04 1.04l-3.863-3.864a.744.744 0 0 1-.047-.051 6.667 6.667 0 1 1 1.035-1.035zM6.667 12a5.333 5.333 0 1 0 0-10.667 5.333 5.333 0 0 0 0 10.667z"></path>
    </svg>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\search\SearchDropdown.tsx
import React from "react";
import { AnimatePresence, motion } from "framer-motion";
import {
  SoundCloudAlbum,
  SoundCloudArtist,
  SoundCloudSearchResult,
} from "@/lib/types/soundcloud";
import Link from "next/link";
import "./SearchDropDown.css";
import Image from "next/image";
import { PLACEHOLDER_IMAGE } from "@/lib/constants";
import { useUser } from "@/hooks/useUser";

interface SearchDropdownProps {
  results: SoundCloudSearchResult;
  typedQuery: string;
  setShowDropdown: (value: boolean) => void;
}

function highlightText(text: string, query: string) {
  if (!query.trim()) return text;

  // Escape any special regex chars in the query
  const safeQuery = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  // Build a case-insensitive regex
  const regex = new RegExp(safeQuery, "gi");

  // Replace all matches with a <span> around them
  return text.replace(
    regex,
    (match) => `<p class="SearchDropdownHighlight">${match}</p>`
  );
}

const SearchDropdown: React.FC<SearchDropdownProps> = ({
  results,
  typedQuery,
  setShowDropdown,
}) => {
  const { settings } = useUser();
  const formatter = new Intl.NumberFormat("en-US", {
    notation: "compact",
    compactDisplay: "short",
  });
  return (
    <AnimatePresence>
      <motion.ul
        key="search-dropdown"
        initial={{ opacity: 0, filter: "blur(10px)" }}
        animate={{ opacity: 1, filter: "blur(0px)" }}
        exit={{ opacity: 0, filter: "blur(10px)" }}
        className="search-hints is-visible"
        role="listbox"
        id="search-hints"
        aria-labelledby="search-header-form-input-label"
      >
        {results.small.collection.slice(0, 3).map((result, index) => (
          <Link
            href={`/search?q=${result.query}`}
            key={result.query + "-" + index}
            aria-selected="false"
            className="search-hint"
            role="option"
            tabIndex={0}
            onClick={() => {
              setShowDropdown(false);
            }}
          >
            <span className="flex flex-col">
              {settings?.highlightedQueries ? (
                <p
                  className="search-hint-text truncate"
                  // Dangerously set the HTML with the highlight
                  dangerouslySetInnerHTML={{
                    __html: highlightText(result.query, typedQuery),
                  }}
                />
              ) : (
                <p className="search-hint-text truncate">{result.query}</p>
              )}
            </span>
          </Link>
        ))}
        <div className="search-hint-divider" />
        {results.large.collection.slice(0, 3).map((result, index) => (
          <Link
            href={
              result.kind === "playlist"
                ? `/album/${result.permalink}/${result.id}`
                : result.kind === "user"
                ? `/artist/${result.permalink}/${result.id}`
                : `/song/${result.permalink}/${result.id}`
            }
            key={result.title + "-" + result.id}
            aria-selected="false"
            className="search-hint"
            role="option"
            tabIndex={0}
            onClick={() => {
              setShowDropdown(false);
            }}
          >
            {result.kind === "track" && (
              <div className="relative aspect-square overflow-hidden mr-2 rounded w-[50px] after:absolute after:inset-0 after:z-20 after:rounded after:ring-1 after:ring-inset after:ring-white/10 transition-shadow">
                <Image
                  height={50}
                  width={50}
                  src={result.artwork_url || PLACEHOLDER_IMAGE.dark.url}
                  alt={result.title || ""}
                  className="search-hint-image"
                  unoptimized={true}
                />
              </div>
            )}
            {result.kind === "playlist" && (
              <div className="relative aspect-square overflow-hidden mr-2 rounded w-[50px] after:absolute after:inset-0 after:z-20 after:rounded after:ring-1 after:ring-inset after:ring-white/10 transition-shadow">
                <Image
                  height={50}
                  width={50}
                  src={
                    (result as unknown as SoundCloudAlbum).tracks[0]
                      .artwork_url || PLACEHOLDER_IMAGE.dark.url
                  }
                  alt={result.title || ""}
                  className="search-hint-image"
                  unoptimized={true}
                />
              </div>
            )}
            {result.kind === "user" && (
              <div className="relative aspect-square overflow-hidden mr-2 rounded-full w-[50px] after:absolute after:inset-0 after:z-20 after:rounded after:ring-1 after:ring-inset after:ring-white/10 transition-shadow">
                <Image
                  height={50}
                  width={50}
                  src={
                    (result as unknown as SoundCloudArtist).avatar_url ||
                    PLACEHOLDER_IMAGE.dark.url
                  }
                  alt={(result as unknown as SoundCloudArtist).username || ""}
                  onError={(e) => {
                    e.currentTarget.src = PLACEHOLDER_IMAGE.dark.url;
                  }}
                  className="search-hint-image"
                  unoptimized={true}
                />
              </div>
            )}
            <span className="flex flex-col">
              <p className="search-hint-text truncate text-[--systemPrimary]">
                {result.kind === "user"
                  ? (result as unknown as SoundCloudArtist).username
                  : result.title}
              </p>
              <p className="search-hint-text text-[0.65rem]">
                {result.kind === "user"
                  ? formatter.format(
                      (result as unknown as SoundCloudArtist).followers_count
                    ) + " followers"
                  : result.user.username}
              </p>
            </span>
          </Link>
        ))}
      </motion.ul>
    </AnimatePresence>
  );
};

export default SearchDropdown;


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\Sidebar.tsx
import { SidebarContent } from "./SidebarContent";
import style from "./Sidebar.module.css";
import Search from "./search/Search";
// TODO | Change the all the import paths with the @ symbol

export const Sidebar = () => {
  return (
    <div className={style.SidebarContainer} aria-label="Sidebar Container">
      <nav className={style.Sidebar} role="navigation" aria-label="Sidebar">
        <SidebarHeader />
        <SidebarContent />
      </nav>
    </div>
  );
};

const SidebarHeader = () => {
  return (
    <header className={style.SidebarHeader}>
      <div className={style.SidebarHeaderLogo}>
        <h1>Gaku</h1>
      </div>
      <Search />
    </header>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\SidebarContent.tsx
import React from "react";
import style from "./Sidebar.module.css";
import { LinearBlur } from "progressive-blur";
import Link from "next/link";
import { SidebarUserFooter } from "./SidebarUserFooter";
import { AiFillHome, AiFillClockCircle, AiFillHeart } from "react-icons/ai";
import { BiSolidAlbum, BiSolidPlaylist, BiSolidMusic } from "react-icons/bi";
import { FaUserAlt, FaListAlt } from "react-icons/fa";
import { IoMusicalNote } from "react-icons/io5";
import { useUser } from "@/hooks/useUser";

const libraryItems = [
  {
    href: "/library/recently-added",
    text: "Recently Added",
    icon: <AiFillClockCircle />,
  },
  { href: "/library/artists", text: "Artists", icon: <FaUserAlt /> },
  { href: "/library/albums", text: "Albums", icon: <BiSolidAlbum /> },
  { href: "/library/songs", text: "Songs", icon: <BiSolidMusic /> },
];

const playlistItems = [
  { href: "/playlists", text: "All Playlists", icon: <FaListAlt /> },
  // {
  //   href: "/2093-all-parts",
  //   text: "2093 (All Parts)",
  //   icon: <BiSolidPlaylist />,
  // },
];

const meItems = [
  { href: "/me/likes", text: "Your Likes", icon: <AiFillHeart /> },
  { href: "/me/playlists", text: "Your Playlists", icon: <FaListAlt /> },
  // {
  //   href: "/2093-all-parts",
  //   text: "2093 (All Parts)",
  //   icon: <BiSolidPlaylist />,
  // },
];

const pinnedItems = [
  {
    href: "/album/eternal-atake-2-1/1899041115",
    text: "Eternal Atake 2",
    icon: <IoMusicalNote />,
  },
];

export const SidebarContent = () => {
  return (
    <div className={style.SidebarContent}>
      <div className={style.SidebarContentScrollArea}>
        <ul className={style.SidebarList}>
          <Item href="/" text="Home" icon={<AiFillHome />} />

          <SectionLabel label="Library" />
          {libraryItems.map((item, index) => (
            <Item
              key={`library-${index}`}
              href={item.href}
              text={item.text}
              icon={item.icon}
            />
          ))}

          <SectionLabel title="Your Soundcloud Content" label="Me" />
          {meItems.map((item, index) => (
            <Item
              key={`me-${index}`}
              href={item.href}
              text={item.text}
              icon={item.icon}
            />
          ))}

          <SectionLabel label="Playlists" />
          {playlistItems.map((item, index) => (
            <Item
              key={`playlist-${index}`}
              href={item.href}
              text={item.text}
              icon={item.icon}
            />
          ))}

          <SectionLabel label="Pinned" />
          {pinnedItems.map((item, index) => (
            <Item
              key={`pinned-${index}`}
              href={item.href}
              text={item.text}
              icon={item.icon}
            />
          ))}
        </ul>
      </div>
      <div className={style.SidebarFooter}>
        <SidebarUserFooter />
        <span className="z-0 relative w-full grid">
          <div
            style={{
              zIndex: 1,
              width: "100%",
              height: "1rem",
              position: "absolute",
              bottom: 0,
              background: "var(--blur-tint-gradient)",
            }}
          />
          <LinearBlur
            style={{
              zIndex: 0,
              width: "100%",
              height: "2rem",
              position: "absolute",
              bottom: 0,
            }}
            side="bottom"
            tint="var(--blur-tint)"
          />
        </span>
      </div>
    </div>
  );
};

const SectionLabel = ({ label, title }: { label: string; title?: string }) => (
  <div title={title} className={style.SidebarSectionLabel}>
    {label}
  </div>
);

const Item = ({
  href,
  text,
  icon,
}: {
  href: string;
  text: string;
  icon?: React.ReactNode;
}) => {
  const { settings } = useUser();
  return (
    <li className={style.SidebarItem}>
      <Link href={href} className={style.SidebarItemLink}>
        {settings?.showSidebarIcons && icon && (
          <span className={style.SidebarItemIcon}>{icon}</span>
        )}
        <span>{text}</span>
      </Link>
    </li>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\navigation\SidebarUserFooter.tsx
import { useUser } from "@clerk/nextjs";
import Image from "next/image";
import Link from "next/link";
import { IoIosArrowForward } from "react-icons/io";
import { MiniSpinner } from "../extra/MiniSpinner";

export const SidebarUserFooter = () => {
  const { user, isLoaded } = useUser();

  if (!isLoaded) {
    return (
      <FooterContainer href="#">
        <div className="flex gap-2 items-center">
          <div className="bg-white/5 animate-pulse rounded-full size-8" />
          <MiniSpinner size="md" />
        </div>
        <div>
          <IoIosArrowForward className="fill-[--systemSecondary]" />
        </div>
      </FooterContainer>
    );
  }

  if (!user) {
    return (
      <FooterContainer href="/sign-in">
        <div className="flex gap-2 items-center">
          <div className="bg-white/5 rounded-full size-8" />
          Sign in
        </div>
        <div>
          <IoIosArrowForward className="fill-[--systemSecondary]" />
        </div>
      </FooterContainer>
    );
  }

  return (
    <FooterContainer href="/settings">
      <div className="flex gap-2 items-center">
        {user.imageUrl && (
          <div className="dark:bg-white/5 bg-black/5 flex items-center rounded-full size-8 overflow-hidden">
            <Image
              src={user.imageUrl}
              alt="User profile image"
              width={40}
              height={40}
              className="object-xx"
            />
          </div>
        )}
        {user.username || user.fullName || user.firstName}
      </div>
      <div>
        <IoIosArrowForward className="fill-[--systemSecondary]" />
      </div>
    </FooterContainer>
  );
};

const FooterContainer = ({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) => {
  return (
    <div className="z-10 relative mb-16 p-3">
      <Link href={href}>
        <div className="hover:bg-white/5 w-full p-2 rounded-[9px] flex justify-between items-center">
          {children}
        </div>
      </Link>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\Artwork.tsx
"use client";

import { useRef, useEffect } from "react";
import Image from "next/image";
import { motion, useMotionValue, useTransform, animate } from "framer-motion";
import style from "./PlayerBar.module.css";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";

interface ArtworkProps {
  src: string;
}

/**
 * Slower overshoot flip:
 *   forcibly sets rotateY=0, then 0→240→180
 *   blurVal from 10→0 over 1s
 */
export const Artwork: React.FC<ArtworkProps> = ({ src }) => {
  const THEMED_DEFAULT_IMAGE = useThemedPlaceholder();
  const finalSrc = src || THEMED_DEFAULT_IMAGE;
  const oldSrcRef = useRef(finalSrc);

  // Animate rotateY and blur values
  const rotateY = useMotionValue(0);
  const blurVal = useMotionValue(0);
  const filter = useTransform(blurVal, (val) => `blur(${val}px)`);

  useEffect(() => {
    if (finalSrc !== oldSrcRef.current) {
      // Reset rotation and set initial blur
      rotateY.set(0);
      const duration = 1;
      blurVal.set(5);
      animate(blurVal, 0, { duration });

      // Animate rotation with overshoot
      (async () => {
        await animate(rotateY, 180, {
          type: "spring",
          stiffness: 60,
          damping: 15,
          mass: 1.5,
          duration,
        });
        await animate(rotateY, 180, {
          type: "spring",
          stiffness: 60,
          damping: 15,
          mass: 1.5,
          duration,
        });
      })();

      oldSrcRef.current = finalSrc;
    }
  }, [finalSrc, rotateY, blurVal]);

  return (
    <motion.div
      className={style.Artwork}
      style={{
        rotateY,
        perspective: 1000,
        transformStyle: "preserve-3d",
        // Removed filter from here
      }}
    >
      <div
        style={{
          position: "relative",
          width: "100%",
          height: "100%",
          transformStyle: "preserve-3d",
          filter: filter as any,
        }}
      >
        {/* FRONT image */}
        <div
          style={{
            position: "absolute",
            inset: 0,
            backfaceVisibility: "visible",
          }}
        >
          <Image
            src={finalSrc}
            alt="Artwork Front"
            fill
            draggable={false}
            placeholder="blur"
            blurDataURL={THEMED_DEFAULT_IMAGE}
            onError={(e) => {
              e.currentTarget.src = THEMED_DEFAULT_IMAGE;
            }}
          />
        </div>

        {/* BACK image */}
        <div
          style={{
            position: "absolute",
            inset: 0,
            transform: "rotateY(180deg)",
            backfaceVisibility: "visible",
          }}
        >
          <Image
            src={finalSrc}
            alt="Artwork Back"
            fill
            draggable={false}
            placeholder="blur"
            blurDataURL={THEMED_DEFAULT_IMAGE}
            onError={(e) => {
              e.currentTarget.src = THEMED_DEFAULT_IMAGE;
            }}
          />
        </div>
      </div>
    </motion.div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\Audio.tsx
"use client";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { useEffect, useRef } from "react";
import ReactPlayer from "react-player";

export const Audio = () => {
  const {
    currentSong,
    isPlaying,
    nextSong,
    previousSong,
    duration,
    setPlayerRef,
    setIsPlaying,
    volume,
  } = useAudioStoreNew();
  const playerRef = useRef<ReactPlayer>(null);
  useEffect(() => {
    setPlayerRef(playerRef);
  }, [setPlayerRef]);

  useEffect(() => {
    if ("mediaSession" in navigator) {
      const isIPhone = /iPhone/i.test(navigator.userAgent);
      const displayTitle =
        isIPhone && currentSong?.explicit
          ? `${currentSong?.name} 🅴`
          : currentSong?.name;
      navigator.mediaSession.metadata = new MediaMetadata({
        title: displayTitle || "Unknown Title",
        artist: currentSong?.artist.name || "Unknown Artist",
        album: currentSong?.albumName || "",
        artwork: [
          {
            src: currentSong?.artwork.hdUrl || "default-image.jpg",
            sizes: "512x512",
            type: "image/png",
          },
        ],
      });

      navigator.mediaSession.setActionHandler("play", () => {
        setIsPlaying(true);
      });
      navigator.mediaSession.setActionHandler("pause", () => {
        setIsPlaying(false);
      });
      navigator.mediaSession.setActionHandler("nexttrack", () => {
        nextSong();
      });
      navigator.mediaSession.setActionHandler("previoustrack", () => {
        previousSong();
      });
      navigator.mediaSession.setActionHandler("seekto", (details) => {
        if (details.seekTime && playerRef.current) {
          playerRef.current.seekTo(details.seekTime, "seconds");
        }
      });
      const updatePositionState = () => {
        if (playerRef.current) {
          const internalPlayer = playerRef.current.getInternalPlayer();
          navigator.mediaSession.setPositionState({
            duration: duration,
            playbackRate: internalPlayer ? internalPlayer.playbackRate : 1,
            position: playerRef.current.getCurrentTime(),
          });
        }
      };
      const positionUpdateInterval = setInterval(updatePositionState, 1000);
      return () => {
        clearInterval(positionUpdateInterval);
      };
    }
  }, [currentSong, isPlaying, duration, nextSong, previousSong, setIsPlaying]);

  return (
    <ReactPlayer
      ref={playerRef}
      url={currentSong?.src}
      playing={isPlaying}
      onEnded={nextSong}
      volume={volume}
      onProgress={({ playedSeconds }) =>
        useAudioStoreNew.getState().setCurrentTime(playedSeconds)
      }
      onDuration={(duration) =>
        useAudioStoreNew.getState().setDuration(duration)
      }
      width="0px"
      height="0px"
    />
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\Controls.tsx
import React from "react";
import style from "./Controls.module.css";
import { IoPlay, IoPlayBack, IoPlayForward } from "react-icons/io5";
import { PiPauseFill } from "react-icons/pi";
import { motion } from "framer-motion";
import { useAudioStoreNew } from "@/context/AudioContextNew";

export const Controls = () => {
  const { currentSong, isPlaying, setIsPlaying, nextSong, previousSong } =
    useAudioStoreNew();
  const handlePlayPause = () => {
    if (!currentSong) return;
    setIsPlaying(!isPlaying);
  };
  return (
    <div data-name="Controls Container" className={style.ControlsContainer}>
      <ControlButtons
        playing={isPlaying}
        onPlayPause={handlePlayPause}
        onNext={nextSong}
        onPrev={previousSong}
      />
    </div>
  );
};

const ControlButtons = ({
  playing,
  onPlayPause,
  onNext,
  onPrev,
}: {
  playing: boolean;
  onPlayPause: () => void;
  onNext: () => void;
  onPrev?: () => void;
}) => {
  const buttonMotionProps = {
    whileHover: { backgroundColor: "rgba(255, 255, 255, 0.05)" },
    whileTap: {
      scale: 0.85,
      backgroundColor: "rgba(255, 255, 255, 0.1)",
    },
    transition: { duration: 0.125, ease: "easeInOut" },
    className: "flex flex-col items-center rounded-full p-2",
  };

  return (
    <div className="flex items-center gap-2">
      <motion.button {...buttonMotionProps} onClick={onPrev}>
        <IoPlayBack size={26} />
      </motion.button>
      <motion.button {...buttonMotionProps} onClick={onPlayPause}>
        {playing ? <PiPauseFill size={26} /> : <IoPlay size={26} />}
      </motion.button>
      <motion.button {...buttonMotionProps} onClick={onNext}>
        <IoPlayForward size={26} />
      </motion.button>
    </div>
  );
};


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\FullScreenButton.tsx
import { Attributes, useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { LucideFullscreen } from "lucide-react";
import dynamic from "next/dynamic";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";
import Image from "next/image";
import { CloseButton } from "@/components/player/new/controls/components/CloseButton";
import {
  AppleCover,
  buttonMotionProps,
  DurationSlider,
  ExpandedPlayerControls,
  formatTime,
  LyricButton,
  OptionsButton,
  VolumeSlider,
} from "@/components/player/new/controls/Controls";
import { showToast } from "@/hooks/useToast";
import Link from "next/link";

// Using dynamic imports with loading strategy to optimize performance
const AppleLyrics = dynamic(
  () =>
    import("../../../components/player/new/lyrics/AppleLyrics").then(
      (mod) => mod.AppleLyrics
    ),
  {
    ssr: false,
    loading: () => (
      <div className="flex items-center justify-center h-full w-full">
        <span className="text-white/50">Loading lyrics...</span>
      </div>
    ),
  }
);

const BackgroundRender = dynamic(
  () =>
    import("@applemusic-like-lyrics/react").then((mod) => mod.BackgroundRender),
  {
    ssr: false,
  }
);

const FullScreenButton = () => {
  const setFullscreen = useAudioStoreNew((state) => state.setFullscreen);
  return (
    <motion.button onClick={() => setFullscreen(true)} {...buttonMotionProps}>
      <LucideFullscreen />
    </motion.button>
  );
};

const Screen = () => {
  const {
    isFullscreen,
    setFullscreen,
    currentSong,
    isPlaying,
    setIsPlaying,
    nextSong,
    previousSong,
    setVolume,
    volume,
  } = useAudioStoreNew();
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();

  const currentTime = useAudioStoreNew((state) => state.currentTime ?? 0);
  const duration = useAudioStoreNew((state) => state.duration ?? 0);
  const seek = useAudioStoreNew((state) => state.seek);

  const handleSeekChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTime = parseFloat(e.target.value);
    seek(newTime);
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
  };

  const [lyricsVisible, setLyricsVisible] = useState(false);
  const toggleLyrics = () => setLyricsVisible((prev) => !prev);

  const optionsButton = () =>
    showToast("warning", "Options not implemented yet");

  // Optimize heavy components when in fullscreen
  useEffect(() => {
    if (isFullscreen) {
      // Pause any intensive animations or calculations in background components
      document.body.classList.add("fullscreen-active");
      // Prevent scrolling when fullscreen is active
      document.body.style.overflow = "hidden";
    } else {
      document.body.classList.remove("fullscreen-active");
      // Restore scrolling when fullscreen is inactive
      document.body.style.overflow = "";
    }

    return () => {
      document.body.classList.remove("fullscreen-active");
      document.body.style.overflow = "";
    };
  }, [isFullscreen]);

  const controlsBaseProps = {
    className:
      "controlsBase fixed inset-0 flex flex-col bg-black text-white z-[110] standalone:pt-10 !visible !pointer-events-auto",
    initial: { opacity: 0, filter: "blur(10px)" },
    animate: { opacity: 1, filter: "blur(0px)" },
    exit: { opacity: 0, filter: "blur(10px)" },
    transition: { duration: 0.3, ease: "easeInOut" },
  };

  return (
    <AnimatePresence>
      {isFullscreen && (
        <motion.div
          style={{
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            height: "100vh",
            width: "100vw",
          }}
          {...controlsBaseProps}
        >
          <motion.div className="flex justify-start z-20 absolute w-full pointer-events-none">
            <CloseButton onClick={() => setFullscreen(false)} />
          </motion.div>
          <motion.div className="flex-1 flex items-center justify-center z-10">
            <motion.span
              layout="preserve-aspect"
              className="justify-center h-full flex-col items-center flex w-full"
            >
              <motion.div
                layout="position"
                layoutId="playerImage"
                className="relative"
              >
                <Image
                  className="rounded-[1rem] blur-md opacity-25 translate-y-1 select-none"
                  src={
                    currentSong?.artwork?.hdUrl ||
                    currentSong?.artwork?.url ||
                    PLACEHOLDER_IMAGE
                  }
                  alt={currentSong?.name || "Missing Image"}
                  width={400}
                  height={400}
                  quality={10}
                  unoptimized={true}
                  draggable={false}
                />
                <span className="absolute inset-0 flex items-center justify-center">
                  <AppleCover
                    isAnimated={Boolean(currentSong?.artwork?.animatedURL)}
                    isDesktop={true}
                    song={currentSong || undefined}
                  />
                </span>
              </motion.div>
              <motion.div
                layout="position"
                className="w-[25rem] max-md:w-[20rem] flex-col mt-3 flex justify-center items-center"
              >
                <motion.div
                  layout="position"
                  layoutId="playerInfo"
                  className="flex justify-between items-center w-full"
                >
                  <motion.div className="flex flex-col">
                    <motion.h2
                      layout="position"
                      layoutId="playerTitle"
                      className="text-lg text-left font-semibold"
                    >
                      {currentSong?.name}
                    </motion.h2>
                    <motion.h2
                      layout="position"
                      layoutId="playerArtist"
                      className="text-sm text-left text-white/75 cursor-pointer hover:underline"
                    >
                      <Link
                        href={`/artist/${currentSong?.artist.id}/${currentSong?.artist.id}`}
                        onClick={(e) => {
                          // If we're already on the artist page, don't navigate:
                          setFullscreen(false);
                          if (
                            window.location.pathname.includes(
                              currentSong?.artist.id?.toString() || ""
                            )
                          ) {
                            e.preventDefault(); // Prevent Link's normal routing
                            setFullscreen(false);
                          }
                        }}
                      >
                        {currentSong?.artist.name}
                      </Link>
                    </motion.h2>
                  </motion.div>
                  <motion.div className="flex gap-2">
                    <LyricButton
                      active={lyricsVisible}
                      onClick={toggleLyrics}
                    />
                    <OptionsButton onClick={optionsButton} />
                  </motion.div>
                </motion.div>
                <motion.div
                  layout="position"
                  layoutId="playerControls"
                  className="flex-col mt-4 flex items-center w-full gap-2"
                >
                  <div className="flex w-full items-center gap-2">
                    <span className="text-xs text-white/75 select-none">
                      {formatTime(currentTime)}
                    </span>
                    <DurationSlider
                      duration={duration}
                      currentTime={currentTime}
                      onChange={handleSeekChange}
                    />
                    <span
                      className="text-xs text-white/75 select-none cursor-pointer"
                      onClick={() => {
                        const timeLeftElement =
                          document.getElementById("timeLeft");
                        if (timeLeftElement) {
                          const isShowingTotal =
                            timeLeftElement.dataset.showing === "total";
                          timeLeftElement.dataset.showing = isShowingTotal
                            ? "remaining"
                            : "total";
                          timeLeftElement.textContent = isShowingTotal
                            ? `-${formatTime(duration - currentTime)}`
                            : formatTime(duration);
                        }
                      }}
                    >
                      <span id="timeLeft" data-showing="total">
                        {formatTime(duration)}
                      </span>
                    </span>
                  </div>
                  <div>
                    <ExpandedPlayerControls
                      onPlayPause={() => setIsPlaying(!isPlaying)}
                      playing={isPlaying}
                      onNext={nextSong}
                      onPrev={previousSong}
                    />
                  </div>
                  <div className="flex items-center w-full justify-between">
                    <VolumeSlider
                      onChange={handleVolumeChange}
                      volume={volume}
                    />
                  </div>
                </motion.div>
              </motion.div>
            </motion.span>
            {lyricsVisible && (
              <motion.span
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="flex flex-col size-full items-center justify-center"
              >
                <AppleLyrics />
              </motion.span>
            )}
          </motion.div>
          <BackgroundRender
            fps={24}
            playing={isPlaying}
            style={{
              position: "fixed",
              width: "100%",
              height: "100%",
              inset: "0",
              // zIndex: 1,
            }}
            album={currentSong?.artwork.url}
          />
        </motion.div>
      )}
    </AnimatePresence>
  );
};

const FullScreen = () => {
  return (
    <>
      <Screen key="expanded" />
    </>
  );
};

FullScreen.Button = FullScreenButton;
FullScreen.Screen = Screen;
export { FullScreen };


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\PlayerBar.tsx
"use client";
import React, { memo, useState } from "react";
import style from "./PlayerBar.module.css";
import { Artwork } from "./Artwork";
import { TrackInfo } from "./TrackInfo";
import { Controls } from "./Controls";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import { motion } from "framer-motion";
import { FullScreen } from "./FullScreenButton";
import { useThemedPlaceholder } from "@/lib/utils/themedPlaceholder";

const EXAMPLE_ALBUM_COVER =
  "https://is1-ssl.mzstatic.com/image/thumb/Music122/v4/bd/3b/a9/bd3ba9fb-9609-144f-bcfe-ead67b5f6ab3/196589564931.jpg/1000x1000bb.jpg";

export const PlayerBar = () => {
  return (
    <div className={style.PlayerBar}>
      <Player />
    </div>
  );
};

const Player = memo(() => {
  const { currentSong } = useAudioStoreNew();
  const PLACEHOLDER_IMAGE = useThemedPlaceholder();
  return (
    <>
      <motion.div className={style.Player}>
        <div
          data-name="Track Info and Artwork"
          className={style.TrackInfoAndArtwork}
        >
          <Artwork
            src={
              currentSong?.artwork.hdUrl ||
              currentSong?.artwork.url ||
              PLACEHOLDER_IMAGE
            }
          />
          <TrackInfo />
        </div>
        <Controls />
        <FullScreen.Button />
      </motion.div>
      <FullScreen.Screen />
    </>
  );
});

Player.displayName = "Player";


\c\Users\covaw\Desktop\Desktop\Coding\Gaku\musicpla\src\rework\components\player\TrackInfo.tsx
"use client";
import { useAudioStoreNew } from "@/context/AudioContextNew";
import Link from "next/link";
import { useRouter } from "next/navigation";

export const TrackInfo = () => {
  const { currentSong } = useAudioStoreNew();
  if (!currentSong) {
    return (
      <div className="px-2 grid items-center" aria-label="Track Info">
        <span aria-label="No Song" className="flex gap-1">
          <h2 style={{ fontWeight: 500 }}>No song playing</h2>
        </span>
      </div>
    );
  }
  return (
    <div className="grid items-center px-2" aria-label="Track Info">
      <span
        aria-label={`Name of the track: ${currentSong.name}`}
        className="flex gap-1"
      >
        <h2 style={{ fontWeight: 500 }}>{currentSong.name}</h2>
        {currentSong.explicit && <span className="text-[#aeaeae]">🅴</span>}
      </span>
      <Link
        href={currentSong.artist.url}
        style={{ fontWeight: 400, opacity: 0.7 }}
        aria-label={`Name of the artist: ${currentSong.artist.name}`}
        className="w-fit hover:underline cursor-pointer -mt-2"
      >
        {currentSong.artist.name}
      </Link>
    </div>
  );
};


